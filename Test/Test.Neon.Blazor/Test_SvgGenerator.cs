// -----------------------------------------------------------------------------
// FILE:	    Test_SvgGenerator.cs
// CONTRIBUTOR: NEONFORGE Team
// COPYRIGHT:   Copyright Â© 2005-2023 by NEONFORGE LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Threading;

using FluentAssertions;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

using Neon.Blazor.Analyzers;

using Xunit;

using static System.Net.Mime.MediaTypeNames;

namespace Test.Neon.Blazor
{
    public class Test_SvgGenerator
    {
        [Fact]
        public void SimpleGeneratorTest()
        {
            var svg = @"<svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 24 24"">
  <path d=""M4 5v11h16V5H4Zm-2-.993C2 3.451 2.455 3 2.992 3h18.016c.548 0 .992.449.992 1.007V18H2V4.007ZM1 19h22v2H1v-2Z""/>
</svg>";

            Compilation compilation = CreateCompilation(string.Empty);

            List<AdditionalText> additionalTexts = new List<AdditionalText>
            {
                new CustomAdditionalText("foo.svg", svg)
            };

            Compilation newComp = RunGenerators(
                compilation,
                ImmutableArray.CreateRange(additionalTexts),
                out ImmutableArray<Diagnostic> generatorDiags,
                new SvgGenerator());

            IEnumerable<SyntaxTree> generatedTrees = newComp.RemoveSyntaxTrees(compilation.SyntaxTrees).SyntaxTrees;

            generatedTrees.Should().HaveCount(1);
            generatorDiags.Should().BeNullOrEmpty();

            var generatedCode = generatedTrees.First().ToString();

            generatedCode.TrimEnd().Should().BeEquivalentTo(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the NeonFORGE Blazor SDK.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Linq;

using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;

#pragma warning disable CS1591 // Disable warnings for missing comments.

namespace Neon.Blazor.Svg
{
    public partial class Foo : ComponentBase
    {
        /// <summary>
        /// Catch all for additional attributes.
        /// </summary>
        [Parameter(CaptureUnmatchedValues = true)]
        public IReadOnlyDictionary<string, object> AdditionalAttributes { get; set; } = new Dictionary<string, object>();

        private Dictionary<string, object> Attributes { get; set; }

        private string baseClass = """";
        private string fill = """";
        private string stroke = """";

        protected override void OnParametersSet()
        {
            Attributes = GetDefaultAttributes();

            var classes = new List<string>();

            if (!string.IsNullOrEmpty(baseClass))
            {
                classes = baseClass.Split(null).ToList();
            }

            if (AdditionalAttributes.TryGetValue(""class"", out var additionalClasses))
            {
                classes.AddRange(((string)additionalClasses).Split(null));
            }

            if (classes.Count > 0)
            {
                Attributes[""class""] = string.Join("" "", classes.ToHashSet());
            }

            if (AdditionalAttributes.TryGetValue(""fill"", out var _fill))
            {
                Attributes[""fill""] = _fill;
            }
            else if (!string.IsNullOrEmpty(fill))
            {
                Attributes[""fill""] = fill;
            }

            if (AdditionalAttributes.TryGetValue(""stroke"", out var _stroke))
            {
                Attributes[""stroke""] = _stroke;
            }
            else if (!string.IsNullOrEmpty(stroke))
            {
                Attributes[""stroke""] = stroke;
            }

            StateHasChanged();

            base.OnParametersSet();
        }

        protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
            builder.OpenElement(0, ""svg"");

            if (Attributes.Count > 0)
            {
                builder.AddMultipleAttributes(1, Attributes.Select(a => new KeyValuePair<string, object>(a.Key, a.Value)));
            }

            builder.AddMarkupContent(2, @""<path d=""""M4 5v11h16V5H4Zm-2-.993C2 3.451 2.455 3 2.992 3h18.016c.548 0 .992.449.992 1.007V18H2V4.007ZM1 19h22v2H1v-2Z"""" xmlns=""""http://www.w3.org/2000/svg"""" />"");
            builder.CloseElement();
        }

        private static Dictionary<string, object> GetDefaultAttributes()
        {
            var attributes = new Dictionary<string, object>();
            attributes.Add(""viewBox"", @""0 0 24 24"");

            return attributes;
        }
    }
}
#pragma warning restore CS1591 // Restore warnings for missing comments.");
        }

        private static Compilation CreateCompilation(string source, OutputKind outputKind = OutputKind.ConsoleApplication)
        {
            return CSharpCompilation.Create("compilation",
                new[] { CSharpSyntaxTree.ParseText(source, new CSharpParseOptions(LanguageVersion.Preview)) },
                new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
                new CSharpCompilationOptions(outputKind));
        }

        private static GeneratorDriver CreateDriver(Compilation c, params ISourceGenerator[] generators)
            => CSharpGeneratorDriver.Create(generators, parseOptions: (CSharpParseOptions)c.SyntaxTrees.First().Options);

        private static Compilation RunGenerators(
            Compilation c,
            ImmutableArray<AdditionalText> additionalTexts,
            out ImmutableArray<Diagnostic> diagnostics,
            params ISourceGenerator[] generators)
        {
            CreateDriver(c, generators).AddAdditionalTexts(additionalTexts).RunGeneratorsAndUpdateCompilation(c, out var d, out diagnostics);
            return d;
        }
    }

    /// <summary>
    /// Represents an additional text file.
    /// </summary>
    public class CustomAdditionalText : AdditionalText
    {
        private readonly string _text;

        /// <inheritdoc/>
        public override string Path { get; }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="path"></param>
        /// <param name="text"></param>
        public CustomAdditionalText(string path, string text)
        {
            Path = path;
            _text = text;
        }

        /// <inheritdoc/>
        public override SourceText GetText(CancellationToken cancellationToken = new CancellationToken())
        {
            return SourceText.From(_text);
        }
    }
}