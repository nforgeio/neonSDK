<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neon.Common</name>
    </assembly>
    <members>
        <member name="T:Neon.Build">
            <summary>
            Neon build constants.
            </summary>
        </member>
        <member name="F:Neon.Build.Company">
            <summary>
            The company name to use for all Neon assemblies.
            </summary>
        </member>
        <member name="F:Neon.Build.Copyright">
            <summary>
            The copyright statement to be included in all assemblies.
            </summary>
        </member>
        <member name="F:Neon.Build.Trademark">
            <summary>
            Trademark statement.
            </summary>
        </member>
        <member name="F:Neon.Build.ProductName">
            <summary> 
            The product name.
            </summary>
        </member>
        <member name="F:Neon.Build.NeonSdkVersion">
            <summary>
            <para>
            The released library/package version.
            </para>
            <note>
            <b>WARNING:</b> Do not rename this constant without updating the relevant 
            release scripts to match.
            </note>
            </summary>
        </member>
        <member name="F:Neon.Build.ProductLicense">
            <summary>
            The product license.
            </summary>
        </member>
        <member name="F:Neon.Build.ProductLicenseUrl">
            <summary>
            The product license URL.
            </summary>
        </member>
        <member name="F:Neon.Build.Configuration">
            <summary>
            The build configuration.
            </summary>
        </member>
        <member name="T:Neon.BuildEnvironment">
            <summary>
            Describes the build environment. 
            </summary>
        </member>
        <member name="P:Neon.BuildEnvironment.BuildMachine">
            <summary>
            Returns the build machine name.
            </summary>
        </member>
        <member name="P:Neon.BuildEnvironment.BuildRootPath">
            <summary>
            Returns the fully qualified path to the build root folder.
            </summary>
        </member>
        <member name="P:Neon.BuildEnvironment.BuildArtifactPath">
            <summary>
            Returns the fully qualified path to the build artifacts folder.
            </summary>
        </member>
        <member name="T:Neon.Collections.ArgDictionary">
            <summary>
            A dictionary of objects keyed by case sensitive strings.
            </summary>
        </member>
        <member name="T:Neon.Collections.Bits">
            <summary>
            Implements an efficient array of boolean values that can also
            perform bit oriented operations such as AND, OR, NOT, XOR.
            </summary>
            <remarks>
            <note>
            This class is similar to the .NET <see cref="T:System.Collections.BitArray"/> class.  The main
            difference is that this class serializes the bits to a byte array as you'd
            expect, with bit zero being the most significant bit of the first byte,
            bit one being the second significant bit, etc.  The <see cref="T:System.Collections.BitArray"/>
            class serializes the first bit to the least significant bit of the first byte.
            </note>
            <para>
            A <see cref="T:Neon.Collections.Bits" /> bitmap encodes internally as an array of 32-bit integers which
            is much more memory efficent than how the .NET Framework would encode an
            array of boolean values.  Use the <see cref="M:Neon.Collections.Bits.#ctor(System.Int32)" /> constructor to
            create a zeroed bitmap with the specified number of bits, <see cref="M:Neon.Collections.Bits.#ctor(System.Boolean[])" />
            to initialize the bitmap from a boolean array, or <see cref="M:Neon.Collections.Bits.#ctor(System.String)" />
            to create a bitmap from a string of ones and zeros, and <see cref="M:Neon.Collections.Bits.#ctor(System.Byte[],System.Int32)" />
            to load a bitmap from a byte array serialized by a previous call to <see cref="M:Neon.Collections.Bits.ToBytes" />.
            </para>
            <para>
            You can use the indexer to get/set specific bits in the bitmap.  Note that all
            indexes are zero-based.  <see cref="M:Neon.Collections.Bits.ClearRange(System.Int32,System.Int32)" /> sets the specified range of 
            bits to zero, <see cref="M:Neon.Collections.Bits.SetRange(System.Int32,System.Int32)" /> sets the specified range of bits to one,
            and <see cref="M:Neon.Collections.Bits.ClearAll" /> and <see cref="M:Neon.Collections.Bits.SetAll" /> sets all bits to the 
            appropriate value.  <see cref="M:Neon.Collections.Bits.Resize(System.Int32)" /> can be used to resize a bitmap.
            </para>
            <para>
            The class implements the following bitwise operations: <see cref="M:Neon.Collections.Bits.Not" />, <see cref="M:Neon.Collections.Bits.And(Neon.Collections.Bits)" />,
            <see cref="M:Neon.Collections.Bits.Or(Neon.Collections.Bits)" />, <see cref="M:Neon.Collections.Bits.Xor(Neon.Collections.Bits)" />, <see cref="M:Neon.Collections.Bits.ShiftLeft(System.Int32)" />, and <see cref="M:Neon.Collections.Bits.ShiftRight(System.Int32)" />.
            Note that the lengths of the two bitmaps passed to binary operations must be the same.
            </para>
            <para>
            <see cref="M:Neon.Collections.Bits.Clone" /> returns a copy of the bitmap and <see cref="M:Neon.Collections.Bits.ToArray" /> converts the
            bitmap into a boolean array.  The <see cref="P:Neon.Collections.Bits.IsAllZeros" /> and <see cref="P:Neon.Collections.Bits.IsAllOnes" /> properties
            can be used to determine if a bitmap is all zeros or ones and <see cref="M:Neon.Collections.Bits.Equals(System.Object)" /> can be
            used to determine whether two bitmaps are the same.  <see cref="M:Neon.Collections.Bits.ToString" /> renders the bitmap
            as a string of 1s and 0s.
            </para>
            <para>
            This class also defines explict casts for converting to and from a string of ones and zeros
            and also defines the bitwise <b>||</b>, <b>&amp;</b>, <b>~</b> and <b>^</b>,
            <b>&lt;&lt;</b>, and <b>&gt;&gt;</b> operators.
            </para>
            </remarks>
        </member>
        <member name="F:Neon.Collections.Bits.IntBitMask">
            <summary>
            32-bit oriented bit position masks.
            </summary>
        </member>
        <member name="F:Neon.Collections.Bits.ByteBitMasks">
            <summary>
            8-bit oriented serialization bit positions masks.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.op_Explicit(Neon.Collections.Bits)~System.String">
            <summary>
            Casts a <see cref="T:Neon.Collections.Bits" /> instance into a bit string of ones and zeros.
            </summary>
            <param name="bits">The bitmap.</param>
            <returns>The bit string.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.op_Explicit(System.String)~Neon.Collections.Bits">
            <summary>
            Casts a bit string of ones and zeros into a <see cref="T:Neon.Collections.Bits" /> bitmap.
            </summary>
            <param name="bitString">The bit string.</param>
            <returns>The bitmap.</returns>
            <exception cref="T:System.FormatException">Thrown if <paramref name="bitString"/> contains a character other than a 1 or 0.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_OnesComplement(Neon.Collections.Bits)">
            <summary>
            Returns the bitwise <b>not</b> on a bitmap.
            </summary>
            <param name="bits">The source bitmap.</param>
            <returns>The output bitmap.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.op_BitwiseAnd(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Returns the intersection of two bitmaps.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns>The intersection.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_BitwiseOr(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Returns the union of two bitmaps.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns>The union.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_ExclusiveOr(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Returns the exclusive or of two bitmaps.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns>The exclusive-or of the bits.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_LeftShift(Neon.Collections.Bits,System.Int32)">
            <summary>
            Left shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="input">The input bitmap.</param>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted left past position zero will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.op_RightShift(Neon.Collections.Bits,System.Int32)">
            <summary>
            Right shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="input">The input bitmap.</param>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted right past the end of the bitmap will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.op_Equality(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Determines whether two bitmaps contain the same values.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns><c>true</c> if the bitmaps are the same.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.op_Inequality(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Determines whether two bitmaps do not contain the same values.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns><c>true</c> if the bitmaps are the same.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Int32)">
            <summary>
            Constructs a zeroed bitmap of a specified length.
            </summary>
            <param name="length">The bitmap length.</param>
            <exception cref="T:System.ArgumentException">Thrown is <paramref name="length" /> is negative.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Boolean[])">
            <summary>
            Constructs a bitmap from a boolean array.
            </summary>
            <param name="array">The array.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="array" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.String)">
            <summary>
            Constructs a bitmap by parsing a string of 1s and 0s.
            </summary>
            <param name="bitString">The bit string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="bitString" /> is <c>null</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if <paramref name="bitString"/> contains a character other than a 1 or 0.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Byte[])">
            <summary>
            Constructs a bitmap from a an array of bytes.
            </summary>
            <param name="bytes">The byte array.</param>
            <remarks>
            This constructor is useful for deserializing bitmaps persisted to a binary structure.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="bytes" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Byte[],System.Int32)">
            <summary>
            Constructs a bitmap from a specified number of bits from an array of bytes.
            </summary>
            <param name="bytes">The byte array.</param>
            <param name="length">
            Specifies length of the bitmap to be created.
            </param>
            <remarks>
            This constructor is useful for deserializing bitmaps persisted to a binary structure.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="bytes" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown is <paramref name="length" /> is negative.</exception>
            <remarks>
            <note>
            The byte array may be larger or smaller than the implied number of bits
            as compared to the <paramref name="length" /> parameter.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Collections.Bits.Length">
            <summary>
            Returns the length of the bitmap.
            </summary>
        </member>
        <member name="P:Neon.Collections.Bits.Item(System.Int32)">
            <summary>
            Gets or sets a bit in the bitmap.
            </summary>
            <param name="index">The zero-based index of the bit.</param>
            <returns>The bit value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throw if the <paramref name="index" /> is not in range.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.ClearRange(System.Int32,System.Int32)">
            <summary>
            Zeros a number of bits starting at an index.
            </summary>
            <param name="index">The start index.</param>
            <param name="count">Number of bits.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the <paramref name="index"/> or <paramref name="count"/> is out of range.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.ClearAll">
            <summary>
            Zeros all bits.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.SetRange(System.Int32,System.Int32)">
            <summary>
            Sets a number of bits starting at an index.
            </summary>
            <param name="index">The start index.</param>
            <param name="count">Number of bits.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the <paramref name="index"/> or <paramref name="count"/> is out of range.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.SetAll">
            <summary>
            Sets all bits.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.Resize(System.Int32)">
            <summary>
            Creates a new bitmap from the current instance, but resized to contain
            the specified number of bits.
            </summary>
            <param name="length">The length desired for the new bitmap.</param>
            <returns>The resized bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="length" /> is negative.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.Not">
            <summary>
            Returns a bitmap that inverts all the bits of the current bitmap.
            </summary>
            <returns>The inverted <see cref="T:Neon.Collections.Bits" />.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.And(Neon.Collections.Bits)">
            <summary>
            Performs a bitwise <b>and</b> on the <paramref name="bits"/> passed and the
            current bits and returns the result.
            </summary>
            <param name="bits">The source <see cref="T:Neon.Collections.Bits" />.</param>
            <returns>A new <see cref="T:Neon.Collections.Bits" /> instance with the intersection.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.Or(Neon.Collections.Bits)">
            <summary>
            Performs a bitwise <b>or</b> on the <paramref name="bits"/> passed and the
            current bits and returns the result.
            </summary>
            <param name="bits">The source <see cref="T:Neon.Collections.Bits" />.</param>
            <returns>A new <see cref="T:Neon.Collections.Bits" /> instance with the union.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.Xor(Neon.Collections.Bits)">
            <summary>
            Performs a bitwise <b>xor</b> on the <paramref name="bits"/> passed and the
            current bits and returns the result.
            </summary>
            <param name="bits">The source <see cref="T:Neon.Collections.Bits" />.</param>
            <returns>A new <see cref="T:Neon.Collections.Bits" /> instance with the exclusive or results.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.ShiftLeft(System.Int32)">
            <summary>
            Left shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted left past position zero will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.ShiftRight(System.Int32)">
            <summary>
            Right shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted right past the end of the bitmap will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.Clone">
            <summary>
            Returns a clone of the bitmap.
            </summary>
            <returns>The cloned copy.</returns>
        </member>
        <member name="P:Neon.Collections.Bits.IsAllZeros">
            <summary>
            Returns <c>true</c> if all of the bits are set to zeros.
            </summary>
        </member>
        <member name="P:Neon.Collections.Bits.IsAllOnes">
            <summary>
            Returns <c>true</c> if all of the bits are set to ones.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.Equals(System.Object)">
            <summary>
            Determines if the bitmap passed is equal to the current bitmap.
            </summary>
            <param name="obj">The instance to be compared.</param>
            <returns><c>true</c> of the bitmaps are equal.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.GetHashCode">
            <summary>
            Computes a hash code for the instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.ToArray">
            <summary>
            Converts the bitmap into a boolean array.
            </summary>
            <returns>The boolean array.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.ToBytes">
            <summary>
            Converts the bitmap into an array of bytes.
            </summary>
            <returns>The byte array.</returns>
            <remarks>
            This method is useful for serializing bitmaps for storage in a binary structure.
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.ToString">
            <summary>
            Renders the bitmap as a string of ones and zeros.
            </summary>
            <returns>The bitmap string.</returns>
        </member>
        <member name="T:Neon.Collections.IObjectDictionary">
            <summary>
            Describes dictionaries mapping case-sensitive strings to objects along with nice 
            generic methods that converts item values to specific types.
            </summary>
        </member>
        <member name="M:Neon.Collections.IObjectDictionary.Get``1(System.String)">
            <summary>
            Returns the value of an item converted to a specific type.
            </summary>
            <typeparam name="TValue">The result type.</typeparam>
            <param name="key">The key.</param>
            <returns>The value converted to <typeparamref name="TValue"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if key is <c>null</c>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown by the getter if the key doesn't exist.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if the item value cannot be cast into a <typeparamref name="TValue"/>.</exception>
        </member>
        <member name="M:Neon.Collections.IObjectDictionary.Get``1(System.String,``0)">
            <summary>
            Returns the value of an item converted to a specific type.
            </summary>
            <typeparam name="TValue">The result type.</typeparam>
            <param name="key">The key.</param>
            <param name="default">Secifies the default value to return if the key doesn't exist.</param>
            <returns>The value converted to <typeparamref name="TValue"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if key is <c>null</c>.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if the item value cannot be cast into a <typeparamref name="TValue"/>.</exception>
        </member>
        <member name="M:Neon.Collections.IObjectDictionary.TryGetValue``1(System.String,``0@)">
            <summary>
            Attempts to retrieve a specific value from the dictionary.
            </summary>
            <typeparam name="TValue">The result type.</typeparam>
            <param name="key">The key.</param>
            <param name="value">Returns as the value when the key exists.</param>
            <returns><c>true</c> if the key exists and the value was returned.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if key is <c>null</c>.</exception>
        </member>
        <member name="T:Neon.Collections.NamespaceDoc">
            <summary>
            This namespace defines a handful of probably archaic custom collection classes.
            </summary>
        </member>
        <member name="T:Neon.Collections.NiceDictionary`2">
            <summary>
            A dictionary of values where the indexer will return the default value
            for keys that don't map to an item.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="P:Neon.Collections.NiceDictionary`2.Item(`0)">
            <summary>
            Accesses the value associated with a specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>
            The associated value or the <c>default</c> value for the
            type when there's no associated value.
            </returns>
        </member>
        <member name="T:Neon.Collections.ObjectDictionary">
            <summary>
            Describes dictionaries mapping case-sensitive strings to objects along with nice 
            generic methods that converts item values to specific types.
            </summary>
        </member>
        <member name="M:Neon.Collections.ObjectDictionary.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Collections.ObjectDictionary.Get``1(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Collections.ObjectDictionary.Get``1(System.String,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Collections.ObjectDictionary.TryGetValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.Block">
            <summary>
            Used to reference a block in a <see cref="T:Neon.Common.BlockArray"/> or <see cref="T:Neon.IO.BlockStream"/>.
            </summary>
        </member>
        <member name="M:Neon.Common.Block.op_Explicit(System.ArraySegment{System.Byte})~Neon.Common.Block">
            <summary>
            Explict cast from a <see cref="T:System.Byte" /> <see cref="T:System.ArraySegment`1" /> to a <see cref="T:Neon.Common.Block" />.
            </summary>
            <param name="segment">The array segment to be converted.</param>
            <returns>The equivalent <see cref="T:Neon.Common.Block" />.</returns>
        </member>
        <member name="M:Neon.Common.Block.op_Explicit(Neon.Common.Block)~System.ArraySegment{System.Byte}">
            <summary>
            Explict cast from a <see cref="T:Neon.Common.Block" /> to a <see cref="T:System.Byte" /> <see cref="T:System.ArraySegment`1" />
            </summary>
            <param name="block">The <see cref="T:Neon.Common.Block" /> to be converted.</param>
            <returns>The equivalent <see cref="T:System.ArraySegment`1" />.</returns>
        </member>
        <member name="M:Neon.Common.Block.Assemble(Neon.Common.Block[])">
            <summary>
            Assembles the bytes referenced by the blocks into a contiguous buffer.
            </summary>
            <param name="blocks">The blocks.</param>
            <returns>A contiguous buffer.</returns>
        </member>
        <member name="M:Neon.Common.Block.#ctor(System.Byte[])">
            <summary>
            Constructs a block.
            </summary>
            <param name="buffer">The byte buffer.</param>
        </member>
        <member name="M:Neon.Common.Block.#ctor(System.Int32)">
            <summary>
            Allocates a block to a newly allocated buffer of the
            specified size.
            </summary>
            <param name="size">The new block size in bytes.</param>
        </member>
        <member name="M:Neon.Common.Block.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructs a block.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">Offset of the first referenced byte.</param>
            <param name="length">Byte length of the reference.</param>
        </member>
        <member name="P:Neon.Common.Block.Buffer">
            <summary>
            The referenced buffer.
            </summary>
        </member>
        <member name="P:Neon.Common.Block.Offset">
            <summary>
            The offset of the starting position of the referenced bytes in the buffer.
            </summary>
        </member>
        <member name="P:Neon.Common.Block.Length">
            <summary>
            The number of referenced bytes.
            </summary>
        </member>
        <member name="M:Neon.Common.Block.SetRange(System.Int32,System.Int32)">
            <summary>
            Modifies the range of bytes referenced by the instance.
            </summary>
            <param name="offset">Index of the first referenced byte.</param>
            <param name="length">Number of bytes referenced.</param>
        </member>
        <member name="P:Neon.Common.Block.Item(System.Int32)">
            <summary>
            Accesses the byte at the specified index in the block.
            </summary>
        </member>
        <member name="M:Neon.Common.Block.CopyTo(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from the logical offset in the block
            to the target byte array.
            </summary>
            <param name="sourceOffset">Logical offset of the first byte to copy.</param>
            <param name="target">The output byte array.</param>
            <param name="targetOffset">Target offset where the first byte is to be written.</param>
            <param name="length">The number of bytes to copy.</param>
        </member>
        <member name="M:Neon.Common.Block.CopyFrom(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies bytes from the byte array passed into the block.
            </summary>
            <param name="source">The source byte array.</param>
            <param name="sourceOffset">Offset of the first byte to copy from the source array.</param>
            <param name="targetOffset">Logical offset of the first target byte in the block.</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="T:Neon.Common.BlockArray">
            <summary>
            Implements an array of <see cref="T:Neon.Common.Block"/> instances.
            </summary>
            <remarks>
            <para>
            The purpose of <see cref="T:Neon.Common.BlockArray"/> is to avoid performance robbing 
            buffer reallocations and copies and large obvject heap applications as can happen 
            with extensive use of the <see cref="T:System.IO.MemoryStream"/> class.  Rather than doing I/O
            to a single large buffer, the <see cref="T:Neon.Common.BlockArray"/> provides the underlying
            functionality for spreading I/O across multiple blocks.  This avoids any need
            to reallocate and copy a large buffer as the stream grows an also
            tends to allocate consistently sized memory blocks, making life
            easier for the memory allocator.
            </para>
            <para>
            This class is pretty flexible.  Blocks can be explicitly added and
            removed from the class or the <see cref="M:Neon.Common.BlockArray.ExtendTo(System.Int32)" />, 
            <see cref="M:Neon.Common.BlockArray.TruncateTo(System.Int32)" />, or <see cref="M:Neon.Common.BlockArray.SetExactSize(System.Int32)" />
            methods can be used have the class handle block management.
            </para>
            <para>
            The <see cref="P:Neon.Common.BlockArray.BlockSize" /> and <see cref="P:Neon.Common.BlockArray.BlockOffset" />
            properties are used by the internal block management methods when allocating 
            new blocks.  <see cref="P:Neon.Common.BlockArray.BlockSize" /> defaults to 512 and specifies 
            the size of new blocks.  <see cref="P:Neon.Common.BlockArray.BlockOffset" />
            defaults to 0.  New blocks will have their <see cref="P:Neon.Common.Block.Offset" /> field set to
            <see cref="P:Neon.Common.BlockArray.BlockOffset" />.
            </para>
            <para>
            BlockOffset provides for some tricky performance optimizations.
            A common situation in network protocols is the need to fragment
            serialized data across multiple data packets with fixed sized
            headers.  Setting BlockOffset to the size of the fixed header
            will reserve these bytes at the beginning of each block.  The
            data can be serialized into the array and then afterwards, the
            headers can be written manually into each block.  This technique
            can avoid lots of buffer copying.
            </para>
            <para>
            <note>
            You should call <see cref="M:Neon.Common.BlockArray.Reload" /> after 
            directly modifying the <see cref="P:Neon.Common.Block.Length" /> or <see cref="P:Neon.Common.Block.Offset" />
            properties of any of the blocks in the array.  It is not necessary 
            to call this for changes to the Block.Buffer 
            array.
            </note>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.op_Implicit(Neon.Common.Block[])~Neon.Common.BlockArray">
            <summary>
            Implicit cast from and array of Blocks into a BlockArray.
            </summary>
            <param name="blocks">The array of blocks to be converted.</param>
            <returns>The <see cref="T:Neon.Common.BlockArray"/>.</returns>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor">
            <summary>
            Constructs an empty list.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Int32)">
            <summary>
            Constructs an array with the specified capacity.
            </summary>
            <param name="capacity">The capacity in bytes.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an array with the specified capacity and block size.
            </summary>
            <param name="capacity">The capacity in bytes.</param>
            <param name="blockSize">Size of blocks added when extending the array.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an array with the specified capacity, block size, and block offset.
            </summary>
            <param name="capacity">The capacity in bytes.</param>
            <param name="blockSize">Size of blocks added when extending the array.</param>
            <param name="blockOffset">Bytes to be reserved at the beginning of each new block.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(Neon.Common.Block[])">
            <summary>
            Constructs an array from the blocks passed.
            </summary>
            <param name="blocks">The blocks.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Byte[])">
            <summary>
            Constructs a block array from a buffer.
            </summary>
            <param name="buffer">The buffer to append.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.ClearPos">
            <summary>
            Clears the cached position related fields.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.Reload">
            <summary>
            Reloads cached information about the blocks in the array.
            </summary>
            <remarks>
            This should be called after making changes to the Length
            property of any blocks in the array.
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.CalcPos(System.Int32)">
            <summary>
            Calculates the block and position of the specified logically indexed
            byte in the block.
            </summary>
            <param name="index">The logical index.</param>
            <remarks>
            The method updates the lastIndex, lastBlock, lastBlockIndex, 
            and lastBlockPos with the calculated values.
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.Reset">
            <summary>
            Used internally by unit tests to reset any internal positional
            optimization information maintained by the class.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(System.Byte[])">
            <summary>
            Appends a block formed by a buffer to the array.
            </summary>
            <param name="buffer">The buffer to add.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(Neon.Common.Block)">
            <summary>
            Appends a block to end of the array.
            </summary>
            <param name="block">The new block.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(Neon.Common.BlockArray)">
            <summary>
            Appends all blocks from a block array to this array.
            </summary>
            <param name="blocks">The source array.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(Neon.Common.BlockArray,System.Int32,System.Int32)">
            <summary>
            Appends blocks from a block array to this array.
            </summary>
            <param name="blocks">The source array.</param>
            <param name="index">Index of the first block to append.</param>
            <param name="count">Number of blocks to append.</param>
        </member>
        <member name="P:Neon.Common.BlockArray.BlockOffset">
            <summary>
            The default offset to use when adding new blocks to the array.
            </summary>
        </member>
        <member name="P:Neon.Common.BlockArray.BlockSize">
            <summary>
            The size of new blocks added when extending the array.
            </summary>
        </member>
        <member name="P:Neon.Common.BlockArray.Count">
            <summary>
            Returns the number of blocks in the list.
            </summary>
        </member>
        <member name="P:Neon.Common.BlockArray.Size">
            <summary>
            Returns the total size of all the blocks in bytes.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.ExtendTo(System.Int32)">
            <summary>
            Adds blocks to the array as necessary to ensure that the total size
            of these blocks is at least equal to the value passed.
            </summary>
            <param name="capacity">The minimum requested capacity in bytes.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.TruncateTo(System.Int32)">
            <summary>
            Removes blocks from the and of the array array such that only 
            those blocks necessary to achieve the specified capacity remain.
            </summary>
            <param name="capacity">The desired capacity in bytes.</param>
            <remarks>
            The method does nothing if the requested capacity is larger
            than the current size of the blocks.
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.SetExactSize(System.Int32)">
            <summary>
            Adjusts the blocks in the array such that their sizes
            total exactly to the value passed.
            </summary>
            <param name="capacity">The desired size.</param>
            <remarks>
            The method removes or appends blocks onto the end of the
            array to reach the desired size.  The method will also
            adjust the length of the final block if necessary.
            </remarks>
        </member>
        <member name="P:Neon.Common.BlockArray.Item(System.Int32)">
            <summary>
            Accesses the indexed byte in the logical array formed by
            concatentating all of the blocks.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.CopyTo(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from the logical offset in the blocks to the target byte array.
            </summary>
            <param name="sourceOffset">Logical offset of the first byte to copy.</param>
            <param name="target">The output byte array.</param>
            <param name="targetOffset">Target offset where the first byte is to be written.</param>
            <param name="length">The number of bytes to copy.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.CopyFrom(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies bytes from the byte array passed into the blocks.
            </summary>
            <param name="source">The source byte array.</param>
            <param name="sourceOffset">Offset of the first byte to copy from the source array.</param>
            <param name="targetOffset">Logical offset of the first target byte in the buffer references.</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.ToByteArray">
            <summary>
            Assembles the blocks referenced by the array into a contiguous
            byte array.
            </summary>
            <returns>A contiguous byte array.</returns>
        </member>
        <member name="M:Neon.Common.BlockArray.GetBlocks">
            <summary>
            Returns an array to the underlying blocks.
            </summary>
            <returns>The block array.</returns>
        </member>
        <member name="M:Neon.Common.BlockArray.GetBlock(System.Int32)">
            <summary>
            Returns the indexed block in the list.
            </summary>
            <param name="index">The index (0..Count-1).</param>
            <returns>The block.</returns>
        </member>
        <member name="M:Neon.Common.BlockArray.Extract(System.Int32,System.Int32)">
            <summary>
            Extracts a range of bytes from the array into newly
            created block array.
            </summary>
            <param name="index">Logical index of the first byte.</param>
            <param name="length">Number of bytes to extract.</param>
            <returns>A new block array referencing the bytes.</returns>
            <remarks>
            <note>
            Although this method does create a new BlockArray
            and Block objects, it does not copy the underlying buffers.
            Instead, it adjusts the new Block objects to reference the
            requested portions of the original underlying buffers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.Extract(System.Int32)">
            <summary>
            Extracts a range of bytes from the array from the specified
            index to the end of the array into newly created block array.
            </summary>
            <param name="index">Logical index of the first byte.</param>
            <returns>A new block array referencing the bytes.</returns>
            <remarks>
            <note>
            Although this method does create a new BlockArray
            and Block objects, it does not copy the underlying buffers.
            Instead, it adjusts the new Block objects to reference the
            requested portions of the original underlying buffers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.Clone">
            <summary>
            Returns a shallow copy of the block array.
            </summary>
            <returns>The cloned array.</returns>
            <remarks>
            A new set of Block objects will be returned but they
            will point to the same underlying buffers.
            </remarks>
        </member>
        <member name="T:Neon.Common.CommandLine">
            <summary>
            Performs common operations on application a DOS or Linux command line.
            </summary>
            <remarks>
            <para>
            Command lines may consist of zero or more items.  Items that begin with
            the dash (-) character are considered to be command line options.  Items that
            begin with an at sign (@) can be considered to be response files, and all
            other items are considered to be command line arguments.
            </para>
            <note>
            The "<b>-</b>" and "<b>--</b>" items (without an option name are considered 
            arguments, not options.
            </note>
            <para>
            The static <see cref="M:Neon.Common.CommandLine.ExpandFiles(System.String[])" /> method can be used to process
            response files specified in a command line.  Response files
            are specified by prepending a '@' character to the name of a text
            file and then treating each line of the file as a command line item.
            </para>
            <para>
            The static <see cref="M:Neon.Common.CommandLine.ExpandWildcards(System.String)" /> method can be used to 
            expand file names with wildcard characters into the set of actual 
            files that match the pattern.
            </para>
            <para>
            The <see cref="T:Neon.Common.CommandLine" /> class can also handles parsing of items
            as command line options.
            </para>
            <code language="none">
            
                --&lt;option name&gt;[=&lt;value&gt;]
                
                You can also use single or double quotes around option values that
                include spaces or other special characters:
            
                --&lt;option name&gt;[='&lt;value&gt;']
                --&lt;option name&gt;[="&lt;value&gt;"]
            
            </code>
            <para>
            will be parsed into name/value pairs and will be available for
            lookup via the string keyed indexer.  Options that specify no
            value will be assigned an empty string value.
            </para>
            <note>
            Command line option names are case sensitive.
            </note>
            <para>
            The class will also make all command line items available via the
            integer keyed indexer which will return items based on
            their position on the command line and also via the <see cref="P:Neon.Common.CommandLine.Items" />
            property.  Command line items that are not command, are available via
            the <see cref="P:Neon.Common.CommandLine.Arguments" /> property.  Options can be looked up via 
            the <see cref="M:Neon.Common.CommandLine.GetOption(System.String,System.String)"/> and <see cref="M:Neon.Common.CommandLine.GetOptionValues(System.String)"/>
            overrides.
            </para>
            <para>
            <see cref="T:Neon.Common.CommandLine"/> also supports the definition of long and
            short forms of options with optional default values using the
            <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/> method.  This associates one or more
            option names with an optional default value.
            </para>
            <para>
            You can use this easily implement the short and long forms 
            of options as well as to centralize the specification of 
            option default values.
            </para>
            <code language="C#">
            var commandLine = new CommandLine(args);
            
            commandLine.DefineOption("-q", "--quiet");
            commandLine.DefineOption("-k", "--key").Default = "none";
            
            // These calls both return the option value for "-q" or "--quiet".
            // Since no default value was set, the default value will be the
            // empty string.
            
            commandLine.GetOption("-q");
            commandLine.GetOption("--quiet");
            
            // These calls both return the option value for "-k" or "--key".
            // The default value will be "none".
            
            commandLine.GetOption("-k");
            commandLine.GetOption("--key");
            </code>
            <note>
            This class assumes that the position of command line options doesn't
            matter, which is somewhat simplistic.  In particular, the <see cref="M:Neon.Common.CommandLine.Shift(System.Int32,System.String)"/> 
            method actually relocates all of the options to the beginning of the 
            shifted command line.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Common.CommandLine.OptionDefinition">
            <summary>
            Associates one or more option names with a default value.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.OptionDefinition.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructor.
            </summary>
            <param name="names">The associated option names.</param>
        </member>
        <member name="P:Neon.Common.CommandLine.OptionDefinition.Names">
            <summary>
            Returns the array of associated option names.
            </summary>
        </member>
        <member name="P:Neon.Common.CommandLine.OptionDefinition.Default">
            <summary>
            The option's default value.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.Parse(System.String)">
            <summary>
            Parses the argument string passed into a <see cref="T:Neon.Common.CommandLine" />
            instance, dealing with quoted parameters, etc.
            </summary>
            <param name="input">The argument string.</param>
            <returns>The parsed <see cref="T:Neon.Common.CommandLine"/>.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.ExpandFiles(System.String[])">
            <summary>
            Expands the command line by processing items beginning with '@' as input files.
            </summary>
            <param name="args">The command line arguments.</param>
            <returns>The set of expanded items.</returns>
            <remarks>
            <para>
            Command line items will be assumed to specify a
            text file name after the '@'.  This file will be read
            and each non-empty line of text will be inserted as a
            command line parameter.
            </para>
            <para>
            Lines of text whose first non-whitespace character is a
            pound sign (#) will be ignored as comments.
            </para>
            <para>
            Command line parameters may also span multiple lines by
            beginning the parameter with a line of text begininning with
            "{{" and finishing it with a line of text containing "}}".
            In this case, the command line parameter will be set to the
            text between the {{...}} with any CRLF sequences replaced by
            a single space.
            </para>
            <para>
            Here's an example:
            </para>
            <code language="none">
            # This is a comment and will be ignored
            
            -param1=aaa
            -param2=bbb
            {{
            -param3=hello
            world
            }}
            </code>
            <para>
            This will be parsed as three command line parameters:
            <b>-param1=aaa</b>, <b>-param2=bbb</b>, and <b>-param3=hello world</b>
            </para>
            </remarks>
            <exception cref="T:System.IO.IOException">Thrown if there's a problem opening an "@" input file.</exception>
            <exception cref="T:System.FormatException">Thrown if there's an error parsing an "@" input file.</exception>
        </member>
        <member name="M:Neon.Common.CommandLine.ExpandWildcards(System.String)">
            <summary>
            Checks the argument passed for wildcards and expands them into the
            appopriate set of matching file names.
            </summary>
            <param name="path">The file path potentially including wildcards.</param>
            <returns>The set of matching file names.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.Format(System.Object[])">
            <summary>
            Formats an array of objects into a form suitable for passing to a 
            process on the command line by adding double quotes around any values
            with embedded spaces.
            </summary>
            <param name="args">The arguments to be formatted.</param>
            <returns>the formatted string.</returns>
            <exception cref="T:System.FormatException">Thrown if any of the arguments contain double quote or any other invalid characters.</exception>
        </member>
        <member name="M:Neon.Common.CommandLine.ToStrings(System.Object[])">
            <summary>
            Converts an array of objects to an array of strings.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.#ctor(System.Object[])">
            <summary>
            Constructs an instance optionally expanding any response files specified
            in the arguments passed.
            </summary>
            <param name="args">The optional command line arguments.</param>
        </member>
        <member name="M:Neon.Common.CommandLine.DefineOption(System.String[])">
            <summary>
            Adds an option definition to the command line and returns the
            definition so its default value may be set if desired.
            </summary>
            <param name="names">The option names (e.g. the short and long form).</param>
            <returns>The <see cref="T:Neon.Common.CommandLine.OptionDefinition"/>.</returns>
            <remarks>
            <para>
            You can use this easily implement the short and long forms 
            of options as well as to centralize the specification of 
            option default values.
            </para>
            <code language="C#">
            var commandLine = new CommandLine(args);
            
            commandLine.DefineOption("-q", "--quiet");
            commandLine.DefineOption("-k", "--key").Default = "none";
            
            // These calls both return the option value for "-q" or "--quiet".
            // Since no default value was set, the default value will be the
            // empty string.
            
            commandLine.GetOption("-q");
            commandLine.GetOption("--quiet");
            
            // These calls both return the option value for "-k" or "--key".
            // The default value will be "none".
            
            commandLine.GetOption("-k");
            commandLine.GetOption("--key");
            </code>
            </remarks>
        </member>
        <member name="P:Neon.Common.CommandLine.Original">
            <summary>
            Returns the original unshifted command line.
            </summary>
        </member>
        <member name="P:Neon.Common.CommandLine.Items">
            <summary>
            Returns the array of command line arguments (including both
            command line options and values).
            </summary>
        </member>
        <member name="P:Neon.Common.CommandLine.Arguments">
            <summary>
            Returns the array of command line values (items that are not
            command line options).
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.GetArguments(System.Int32)">
            <summary>
            Enumerates the command line arguments beginning at the specified index.
            </summary>
            <param name="startIndex">The index of the first argument to be returned.</param>
            <returns>The enumerated arguments.</returns>
        </member>
        <member name="P:Neon.Common.CommandLine.Item(System.Int32)">
            <summary>
            Returns an item from the command line based on its position.
            </summary>
            <param name="index">The zero-based position of the desired argument.</param>
            <returns>The argument string.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.GetOption(System.String,System.String)">
            <summary>
            Returns the value associated with a command line option if the option was present 
            on the command line otherwise, the specified default value will be returned.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <param name="def">The default value.</param>
            <returns>The option value if present, the specified default value otherwise.</returns>
            <remarks>
            <para>
            If the <paramref name="optionName"/> was included in a previous <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/>
            call, then all aliases for the option will be searched.  If the option is not
            present on the command line and <paramref name="def"/> is <c>null</c>, then the default
            defined default value will be returned otherwise <paramref name="def"/> will override
            the definition.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.GetFlag(System.String)">
            <summary>
            Determines whether an option is present on the command line.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <returns>The option value if present, the specified default value otherwise.</returns>
        </member>
        <member name="P:Neon.Common.CommandLine.Options">
            <summary>
            Returns the command line options as a dictionary of option name/value tuples.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.HasOption(System.String)">
            <summary>
            Determines if an option was present on the command line.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <returns><c>true</c> if the option is present.</returns>
            <remarks>
            <para>
            If the <paramref name="optionName"/> was included in a previous <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/>
            call, then all aliases for the option will be searched.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.GetOptionValues(System.String)">
            <summary>
            Returns all of the values a command line option that appears multiple
            times in the command.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <returns>The array of values found sorted in the same order thney appear in the command line.</returns>
            <remarks>
            <note>
            Only command line options that actually specify a value using the
            colon (=) syntax are returned by this method.
            </note>
            <para>
            If the <paramref name="optionName"/> was included in a previous <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/>
            call, then all aliases for the option will be searched.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Common.CommandLine.HasHelpOption">
            <summary>
            Determines if the <b>--help</b> command line option is present.
            </summary>
            <returns><c>true</c> if the <b>--help</b> help option is present.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.Shift(System.Int32,System.String)">
            <summary>
            Returns a new <see cref="T:Neon.Common.CommandLine" /> which includes all of the command line options
            and the arguments starting at the position passed to the end of the command line,
            essentially shifting arguments to the left.
            </summary>
            <param name="position">The index of the first argument to be included in the result.</param>
            <param name="splitter">
            The optional argument used to ensure that we're only shifting the left 
            side of a command line.  This defaults to <b>"--"</b> but may be set to
            <c>null</c> or the empty string to disable this behavior.
            </param>
            <returns>The new <see cref="T:Neon.Common.CommandLine" />.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.Split(System.String,System.Boolean)">
            <summary>
            Splits the command line into two parts, the command line to the left of 
            the first specified item (defaults to <b>"--"</b>) and the command line 
            to the right of it.
            </summary>
            <param name="splitter">The split item (defaults to <b>"--"</b>).</param>
            <param name="addSplitterToRight">
            Optionally specifies that the split item should be included in the 
            right command line returned.
            </param>
            <returns>A tuple with <b>Left</b> and <b>Right</b> properties.</returns>
            <remarks>
            <note>
            The <b>Left</b> command line will return with a copy of the original option
            definitions.
            </note>
            <note>
            If there is no split item present, then <b>Right</b> will be <c>null</c>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.StartsWithArgs(System.String[])">
            <summary>
            Determines whether the command line starts with the specified arguments.
            </summary>
            <param name="args">The non-<c>null</c> argument strings.</param>
            <returns><c>true</c> if the command is prefxed with the specified arguments.</returns>
            <remarks>
            <note>
            The argument comparison is case sensitive.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.Preprocess(System.Collections.Generic.Dictionary{System.String,System.String},System.Text.RegularExpressions.Regex)">
            <summary>
            <para>
            Preprocesses the command line by using <see cref="T:Neon.IO.PreprocessReader"/> to replace any 
            environment variable, profile, or secret references in the command line arguments, like:
            </para>
            <list type="table">
            <item>
                <term><c>$(env:VARIABLE)</c></term>
                <description>
                Replaced with the environment <b>VARIABLE</b> 
                </description>
            </item>
            <item>
                <term><c>$(profile:VALUE)</c></term>
                <description>
                Replaced with the profile <b>VALUE</b>
                </description>
            </item>
            <item>
                <term><c>${password:SECRET}</c></term>
                <description>
                Replaced with the password field of the <b>SECRET</b>
                </description>
            </item>
            <item>
                <term><c>${password:SECRET:SOURCE}</c></term>
                <description>
                Replaced with the password field of the <b>SECRET</b> obtained from <b>SOURCE</b>
                </description>
            </item>
            <item>
                <term><c>${password:SECRET[PROPERTY]}</c></term>
                <description>
                Replaced with the PROPERTY field of the <b>SECRET</b>
                </description>
            </item>
            <item>
                <term><c>${password:SECRET[PROPERTY]:SOURCE}</c></term>
                <description>
                Replaced with the PROPERTY field of the <b>SECRET</b> obtained from <b>SOURCE</b>
                </description>
            </item>
            </list>
            <note>
            <b>IMORTANT:</b> You'll probably need to surround variable references with single
            quotes on Linux to prevent Bash from interpreting these as Bash variables.
            </note>
            <note>
            <b>IMPORTANT:</b> You must register an <see cref="T:Neon.Deployment.IProfileClient"/> implementation with
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/> for this to work.
            </note>
            </summary>
            <param name="variables">Optionally specifies variables to be incuded in the preprocessing.</param>
            <param name="variableRegex">
            Optionally specifies the regular expression that will be used to locate and process
            any variable references.  This defaults to <see cref="P:Neon.IO.PreprocessReader.CurlyVariableExpansionRegex"/>
            but may be set to any expressions supported by <see cref="T:Neon.IO.PreprocessReader"/>.
            </param>
            <returns>A new <see cref="T:Neon.Common.CommandLine"/> including any changes.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.ToString">
            <summary>
            Renders the command line as a string suitable for presenting to a process or
            a command line shell.  Arguments that include spaces will be enclosed in 
            double quotes.
            </summary>
            <returns>The command line string.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if a command line argument includes both single and double quotes.</exception>
        </member>
        <member name="T:Neon.Common.CommandLine.Redactor">
            <summary>
            Handles redaction of command line arguments and/or options for the <see cref="M:Neon.Common.CommandLine.ToFormatted(System.String,System.Boolean,System.Boolean,Neon.Common.CommandLine.Redactor)"/>
            method.  Return <c>null</c> if no redaction is required for the item or the string to be used instead.
            </summary>
            <param name="commandLine">The command line.</param>
            <param name="index">Zero based index of the item.</param>
            <param name="item">The item string.</param>
            <param name="isOption"><c>true</c> when the item is a command line options.</param>
            <returns><c>null</c> when no redaction is required or else the string to be substituted.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.ToFormatted(System.String,System.Boolean,System.Boolean,Neon.Common.CommandLine.Redactor)">
            <summary>
            Converts the command line into a nicely formatted (potentially multi-line) string
            suitable for including in logs.
            </summary>
            <param name="programName">Specifies the program name.</param>
            <param name="withBars">Optionally include bars above and below the formatted command.</param>
            <param name="withLineContinuation">Optionally include line continuation characters appropriate for the current operating system.</param>
            <param name="redactor">Optionally passed as a redactor.  See <see cref="T:Neon.Common.CommandLine.Redactor"/>.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="T:Neon.Common.Credentials">
            <summary>
            Used to persist credentials.
            </summary>
            <remarks>
            <para>
            Two forms of credentials are currently supported: a standalone security token or
            API key or the combination of a username and password.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.Credentials.FromToken(System.String)">
            <summary>
            Constructs credentials from a token.
            </summary>
            <param name="token">The token.</param>
            <returns>The <see cref="T:Neon.Common.Credentials"/>.</returns>
        </member>
        <member name="M:Neon.Common.Credentials.FromUserPassword(System.String,System.String)">
            <summary>
            Constructs credentials from a token.
            </summary>
            <param name="username">The username.</param>
            <param name="password">The password.</param>
            <returns>The <see cref="T:Neon.Common.Credentials"/>.</returns>
        </member>
        <member name="M:Neon.Common.Credentials.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.Token">
            <summary>
            The security token.
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.Username">
            <summary>
            The username (use in conjunction with <see cref="P:Neon.Common.Credentials.Password"/>).
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.Password">
            <summary>
            The password (use in conjunction with <see cref="P:Neon.Common.Credentials.Username"/>).
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.HasToken">
            <summary>
            Returns <c>true</c> if the credentials hold a <see cref="P:Neon.Common.Credentials.Token"/>.
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.HasUsernamePassword">
            <summary>
            Returns <c>true</c> if the credentials hold a <see cref="P:Neon.Common.Credentials.Username"/> and <see cref="P:Neon.Common.Credentials.Password"/>.
            </summary>
        </member>
        <member name="T:Neon.Common.EnvironmentParser">
            <summary>
            <para>
            Handles parsing of environment variables by default or optionally variables
            from a custom source.  This has built-in methods for parsing: <c>int</c>,
            <c>long</c>, <c>double</c>, <c>TimeSpan</c>, <c>string</c> and <c>enum</c>
            variables as well as mechanisms to parse custom types.
            </para>
            <note>
            <para>
            This class logs details about parsed variables.  By default, these logs include 
            actual value that could not be parsed.  This may not be desirable for variables
            defining secrets.  Pass <c>redact: true</c> for these cases.
            </para>
            <para>
            When debugging, it's useful to ignore <c>redact</c> arguments and include 
            these values in any logged events anyway.  You can accomplish this by setting 
            the <c>NEON_REDACT_OVERRIDE=1</c> environment variable.
            </para>
            <para>
            <b>IMPORTANT:</b> Never set <c>NEON_REDACT_OVERRIDE=1</c> for production.
            </para>
            </note>
            </summary>
        </member>
        <member name="T:Neon.Common.EnvironmentParser.Parser`1">
            <summary>
            Attempts to parse an environment variable as a specific type.
            </summary>
            <typeparam name="T">The output type.</typeparam>
            <param name="input">The string to be parsed.</param>
            <param name="value">Returns as the parsed value on success.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns><c>true</c> If the input was parsed successfully.</returns>
        </member>
        <member name="T:Neon.Common.EnvironmentParser.Validator`1">
            <summary>
            Validates that a parsed environment variable is valid.
            </summary>
            <typeparam name="T">The parsed variable type.</typeparam>
            <param name="input">The input value.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="T:Neon.Common.EnvironmentParser.VariableSource">
            <summary>
            <para>
            Used for custom variable lookup implementation.  This will be passed
            a variable name and should return the value as a string when the variable
            exists or <c>null</c> if it does not.
            </para>
            <para>
            Pass a custom implementation to the <see cref="T:Neon.Common.EnvironmentParser"/> constructor
            when necessary.
            </para>
            </summary>
            <param name="variable">The variable name.</param>
            <returns>The variable's value or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.StringParser(System.String,System.String@,System.String@)">
            <summary>
            Parses a <see cref="T:System.String"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.IntParser(System.String,System.Int32@,System.String@)">
            <summary>
            Parses an <see cref="T:System.Int32"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LongParser(System.String,System.Int64@,System.String@)">
            <summary>
            Parses a <see cref="T:System.Int64"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.DoubleParser(System.String,System.Double@,System.String@)">
            <summary>
            Parses a <see cref="T:System.Double"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.BoolParser(System.String,System.Boolean@,System.String@)">
            <summary>
            Parses a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
            <remarks>
            <para>
            Valid <c>true</c> values: <b>true</b>, <b>yes</b>, <b>on</b>, or <b>1</b>.
            </para>
            <para>
            Valid <c>false</c> values: <b>false</b>, <b>no</b>, <b>off</b>, or <b>0</b>.
            </para>
            <note>
            These strings are case insensitive.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.TimeSpanParser(System.String,System.TimeSpan@,System.String@)">
            <summary>
            Parses a <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.EnumParser``1(System.String,``0@,System.String@)">
            <summary>
            Parses an enumeration.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.#ctor(Microsoft.Extensions.Logging.ILogger,Neon.Common.EnvironmentParser.VariableSource)">
            <summary>
            Constructor.
            </summary>
            <param name="logger">Optionally specifies the logger where parsing errors will be logged.</param>
            <param name="source">Optionally specifies an alternative variable source.  This defaults to retrieving environment variables.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.EnvironmentSource(System.String)">
            <summary>
            Implements the default environment variable based source.
            </summary>
            <param name="variable">The variable name.</param>
            <returns>The variable value or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogMissingVariable(System.String)">
            <summary>
            Reports a missing environment variable.
            </summary>
            <param name="variable">The variable name.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogInvalidVariable(System.String,System.String,System.String)">
            <summary>
            Reports an invalid environment variable.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="value">The invalid variable value.</param>
            <param name="error">Specifies an optional error message.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogInvalidVariable(System.String,System.String,System.Object,System.String)">
            <summary>
            Reports an invalid environment variable.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="value">The invalid variable value.</param>
            <param name="def">The value actually used instead.</param>
            <param name="error">Specifies an optional error message.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogVariable(System.String,System.String,System.Boolean)">
            <summary>
            Reports an environment variable value.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="value">The invalid variable value.</param>
            <param name="redact">Whether to redact the log output.</param>
            <remarks>
            <note>
            <para>
            This class logs details about parsed variables.  By default, these logs include 
            actual value that could not be parsed.  This may not be desirable for variables
            defining secrets.  Pass <c>redact: true</c> for these cases.
            </para>
            <para>
            When debugging, it's useful to ignore <c>redact</c> arguments and include 
            these values in any logged events anyway.  You can accomplish this by setting 
            the <c>NEON_REDACT_OVERRIDE=1</c> environment variable.
            </para>
            <para>
            <b>IMPORTANT:</b> Never set <c>NEON_REDACT_OVERRIDE=1</c> for production.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.ThrowNotFound(System.String)">
            <summary>
            Throws a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> for an environment variable.
            </summary>
            <param name="variable">The variable name.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Parse``1(System.String,System.String,Neon.Common.EnvironmentParser.Parser{``0},System.Boolean,Neon.Common.EnvironmentParser.Validator{``0},System.Boolean)">
            <summary>
            Attempts to parse an environment variable as a <typeparamref name="T"/>, writting 
            messages to the associated logger if one was passed to the constructor.
            </summary>
            <typeparam name="T">The parsed output type.</typeparam>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="parser">The parser function.</param>
            <param name="validator">Optional validation function.</param>
            <param name="redact">Optionally redact log output of the variable.</param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
            <remarks>
            <note>
            <para>
            This class logs details about parsed variables.  By default, these logs include 
            actual value that could not be parsed.  This may not be desirable for variables
            defining secrets.  Pass <c>redact: true</c> for these cases.
            </para>
            <para>
            When debugging, it's useful to ignore <c>redact</c> arguments and include 
            these values in any logged events anyway.  You can accomplish this by setting 
            the <c>NEON_REDACT_OVERRIDE=1</c> environment variable.
            </para>
            <para>
            <b>IMPORTANT:</b> Never set <c>NEON_REDACT_OVERRIDE=1</c> for production.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.String,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.String},System.Boolean)">
            <summary>
            Attempts to parse an environment variable as a <see cref="T:System.String"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <param name="redact">Optionally redact log output of the variable.</param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
            <remarks>
            <note>
            <para>
            This class logs details about parsed variables.  By default, these logs include 
            actual value that could not be parsed.  This may not be desirable for variables
            defining secrets.  Pass <c>redact: true</c> for these cases.
            </para>
            <para>
            When debugging, it's useful to ignore <c>redact</c> arguments and include 
            these values in any logged events anyway.  You can accomplish this by setting 
            the <c>NEON_REDACT_OVERRIDE=1</c> environment variable.
            </para>
            <para>
            <b>IMPORTANT:</b> Never set <c>NEON_REDACT_OVERRIDE=1</c> for production.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.Int32,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.Int32})">
            <summary>
            Attempts to parse an environment variable as an <see cref="T:System.Int32"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.Int64,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.Int64})">
            <summary>
            Attempts to parse an environment variable as a <see cref="T:System.Int64"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.Double,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.Double})">
            <summary>
            Attempts to parse an environment variable as an <see cref="T:System.Double"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.Boolean,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.Boolean})">
            <summary>
            Attempts to parse an environment variable as a <see cref="T:System.Boolean"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.TimeSpan,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.TimeSpan})">
            <summary>
            Attempts to parse an environment variable as a <see cref="T:System.TimeSpan"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get``1(System.String,``0,System.Boolean,Neon.Common.EnvironmentParser.Validator{``0})">
            <summary>
            Attempts to parse an environment variable as an eumeration, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <typeparam name="TEnum">The desired enumeration type.</typeparam>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="T:Neon.Common.GlobPattern">
            <summary>
            Implements a very simple glob matcher inspired by the GitHub <c>.gitignore</c> patterns
            described <a href="https://git-scm.com/docs/gitignore">here</a>.
            </summary>
            <remarks>
            <para>
            The current implementation is somewhat limited compared to that for <c>.gitignore</c>:
            </para>
            <list type="bullet">
            <item>
            Only <b>"*"</b> and <b>"**"</b> wildcard chacacters are allowed.
            <b>"!"</b> and <b>"[..]"</b> are not recognized.
            </item>
            <item>
            <b>"*"</b> matches anything except for <b>"/"</b>.
            </item>
            <item>
            <b>"**"</b> matches zero or more directories.
            </item>
            </list>
            <note>
            This class works only for file paths using either Linux style forward slashes (/) or
            Windows style backslashes by converting any backslashes to forward slashes in 
            <see cref="M:Neon.Common.GlobPattern.IsMatch(System.String)"/> before performing the match.  The <see cref="P:Neon.Common.GlobPattern.Regex"/>
            handles forward slash matching only.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.GlobPattern.Parse(System.String,System.Boolean)">
            <summary>
            Parses a <see cref="T:Neon.Common.GlobPattern"/> from a pattern string.
            </summary>
            <param name="pattern">The pattern.</param>
            <param name="caseInsensitive">Optionally uses case insensitive that matching.</param>
            <returns>The created <see cref="T:Neon.Common.GlobPattern"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the pattern is <c>null</c> or empty.</exception>
            <exception cref="T:System.FormatException">Thrown if the pattern is invalid.</exception>
        </member>
        <member name="M:Neon.Common.GlobPattern.TryParse(System.String,Neon.Common.GlobPattern@)">
            <summary>
            Attempts to parse a case insensitive <see cref="T:Neon.Common.GlobPattern"/>.
            </summary>
            <param name="pattern">The pattern string.</param>
            <param name="globPattern">Returns as the parsed <see cref="T:Neon.Common.GlobPattern"/>.</param>
            <returns><c>true</c> if the pattern was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.GlobPattern.TryParse(System.String,System.Boolean,Neon.Common.GlobPattern@)">
            <summary>
            Attempts to parse a <see cref="T:Neon.Common.GlobPattern"/> where case sensitivity can
            be controlled.
            </summary>
            <param name="pattern">The pattern string.</param>
            <param name="caseInsenstive">Controls whether the mactching is case insensitive.</param>
            <param name="globPattern">Returns as the parsed <see cref="T:Neon.Common.GlobPattern"/>.</param>
            <returns><c>true</c> if the pattern was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.GlobPattern.#ctor(System.String,System.Boolean)">
            <summary>
            Private constructor.
            </summary>
            <param name="pattern">The glob pattern.</param>
            <param name="caseInsensitive">Optionally uses case insensitive that matching.</param>
        </member>
        <member name="P:Neon.Common.GlobPattern.RegexPattern">
            <summary>
            Returns the glob as a regular expression string.
            </summary>
        </member>
        <member name="P:Neon.Common.GlobPattern.Regex">
            <summary>
            Returns the <see cref="P:Neon.Common.GlobPattern.Regex"/> that can be used to match strings against the glob.
            </summary>
        </member>
        <member name="M:Neon.Common.GlobPattern.IsMatch(System.String)">
            <summary>
            Matches a string against the glob.
            </summary>
            <param name="input">The value to be matched.</param>
            <returns><c>true</c> if the parameter matches the glob.</returns>
        </member>
        <member name="M:Neon.Common.GlobPattern.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.HexDumpOption">
            <summary>
            Enumerates the option flags for the <see cref="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,System.Int32,System.Int32,Neon.Common.HexDumpOption)"/> 
            and <see cref="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,Neon.Common.HexDumpOption)"/> > methods.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.None">
            <summary>
            Enable no special formatting options.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.ShowAll">
            <summary>
            Enables all formatting options.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.ShowAnsi">
            <summary>
            Include ANSI characters after the HEX bytes on each line.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.ShowOffsets">
            <summary>
            Include the byte offset of the first byte of each line.
            </summary>
        </member>
        <member name="T:Neon.Common.ILabeled">
            <summary>
            Used by <see cref="T:Neon.Common.LabelSelector`1"/> to retrieve the label dictionary for
            a specific item.  Labels are simply key/value pairs assigned to an object and
            <see cref="T:Neon.Common.LabelSelector`1"/> can be used to select items based on their
            assigned labels.
            </summary>
        </member>
        <member name="M:Neon.Common.ILabeled.GetLabels">
            <summary>
            Returns the label dictionary for the instance.  These are simply key/value
            pairs where the key is the label name.  You may return <c>null</c> to indicate
            that there are not labels.
            </summary>
            <returns>The label dictionary or <c>null</c>.</returns>
            <remarks>
            Label names may be treated as case sensitive or insentive based on how the underlying
            dictionary returned was constructed.  Generally though, labels are considered to be
            case insensitive so you should probably use <see cref="F:System.StringComparison.InvariantCultureIgnoreCase"/>
            when constructing your dictionaries.
            </remarks>
        </member>
        <member name="T:Neon.Common.IServiceContainer">
            <summary>
            <para>
            This interface combines the capabilities of <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and
            <see cref="T:System.IServiceProvider"/> to define an object that can dynamically add
            and remove service implementations.  See the default implementation 
            <see cref="T:Microsoft.Extensions.DependencyInjection.ServiceCollection"/> for more information.
            </para>
            <note>
            Implementations must be thread-safe.
            </note>
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="T:Neon.Common.LabelSelector`1">
            <summary>
            <para>
            Implements a Kubernetes compatible general purpose label-based selector mechanism that 
            can select a set of items from a collection based on the set of labels assigned to each 
            item.  This class supports some simple fixed query methods as well as a simple text-based
            query language.
            </para>
            <para>
            This is suitable for operations like selecting Kubernetes related items by labels 
            or annotations.
            </para>
            </summary>
            <typeparam name="TItem">The underlying item type.</typeparam>
            <remarks>
            <para>
            This class supports Kubernetes style label selectors:
            </para>
            <para>
            <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">Kubernetes: Labels and Selectors</a>
            </para>
            <para>
            For this to work, your <typeparamref name="TItem"/> type will need to implement
            the <see cref="T:Neon.Common.ILabeled"/> interface and its <see cref="M:Neon.Common.ILabeled.GetLabels"/>
            which returns a string/string dictionary holding that items labels.  Then you can
            construct a selector instance via <see cref="T:Neon.Common.LabelSelector`1"/>,
            passing your set of labeled items.  Then you can call <see cref="M:Neon.Common.LabelSelector`1.GetItemsWith(System.String)"/>,
            <see cref="M:Neon.Common.LabelSelector`1.GetItemsWithout(System.String)"/>, and <see cref="M:Neon.Common.LabelSelector`1.Select(System.String)"/>
            to select items based on their labels and one ore more label conditions to be
            satisified.
            </para>
            <note>
            <para>
            Kubernetes labels are key/value pairs. Valid label keys have two segments: an optional prefix and name, separated by a slash <c>(/)</c>. 
            The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character <c>([a-z0-9A-Z])</c> 
            with dashes <c>(-)</c>, underscores <c>(_)</c>, dots <c>(.)</c>, and alphanumerics between. The prefix is optional. If specified, 
            the prefix must be a DNS subdomain: a series of DNS labels separated by dots <b>(.)</b>, not longer than 253 characters in total,
            followed by a slash <c>(/)</c>.
            </para>
            <para>
            If the prefix is omitted, the label Key is presumed to be private to the user. Automated system components (e.g. kube-scheduler,
            kube-controller-manager, kube-apiserver, kubectl, or other third-party automation) which add labels to end-user objects must specify
            a prefix.
            </para>
            <para>
            The <c>kubernetes.io/</c> and <c>k8s.io/</c> prefixes are reserved for Kubernetes core components.
            </para>
            <para>
            Valid label values must be 63 characters or less and must be empty or begin and end with an alphanumeric character <c>([a-z0-9A-Z])</c> 
            with dashes <c>(-)</c>, underscores <c>(_)</c>, dots <c>(.)</c>, and alphanumerics between.
            </para>
            <para>
            </para>
            <para>
            <b>Label Names:</b> must conform to the Kubernetes standard and will be treated as case sensitive 
            or insensitive based on how the underlying dictionary returned was constructed.  Generally
            though, labels are considered to be case insensitive so you should probably use 
            <see cref="F:System.StringComparison.InvariantCultureIgnoreCase"/> when constructing the dictionaries
            returned by your item's <see cref="M:Neon.Common.ILabeled.GetLabels"/> method.
            </para>
            <para>
            Label names must conform to the Kubernetes conventions by default but this can be
            relaxed by passing an option to the constructor.
            </para>
            </note>
            <note>
            <b>Label Values:</b> are considered to be case senstive by default but this can be customized
            via the constructor.
            </note>
            <note>
            See <see cref="M:Neon.Common.LabelSelector`1.Select(System.String)"/> for a description of the label selector language.
            </note>
            <note>
            You may use the <c>static</c> <see cref="M:Neon.Common.LabelSelector.ValidateLabelKey(System.String)"/> and 
            <see cref="M:Neon.Common.LabelSelector.ValidateLabelValue(System.String)"/> methods to explicity confirm that 
            label keys and values satisfy the Kubernetes conventions.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Common.LabelSelector`1.ConditionType">
            <summary>
            Enumerates the condition types.
            </summary>
        </member>
        <member name="T:Neon.Common.LabelSelector`1.LabelCondition">
            <summary>
            Implements label conditions.
            </summary>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.Equal(System.String,System.String,Neon.Common.LabelSelectorOptions)">
            <summary>
            Constructs a <see cref="F:Neon.Common.LabelSelector`1.ConditionType.Equal"/> condition.
            </summary>
            <param name="labelKey">The target label key.</param>
            <param name="value">The value.</param>
            <param name="options">The selector options.</param>
            <returns>The <see cref="T:Neon.Common.LabelSelector`1.LabelCondition"/>.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.NotEqual(System.String,System.String,Neon.Common.LabelSelectorOptions)">
            <summary>
            Constructs a <see cref="F:Neon.Common.LabelSelector`1.ConditionType.NotEqual"/> condition.
            </summary>
            <param name="labelKey">The target label key.</param>
            <param name="value">The value.</param>
            <param name="options">The selector options.</param>
            <returns>The <see cref="T:Neon.Common.LabelSelector`1.LabelCondition"/>.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.In(System.String,System.Collections.Generic.IEnumerable{System.String},Neon.Common.LabelSelectorOptions)">
            <summary>
            Constructs a <see cref="F:Neon.Common.LabelSelector`1.ConditionType.In"/> condition.
            </summary>
            <param name="labelKey">The target label key.</param>
            <param name="values">The values.</param>
            <param name="options">The selector options.</param>
            <returns>The <see cref="T:Neon.Common.LabelSelector`1.LabelCondition"/>.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.NotIn(System.String,System.Collections.Generic.IEnumerable{System.String},Neon.Common.LabelSelectorOptions)">
            <summary>
            Constructs a <see cref="F:Neon.Common.LabelSelector`1.ConditionType.NotIn"/> condition.
            </summary>
            <param name="labelKey">The target label key.</param>
            <param name="values">The values.</param>
            <param name="options">The selector options.</param>
            <returns>The <see cref="T:Neon.Common.LabelSelector`1.LabelCondition"/>.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.Has(System.String,Neon.Common.LabelSelectorOptions)">
            <summary>
            Constructs a <see cref="F:Neon.Common.LabelSelector`1.ConditionType.Has"/> condition.
            </summary>
            <param name="labelKey">The target label kewy.</param>
            <param name="options">The selector options.</param>
            <returns>The <see cref="T:Neon.Common.LabelSelector`1.LabelCondition"/>.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.NotHas(System.String,Neon.Common.LabelSelectorOptions)">
            <summary>
            Constructs a <see cref="F:Neon.Common.LabelSelector`1.ConditionType.NotHas"/> condition.
            </summary>
            <param name="labelKey">The target label key</param>
            <param name="options">The selector options.</param>
            <returns>The <see cref="T:Neon.Common.LabelSelector`1.LabelCondition"/>.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.ValidateLabelKey(System.String,Neon.Common.LabelSelectorOptions)">
            <summary>
            Validates a label key.
            </summary>
            <param name="labelKey">The label key.</param>
            <param name="options">The selector options.</param>
            <exception cref="T:System.FormatException">Thrown if the key is not valid.</exception>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.ValidateLabelValue(System.String,Neon.Common.LabelSelectorOptions)">
            <summary>
            Validates a label value.
            </summary>
            <param name="labelValue">The label value.</param>
            <param name="options">The selector options.</param>
            <exception cref="T:System.FormatException">Thrown if the key is not valid.</exception>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.LabelCondition.Execute(`0,System.StringComparison)">
            <summary>
            Detects whether an item satisfies a label condition.
            </summary>
            <param name="item">The input item.</param>
            <param name="valueComparison">Specifies how label value comparisons are to be performed.</param>
            <returns><c>true</c> if the label selector was satisfied.</returns>
        </member>
        <member name="T:Neon.Common.LabelSelector`1.TokenType">
            <summary>
            Enumerates the possible label selector token types.
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.Eof">
            <summary>
            Indicates the end of input.
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.String">
            <summary>
            A label name, value or a text operator like <b>in</b> or <b>notin</b>.
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.Not">
            <summary>
            A <b>'!'</b> operator.
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.LParen">
            <summary>
            A left parentheses <b>'('</b>
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.RParen">
            <summary>
            A right parentheses <b>'>'</b>
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.Comma">
            <summary>
            A comma <b>','</b>
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.Equal">
            <summary>
            A <b>=</b> or <b>==</b>
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.TokenType.NotEqual">
            <summary>
            A <b>!=</b>
            </summary>
        </member>
        <member name="T:Neon.Common.LabelSelector`1.Token">
            <summary>
            Holds a token extracted by the <see cref="T:Neon.Common.LabelSelector`1.Lexer"/>.
            </summary>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.Eof">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.Eof"/> token.
            </summary>
            <returns>The token.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.String(System.String)">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.String"/> token.
            </summary>
            <param name="value">The string value.</param>
            <returns>The token.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.Not">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.Not"/> token.
            </summary>
            <returns>The token.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.LParen">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.LParen"/> token.
            </summary>
            <returns>The token.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.RParen">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.RParen"/> token.
            </summary>
            <returns>The token.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.Comma">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.Comma"/> token.
            </summary>
            <returns>The token.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.Equal">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.Equal"/> token.
            </summary>
            <returns>The token.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Token.NotEqual">
            <summary>
            Returns <see cref="F:Neon.Common.LabelSelector`1.TokenType.NotEqual"/> token.
            </summary>
            <returns>The token.</returns>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.Token.Type">
            <summary>
            Identifies the token type.
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelector`1.Token.Value">
            <summary>
            Returns the value for <see cref="F:Neon.Common.LabelSelector`1.TokenType.String"/> tokens.
            </summary>
        </member>
        <member name="T:Neon.Common.LabelSelector`1.Lexer">
            <summary>
            Implements a simple lexical analyzer.  This is probably a bit of an overkill
            for the current implementation but may come in handy if we ever extend the
            selector language to include nested subexpressions, etc.
            </summary>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Lexer.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="labelSelector">The label selector being parsed.</param>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Lexer.Next">
            <summary>
            Returns the next token from the input, optionally verifying that the token
            found was expected.
            </summary>
            <returns>The next <see cref="T:Neon.Common.LabelSelector`1.Token"/>.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Lexer.Next(Neon.Common.LabelSelector{`0}.TokenType[])">
            <summary>
            Returns the next token from the input, optionally verifying that the token
            found was expected.
            </summary>
            <param name="expectedTypes">Specifies the expected token types.</param>
            <returns>The next <see cref="T:Neon.Common.LabelSelector`1.Token"/>.</returns>
            <exception cref="T:System.FormatException">Thrown when the next token doesn't match <paramref name="expectedTypes"/>.</exception>
        </member>
        <member name="P:Neon.Common.LabelSelector`1.Lexer.Eof">
            <summary>
            Returns <c>true</c> when the lexer has reached the end of the input.
            </summary>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.#ctor(System.Collections.Generic.IEnumerable{`0},Neon.Common.LabelSelectorOptions)">
            <summary>
            Constructor.
            </summary>
            <param name="items">The set of items to be queries.  <c>null</c> will treated as an empty set.</param>
            <param name="options">Optionally customize selector case sensitivity and other behaviors.</param>
        </member>
        <member name="P:Neon.Common.LabelSelector`1.CaseInsensitive">
            <summary>
            Indicates that we're doing case insensitive label value comparisons.
            </summary>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.GetItemsWith(System.String)">
            <summary>
            Returns the set of items including a specific label.
            </summary>
            <param name="labelKey">The desired label key.</param>
            <returns>The set of items with the label.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.GetItemsWithout(System.String)">
            <summary>
            Returns the set of items that do not include the label.
            </summary>
            <param name="labelKey">The undesired label key.</param>
            <returns>The set of items without the label.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector`1.Select(System.String)">
            <summary>
            Returns the set of items that satisfy a label selector.
            </summary>
            <param name="labelSelector">The label selector condistions(s).</param>
            <returns>The set of items whose meet the query requirements.</returns>
            <exception cref="T:System.FormatException">Thrown when the label selector is not valid.</exception>
            <remarks>
            <para>
            This class supports Kubernetes style label selectors:
            </para>
            <para>
            <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">Kubernetes: Labels and Selectors</a>
            </para>
            <para>
            Label selectors must include zero or more label conditions separated by commas. All label 
            conditions must be satisfied for an item to be selected. The conditions are essentially AND-ed together.
            We'll support two basic types of label conditions: equality/inequality and set based.
            </para>
            <note>
            A <c>null</c> or empty <paramref name="labelSelector"/> simply returns all items.
            </note>
            <para><b>equality/inequality conditions:</b></para>
            <code language="none">
            [label] = [value]
            [label] == [value]
            [label] != [value]      
            </code>
            <para>
            The first two examples two compare label value equality and the last compares for inequality. 
            Note that it is not currently possible to compare an empty or null string.
            </para>
            <para><b>set conditions:</b></para>
            <code language="none">
            [label] in ([value1], [value2],,...)
            notin([value1], [value2],...)
            [label]
            ![label]
            </code>
            <para>
            The first example selects items if they have a label with any of the values listed and the second 
            selects items that have the label that doesn't have any of the values. The last two examples select 
            items when they have or don't have a label, regardless of its value.
            </para>
            <note>
            The <b>in</b> and <b>notin</b> operators both require that the item have the target label for a match.
            </note>
            <note>
            <b>Case Sensitivity:</b> Label name lookups are actually determined by the dictionary returned
            by each item.  .NET string dictionaries are typically case sensitive by default but you can
            change this behavior by having your item implementations construct case insenstive dictionaries.
            By default, this class performs case insensitive comparisions for label values.  You can override
            this by passing <see cref="F:Neon.Common.LabelSelectorOptions.CaseInsensitiveValues"/> to the
            <see cref="M:Neon.Common.LabelSelector`1.#ctor(System.Collections.Generic.IEnumerable{`0},Neon.Common.LabelSelectorOptions)"/> constructor.
            </note>
            <note>
            <para>
            <b>Label Name Constraints:</b> Label keys are checked to ensure that they match Kubernetes conventions
            by default.  You can override this by passing <see cref="F:Neon.Common.LabelSelectorOptions.UnConstraintedLabels"/> to the
            <see cref="M:Neon.Common.LabelSelector`1.#ctor(System.Collections.Generic.IEnumerable{`0},Neon.Common.LabelSelectorOptions)"/> constructor.
            </para>
            <para>
            <b>Label Value Constraints:</b> Label values are also checked to ensure that they match Kubernetes conventions
            by default.  This behavior can also be overriden by passing to the constructor.
            </para>
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Common.LabelSelector">
            <summary>
            Implements label related utilities.
            </summary>
        </member>
        <member name="M:Neon.Common.LabelSelector.IsAlphaNum(System.Char)">
            <summary>
            Determines whether a character is [a-z0-9A-Z].
            </summary>
            <param name="ch">The test character.</param>
            <returns><c>true</c> for valid.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector.IsValidPunctuation(System.Char)">
            <summary>
            Determines whether a character is a valid label punctuation character.
            </summary>
            <param name="ch">The test character.</param>
            <returns><c>true</c> for valid.</returns>
        </member>
        <member name="M:Neon.Common.LabelSelector.ValidateLabelKey(System.String)">
            <summary>
            Validates a label key.
            </summary>
            <param name="labelKey">The label key.</param>
            <exception cref="T:System.FormatException">Thrown if the key is not valid.</exception>
        </member>
        <member name="M:Neon.Common.LabelSelector.ValidateLabelValue(System.String)">
            <summary>
            Validates a label value.
            </summary>
            <param name="labelValue">The label value.</param>
            <exception cref="T:System.FormatException">Thrown if the key is not valid.</exception>
        </member>
        <member name="T:Neon.Common.LabelSelectorOptions">
            <summary>
            <see cref="T:Neon.Common.LabelSelector`1"/> related options.
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelectorOptions.None">
            <summary>
            No options are selected.
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelectorOptions.CaseInsensitiveValues">
            <summary>
            <para>
            Normally <see cref="T:Neon.Common.LabelSelector`1"/> matches label values using
            case sensitive comparisons.  Use this to make the comparisons case
            insensitive.
            </para>
            <note>
            Label name case sensitivity is determined by the the dictionaries returned
            by the item <see cref="M:Neon.Common.ILabeled.GetLabels"/> method.
            </note>
            </summary>
        </member>
        <member name="F:Neon.Common.LabelSelectorOptions.UnConstraintedLabels">
            <summary>
            <see cref="T:Neon.Common.LabelSelector`1"/> defaults to parsing label names
            and values to ensure that they are Kubernetes compliant.  Use this 
            to disable this so you can use arbitrary labels.
            </summary>
        </member>
        <member name="T:Neon.Common.NotReadyException">
            <summary>
            Indicates that a component is not ready to perform an operation but may
            become ready in the future.
            </summary>
        </member>
        <member name="M:Neon.Common.NotReadyException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.NotReadyException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs an exception with a specific message and optional inner exception.
            </summary>
            <param name="message">The custom message.</param>
            <param name="innerException">Optional inner exception.</param>
        </member>
        <member name="T:Neon.Common.ProgramExitException">
            <summary>
            Used to signal that a program or tool should exit.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramExitException.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="exitCode">The desired program exit code.</param>
        </member>
        <member name="P:Neon.Common.ProgramExitException.ExitCode">
            <summary>
            Returns the desired program exit code.
            </summary>
        </member>
        <member name="T:Neon.Common.SemanticVersion">
            <summary>
            Implements a semantic version as defined by the <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning 2.0.0</a>
            specification.  This is similar to the base <see cref="T:System.Version"/> class but includes support for pre-release identifiers
            as well as build information.
            </summary>
        </member>
        <member name="M:Neon.Common.SemanticVersion.TryParse(System.String,Neon.Common.SemanticVersion@)">
            <summary>
            Attempts to parse a semantic version string.
            </summary>
            <param name="versionText">The version text.</param>
            <param name="version">Returns as the parsed version on success.</param>
            <returns><c>true</c> if the version was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Parse(System.String)">
            <summary>
            Parses a semantic version string.
            </summary>
            <param name="versionText">The version text.</param>
            <returns>The parsed <see cref="T:Neon.Common.SemanticVersion"/>.</returns>
            <exception cref="T:System.FormatException">Thrown if the version could not be parsed.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Create(System.Int32,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Creates a semantic version number from parameters.
            </summary>
            <param name="major">The major version.</param>
            <param name="minor">Optional minor version.</param>
            <param name="patch">Optional patch version.</param>
            <param name="build">Optional build.</param>
            <param name="prerelease">Optional prerelease.</param>
            <returns>The <see cref="T:Neon.Common.SemanticVersion"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if any of the parameters are invalid.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Compare(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two non-null semantic versions.
            </summary>
            <param name="v1">The first version.</param>
            <param name="v2">The second version.</param>
            <returns>
            <b>-1</b> if <paramref name="v1"/> is less than <paramref name="v2"/><br/>
            <b>0</b> if <paramref name="v1"/> equals <paramref name="v2"/><br/>
            <b>+1</b> if <paramref name="v1"/> is greater than <paramref name="v2"/>
            </returns>
            <remarks>
            <note>
            A <c>null</c> version is considered to be less than a non-null version.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Equality(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances for equality.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> if the versions have the same precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Inequality(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances for inequality.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> if the versions have the different precedences.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_GreaterThan(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is greater.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has greater precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_GreaterThanOrEqual(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is greater or equal.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has the same or greater precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_LessThan(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is less.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has lower precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_LessThanOrEqual(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is less or equal.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has the same or lower precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Explicit(Neon.Common.SemanticVersion)~System.String">
            <summary>
            Explicitly casts a <see cref="T:Neon.Common.SemanticVersion"/> into a string.
            </summary>
            <param name="version">The version input.</param>
            <returns>The version converted to a string.</returns>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Explicit(System.String)~Neon.Common.SemanticVersion">
            <summary>
            Explicitly casts a string into a <see cref="T:Neon.Common.SemanticVersion"/>.
            </summary>
            <param name="version">The version input.</param>
            <returns>The string converted to a <see cref="T:Neon.Common.SemanticVersion"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.#ctor">
            <summary>
            Default constuctor.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Major">
            <summary>
            The major version number.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Minor">
            <summary>
            The minor version number.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Patch">
            <summary>
            The patch version number.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Numeric">
            <summary>
            Returns only the numeric part of the semantic version, excluding
            any prerelase or build parts.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Prerelease">
            <summary>
            <para>
            The prerelease identifer or <c>null</c>.
            </para>
            <note>
            Prerelease identifiers <b>do not</b> include the prefix dash <b>(-)</b>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.IsPrerelease">
            <summary>
            Indicates whether the version specifies a prerelease.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Build">
            <summary>
            <para>
            The build information or <c>null</c>.
            </para>
            <note>
            Build information does not include the prefix plus <b>(+)</b> sign.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.SemanticVersion.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.SemanticVersion.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.SemanticVersion.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.ServiceContainer">
            <summary>
            This class combines the capabilities of a <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and
            <see cref="T:System.IServiceProvider"/> into a single object that implements the
            combined <see cref="T:Neon.Common.IServiceContainer"/> interface.
            </summary>
            <remarks>
            <para>
            The design of <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and <see cref="T:System.IServiceProvider"/> seems
            somewhat limited.  This assumes that applications explicitly initialize a <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/>
            instance during startup and then call <c>BuildServiceProvider()</c> to return the <see cref="T:System.IServiceProvider"/>
            that can actually be used to find a service at runtime.
            </para>
            <para>
            This works fine for lots of applications, but with a framework like Neon, it is
            useful to have a global service provider that allows the client to register
            default services for applications that are not coded to be aware of dependency
            injection.  The problem with the Microsoft DependencyInjection design is that
            additional services registered after a <c>BuildServiceProvider()</c> call will 
            not be returned by the service provider.
            </para>
            <para>
            This class combines both these capabilities into a single class such that 
            services can be registered and located dynamically without ever having to
            call <c>BuildServiceProvider()</c>.
            </para>
            <note>
            The <c>BuildServiceProvider()</c> extension methods still work the same and
            return only a point-in-time snapshot of the services.  You may not need to
            call these though, because you can call <see cref="M:Neon.Common.ServiceContainer.GetService(System.Type)"/> directly.
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Clone">
            <summary>
            Returns a clone of the instance.  This can be useful for unit testing to save
            the service container before executing a test and then restoring it afterwards.
            </summary>
            <returns>The cloned instance.</returns>
        </member>
        <member name="P:Neon.Common.ServiceContainer.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Common.ServiceContainer.Count">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Common.ServiceContainer.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Add(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Contains(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.CopyTo(Microsoft.Extensions.DependencyInjection.ServiceDescriptor[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Insert(System.Int32,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Remove(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.IndexOf(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.GetService``1">
            <summary>
            This is a convenience generic method that returns the service
            already cast to requested type.
            </summary>
            <typeparam name="TService">Specifies the desired service type.</typeparam>
            <returns>The service instance if it exists or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.ServiceContainer.GetService(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.Stub">
            <summary>
            Used in situations where an innocous parameter is required to disambiguate
            constructor or method overloads.
            </summary>
        </member>
        <member name="T:Neon.Common.Stub.Value">
            <summary>
            An empty value structure.
            </summary>
        </member>
        <member name="F:Neon.Common.Stub.Param">
            <summary>
            Returns the stub value.
            </summary>
        </member>
        <member name="T:Neon.Common.ToolException">
            <summary>
            Typically thrown when a tool or subprocess is executed an fails.
            </summary>
        </member>
        <member name="M:Neon.Common.ToolException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The optional exception message.</param>
            <param name="inner">The optional inner exception.</param>
        </member>
        <member name="T:Neon.Common.AppDomainExtensions">
            <summary>
            Implements <see cref="T:System.AppDomain"/> extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.AppDomainExtensions.GetUserAssemblies(System.AppDomain)">
            <summary>
            Enumerates all non <b>System</b> and <b>Microsoft</b> assemblies currently
            loaded in the <see cref="T:System.AppDomain"/>.  This can be used as a performance
            optimization when you only need to scan user assemblies.
            </summary>
            <param name="appDomain">The <see cref="T:System.AppDomain"/>.</param>
            <returns>The enumerated assemblies.</returns>
        </member>
        <member name="T:Neon.Common.DateTimeExtensions">
            <summary>
            <see cref="T:System.DateTime"/> extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.DateTimeExtensions.RoundUp(System.DateTime,System.TimeSpan)">
            <summary>
            <para>
            Rounds a <see cref="T:System.DateTime"/> up to the nearest specified interval, like:
            </para>
            <code language="c#">
            var date      = new DateTime(2010, 02, 05, 10, 35, 25, 450); // 2010/02/05 10:35:25
            var roundedUp = date.RoundUp(TimeSpan.FromMinutes(15));      // 2010/02/05 10:45:00
            </code>
            </summary>
            <param name="value">The datetime to be rounded.</param>
            <param name="interval">The time interval to be rounded to.</param>
            <returns>The rounded date.</returns>
        </member>
        <member name="M:Neon.Common.DateTimeExtensions.RoundDown(System.DateTime,System.TimeSpan)">
            <summary>
            <para>
            Rounds a <see cref="T:System.DateTime"/> down to the nearest specified interval, like:
            </para>
            <code language="c#">
            var date        = new DateTime(2010, 02, 05, 10, 35, 25, 450); // 2010/02/05 10:35:25
            var roundedDown = date.RoundDown(TimeSpan.FromMinutes(15));    // 2010/02/05 10:30:00
            </code>
            </summary>
            <param name="value">The datetime to be rounded.</param>
            <param name="interval">The time interval to be rounded to.</param>
            <returns></returns>
        </member>
        <member name="M:Neon.Common.DateTimeExtensions.RoundToNearest(System.DateTime,System.TimeSpan)">
            <summary>
            <para>
            Rounds a <see cref="T:System.DateTime"/> to the nearest specified interval, like:
            </para>
            <code language="c#">
            var date             = new DateTime(2010, 02, 05, 10, 35, 25, 450);   // 2010/02/05 10:35:25
            var roundedToNearest = date.RoundToNearest(TimeSpan.FromMinutes(15)); // 2010/02/05 10:30:00
            </code>
            </summary>
            <param name="value">The datetime to be rounded.</param>
            <param name="interval">The time interval to be rounded to.</param>
            <returns></returns>
        </member>
        <member name="M:Neon.Common.DateTimeExtensions.ToUnixEpochMilliseconds(System.DateTime)">
            <summary>
            Converts the <see cref="T:System.DateTime"/> into the number of milliseconds since the
            Unix Epoc (midnight 1-1-1070 UTC).
            </summary>
            <param name="value">The time being converted.</param>
            <returns>The Unix time in milliseconds.</returns>
        </member>
        <member name="M:Neon.Common.DateTimeExtensions.ToUnixEpochNanoseconds(System.DateTime)">
            <summary>
            Converts the <see cref="T:System.DateTime"/> into the number of neonseconds since the
            Unix Epoc (midnight 1-1-1070 UTC).
            </summary>
            <param name="value">The time being converted.</param>
            <returns>The Unix time in naonseconds.</returns>
        </member>
        <member name="T:Neon.Common.EnumerationExtensions">
            <summary>
            Implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.EnumerationExtensions.TakeUpTo``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns up to the specified number of items from the front of an enumerable.
            If the enumerable includes less than <paramref name="maxCount"/> then this
            will return all of the items.
            </summary>
            <typeparam name="T">Specifies the enumerab;e's item type.</typeparam>
            <param name="items">Specifies the enumerable to take items from.</param>
            <param name="maxCount">Specifies the maximumnumber of items to to take.</param>
            <returns>The taken items.</returns>
        </member>
        <member name="T:Neon.Common.EnumExtensions">
            <summary>
            <see cref="T:System.Enum"/> extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.EnumExtensions.ToMemberString(System.Enum)">
            <summary>
            Converts an enumeration value into a string, using the <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            value if one was specified for the value in the enumeration type definition otherwise
            the default enumeration value name will be returned.
            </summary>
            <param name="value">The enumeration value to be converted.</param>
            <returns>The member or default string value.</returns>
            <remarks>
            This is useful because <see cref="M:System.Enum.ToString"/> ignores any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            attributes.
            </remarks>
        </member>
        <member name="T:Neon.Common.ExceptionExtensions">
            <summary>
            <see cref="T:System.Exception"/> extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.ExceptionExtensions.Contains``1(System.Exception)">
            <summary>
            Determines whether the exception has a specified type or was triggered by
            an underlying exception of a specified type.  This is useful for checking whether
            an exception has a specific inner exception or whether an <see cref="T:System.AggregateException"/>
            was triggered with a specific exception type.
            </summary>
            <typeparam name="T">The target exception type.</typeparam>
            <param name="e">The exception being tested.</param>
            <returns><c>true</c> if the exception was triggered by an exception of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Common.ExceptionExtensions.Find``1(System.Exception)">
            <summary>
            Searches an exception for an underlying exception of a specific type specified as a generic
            type parameter.   This is useful for  checking whether an exception has a specific inner 
            exception or whether an <see cref="T:System.AggregateException"/> was triggered with a specific 
            exception type.
            </summary>
            <typeparam name="T">The target exception type.</typeparam>
            <param name="e">The exception being tested.</param>
            <returns>The underlying exception or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.ExceptionExtensions.Find(System.Exception,System.Type)">
            <summary>
            Searches an exception for an underlying exception of a specific type.  This is useful for 
            checking whether an exception has a specific inner exception or whether an <see cref="T:System.AggregateException"/>
            was triggered with a specific exception type.
            </summary>
            <param name="e">The exception being tested.</param>
            <param name="exceptionType">The target exception type.</param>
            <returns>The underlying exception or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.ExceptionExtensions.GetNonAggregateException(System.Exception)">
            <summary>
            Examines the exception passed and if it's a <see cref="T:System.AggregateException"/> then the
            first inner exception will be returned.  This is handy when you need to log the details
            of the underlying exception thrown by an async operation.
            </summary>
            <param name="e">The exception.</param>
            <returns>The underlying exception.</returns>
        </member>
        <member name="T:Neon.Common.Extensions.ExpressionExtensions">
            <summary>
            Provides extension methods for working with <see cref="T:System.Linq.Expressions.Expression"/> objects.
            </summary>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical OR operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.OrAssign``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical OR assignment operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.OrElse``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical ORElse operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.ExclusiveOr``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical Exclusive OR operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.ExclusiveOrAssign``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical Exclusive OR assignment operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical AND operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.AndAlso``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical ANDAlso operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="M:Neon.Common.Extensions.ExpressionExtensions.AndAssign``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Combines two expressions using the logical AND assignment operator.
            </summary>
            <typeparam name="T">The type of the parameter in the expressions.</typeparam>
            <param name="expression1">The first expression.</param>
            <param name="expression2">The second expression.</param>
            <returns>The combined expression.</returns>
        </member>
        <member name="T:Neon.Common.HttpClientExtensions">
            <summary>
            <see cref="T:System.Net.Http.HttpClient"/> extension methods, mostly related to easily supporting custom headers.
            </summary>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.AddHeaders(System.Net.Http.HttpRequestMessage,Neon.Collections.ArgDictionary)">
            <summary>
            Adds headers to an HTTP request.
            </summary>
            <param name="request">The request.</param>
            <param name="headers">Optionally specifies a dictionary of headers.</param>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a GET request to the specified string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a GET request to a specified <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetByteArrayAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified string URI and returns the response body as a byte array.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response byte array.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetByteArrayAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified <see cref="T:System.Uri"/> and returns the response body as a byte array.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response byte array.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStreamAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified string URI and returns the response body as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response stream.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStreamAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified <see cref="T:System.Uri"/> and returns the response body as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response stream.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStringAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET request to a string URI and returns the response as a string.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStringAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET request to a <see cref="T:System.Uri"/> and returns the response as a string.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PostAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a POST request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PostAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a POST request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PutAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PUT request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PutAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PUT request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.DeleteAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a DELETE request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.DeleteAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a DELETE request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PatchAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PATCH request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PatchAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PATCH request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.OptionsAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a OPTIONS request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.OptionsAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a OPTIONS request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.HeadAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a HEAD request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.HeadAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a HEAD request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.SendAsync(System.Net.Http.HttpClient,System.Net.Http.HttpRequestMessage,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends an <see cref="T:System.Net.Http.HttpRequestMessage"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="request">The request.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the request has already been sent by the <see cref="T:System.Net.Http.HttpClient"/> class.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.EnsureSuccess(System.Net.Http.HttpResponseMessage)">
            <summary>
            Ensures that an HTTP operation succedded but thrown an exception if it didn't.
            </summary>
            <param name="response">The response to be checked.</param>
            <returns>The <paramref name="response"/> on success.</returns>
            <exception cref="T:Neon.Net.HttpException">Thrown for failures.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetSafeAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a GET request to the specified string URI ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetSafeAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a GET request to a specified <see cref="T:System.Uri"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetByteArraySafeAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified string URI and returns the response body as a byte array ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response byte array.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetByteArraySafeAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified <see cref="T:System.Uri"/> and returns the response body as a byte array ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response byte array.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStreamSafeAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified string URI and returns the response body as a <see cref="T:System.IO.Stream"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response stream.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStreamSafeAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET to a specified <see cref="T:System.Uri"/> and returns the response body as a <see cref="T:System.IO.Stream"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response stream.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStringSafeAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET request to a string URI and returns the response as a string ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetStringSafeAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary)">
            <summary>
            Sends a GET request to a <see cref="T:System.Uri"/> and returns the response as a string ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The response string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetToStreamSafeAsync(System.Net.Http.HttpClient,System.String,System.IO.Stream,Neon.Collections.ArgDictionary)">
            <summary>
            Downloads the contents of a string URI to a stream.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="output">The stream where the URI contents will be written.</param>
            <param name="headers">Optional request headers.</param>
            /// <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/> making things like response headers available.</returns>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetToStreamSafeAsync(System.Net.Http.HttpClient,System.Uri,System.IO.Stream,Neon.Collections.ArgDictionary)">
            <summary>
            Downloads the contents of a URI to a stream.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="output">The stream where the URI contents will be written.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/> making things like response headers available.</returns>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetToFileSafeAsync(System.Net.Http.HttpClient,System.String,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Downloads the contents of a string URI to a file.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="outputPath">The path to the output file.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/> making things like response headers available.</returns>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.GetToFileSafeAsync(System.Net.Http.HttpClient,System.Uri,System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Downloads the contents of a string URI to a file.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="outputPath">The path to the output file.</param>
            <param name="headers">Optional request headers.</param>
            <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/> making things like response headers available.</returns>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PostSafeAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a POST request to a string URI ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PostSafeAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a POST request to a <see cref="T:System.Uri"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PutSafeAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PUT request to a string URI ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PutSafeAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PUT request to a <see cref="T:System.Uri"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.DeleteSafeAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a DELETE request to a string URI ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.DeleteSafeAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a DELETE request to a <see cref="T:System.Uri"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PatchSafeAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PATCH request to a string URI ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.PatchSafeAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a PATCH request to a <see cref="T:System.Uri"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.OptionsSafeAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a OPTIONS request to a string URI ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.OptionsSafeAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a OPTIONS request to a <see cref="T:System.Uri"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.HeadSafeAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a HEAD request to a string URI ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.HeadSafeAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a HEAD request to a <see cref="T:System.Uri"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Common.HttpClientExtensions.SendSafeAsync(System.Net.Http.HttpClient,System.Net.Http.HttpRequestMessage,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends an <see cref="T:System.Net.Http.HttpRequestMessage"/> ensuring that the operation succeeded.
            </summary>
            <param name="client">The client.</param>
            <param name="request">The request.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the request has already been sent by the <see cref="T:System.Net.Http.HttpClient"/> class.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="T:Neon.Common.HttpResponseMessageExtensions">
            <summary>
            Implements <see cref="T:System.Net.Http.HttpResponseMessage"/> extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.HttpResponseMessageExtensions.EnsureSuccessStatusCodeEx(System.Net.Http.HttpResponseMessage)">
            <summary>
            Throws a <see cref="T:System.Net.Http.HttpRequestException"/> when the response status code does not
            indicate success.  This improves on <see cref="M:System.Net.Http.HttpResponseMessage.EnsureSuccessStatusCode"/>
            by including the URI in the exception message.
            </summary>
            <param name="response">The HTTP response received</param>
        </member>
        <member name="T:Neon.Common.IEnumerableExtensions">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.IEnumerableExtensions.SelectRandom``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Selects one or more randomly selected items from an enumeration.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="items">The source items.</param>
            <param name="count">The number of values to be returned (defaults to <b>1</b>.</param>
            <returns>The randomly selected items as an enumeration.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="count"/> is not positive or if <paramref name="items"/> does
            not have at least <paramref name="count"/> items.
            </exception>
        </member>
        <member name="M:Neon.Common.IEnumerableExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether an <see cref="T:System.Collections.IEnumerable"/> is empty.
            </summary>
            <typeparam name="T">The enumeration value type.</typeparam>
            <param name="items">The items to be tested.</param>
            <param name="predicate">Optional item selector.</param>
            <returns><c>true</c> if <paramref name="items"/> is empty.</returns>
        </member>
        <member name="T:Neon.Common.IOExtensions">
            <summary>
            Implements I/O related class extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.IOExtensions.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Writes a byte array to a stream.
            </summary>
            <param name="stream">The stream.</param>
            <param name="bytes">The byte array.</param>
        </member>
        <member name="M:Neon.Common.IOExtensions.WriteAsync(System.IO.Stream,System.Byte[])">
            <summary>
            Asynchronously writes a byte array to a stream.
            </summary>
            <param name="stream">The stream.</param>
            <param name="bytes">The byte array.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Common.IOExtensions.ReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Reads the byte array from the current position, advancing
            the position past the value read.
            </summary>
            <param name="stream">The stream.</param>
            <param name="cb">The number of bytes to read.</param>
            <returns>
            The byte array.  Note that the array returned may have a length
            less than the size requested if the end of the file has been
            reached.
            </returns>
        </member>
        <member name="M:Neon.Common.IOExtensions.ReadToEnd(System.IO.Stream)">
            <summary>
            Reads all bytes from the current position to the end of the stream.
            </summary>
            <param name="stream">The source stream.</param>
            <returns>The byte array.</returns>
        </member>
        <member name="M:Neon.Common.IOExtensions.ReadToEndAsync(System.IO.Stream)">
            <summary>
            Asynchronously reads all bytes from the current position to the end of the stream.
            </summary>
            <param name="stream">The source stream.</param>
            <returns>The byte array.</returns>
        </member>
        <member name="M:Neon.Common.IOExtensions.DeflateTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses deflate to compress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:Neon.Common.IOExtensions.InflateTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses deflate to decompress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:Neon.Common.IOExtensions.GzipTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses GZIP to compress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:Neon.Common.IOExtensions.GunzipTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses GZIP to decompress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:Neon.Common.IOExtensions.Lines(System.IO.TextReader,System.Boolean)">
            <summary>
            Returns an enumerator that returns the lines of text from a <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="reader">The reader.</param>
            <param name="ignoreBlank">Optionally skip empty lines or lines with oly whitespace.</param>
            <returns>The <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="T:Neon.Common.StaticZipOptions">
            <summary>
            Enumerates the ZIP options for <see cref="M:Neon.Common.IStaticDirectoryExtensions.ZipAsync(Neon.IO.IStaticDirectory,System.IO.Stream,System.String,System.IO.SearchOption,Neon.Common.StaticZipOptions,Neon.Common.ZipPreprocessor)"/> and
            <see cref="M:Neon.Common.IStaticDirectoryExtensions.ZipAsync(Neon.IO.IStaticDirectory,System.String,System.String,System.IO.SearchOption,Neon.Common.StaticZipOptions,Neon.Common.ZipPreprocessor)"/>.  These may be bitwise ORed togther
            in various combinations.
            </summary>
        </member>
        <member name="F:Neon.Common.StaticZipOptions.None">
            <summary>
            No special options required.  This is the default.
            </summary>
        </member>
        <member name="F:Neon.Common.StaticZipOptions.LinuxLineEndings">
            <summary>
            <para>
            Convert any Windows CRLF line endings into Linux compatiable LF endings.
            </para>
            <note>
            Any line endings are converted <b>before</b> the preprocessor is called, when a
            preprocessor is specified.
            </note>
            </summary>
        </member>
        <member name="T:Neon.Common.ZipPreprocessor">
            <summary>
            Specifies a preprocessor that can be used to preprocess files before they
            are added to a ZIP archive.
            </summary>
            <param name="path">
            Specifies the path of the file being preprocessed relative to the folder being zipped.
            Your delegate implementation may decide whether and/or how to preprocess the file based
            on this path, often using file name or extension.
            </param>
            <param name="input">Specifies a stream holding the file data being preprocessed.</param>
            <returns>As the processed stream.</returns>
        </member>
        <member name="T:Neon.Common.IStaticDirectoryExtensions">
            <summary>
            Extension methods for <see cref="T:Neon.IO.IStaticDirectory"/>.
            </summary>
        </member>
        <member name="M:Neon.Common.IStaticDirectoryExtensions.ZipAsync(Neon.IO.IStaticDirectory,System.String,System.String,System.IO.SearchOption,Neon.Common.StaticZipOptions,Neon.Common.ZipPreprocessor)">
            <summary>
            Creates a ZIP file, including the selected files from the static directory.
            </summary>
            <param name="directory">The static directory instance.</param>
            <param name="zipPath">Path to the output ZIP file.</param>
            <param name="searchPattern">
            Optionally specifies a file name pattern using standard file system wildcards
            like <b>[*]</b> and <b>[?]</b>.  This defaults to including all files.
            </param>
            <param name="searchOptions">Optionally perform a recursive search.  This defaults to 
            <see cref="F:System.IO.SearchOption.TopDirectoryOnly"/>.
            </param>
            <param name="zipOptions">
            Additional options that control things like whether the files are zipped within
            the parent directory or whether the files are assumed to contain UTF-8 text and
            that Windows style CRLF line endings are to be converted to Linux compatible LF 
            endings.  You can combine options by bitwise ORing them.  This defaults to
            <see cref="F:Neon.Common.StaticZipOptions.None"/>.
            </param>
            <param name="preprocessor">
            Optionally specifies a preprocessor that can modify files before they are
            added to the ZIP archive.
            </param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            <note>
            The current implementation loads the files into memory so this isn't really suitable
            for zipping very large files.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.IStaticDirectoryExtensions.ZipAsync(Neon.IO.IStaticDirectory,System.IO.Stream,System.String,System.IO.SearchOption,Neon.Common.StaticZipOptions,Neon.Common.ZipPreprocessor)">
            <summary>
            Writes a ZIP file to a stream, including the selected files from the static directory.
            </summary>
            <param name="directory">The static directory instance.</param>
            <param name="zipStream">The output stream.</param>
            <param name="searchPattern">
            Optionally specifies a file name pattern using standard file system wildcards
            like <b>[*]</b> and <b>[?]</b>.  This defaults to including all files.
            </param>
            <param name="searchOptions">Optionally perform a recursive search.  This defaults to 
            <see cref="F:System.IO.SearchOption.TopDirectoryOnly"/>.
            </param>
            <param name="zipOptions">
            Additional options that control things like whether the files are zipped within
            the parent directory or whether the files are assumed to contain UTF-8 text and
            that Windows style CRLF line endings are to be converted to Linux compatible LF 
            endings.  You can combine options by bitwise ORing them.  This defaults to
            <see cref="F:Neon.Common.StaticZipOptions.None"/>.
            </param>
            <param name="preprocessor">
            Optionally specifies a preprocessor that can modify files before they are
            added to the ZIP archive.
            </param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            <note>
            The current implementation loads the files into memory so this isn't really suitable
            for zipping very large files.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Common.NeonAssemblyExtensions">
            <summary>
            Implements custom <see cref="T:System.Reflection.Assembly"/> extension methods.
            </summary>
        </member>
        <member name="T:Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory">
            <summary>
            Used to emulate resource directories.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory.#ctor(Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory,Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="root">The root directory or <c>null</c> if this is the root.</param>
            <param name="parent">The parent directory or <c>null</c> for the root directory.</param>
            <param name="name">The directory name (this must be <c>null</c> for the root directory.</param>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory.AddDirectory(Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory)">
            <summary>
            Adds a subdirectory if it doesn't already exist.
            </summary>
            <param name="directory">The child resource directory.</param>
            <returns>The existing <see cref="T:Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory"/> or <paramref name="directory"/> if it was added</returns>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceDirectory.AddFile(Neon.Common.NeonAssemblyExtensions.StaticResourceFile)">
            <summary>
            Adds a file.
            </summary>
            <param name="file">The resource file.</param>
        </member>
        <member name="T:Neon.Common.NeonAssemblyExtensions.StaticResourceFile">
            <summary>
            Wraps an embedded resource so it can be included in a static file system.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.#ctor(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="path">The virtual path of the file within the file system.</param>
            <param name="assembly">The source assembly.</param>
            <param name="resourceName">The full name of the resource within the assembly.</param>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.OpenReader(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.OpenReaderAsync(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.OpenStream">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.OpenStreamAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.ReadAllBytes">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.ReadAllBytesAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.ReadAllText(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.StaticResourceFile.ReadAllTextAsync(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.GetResourceFileSystem(System.Reflection.Assembly,System.String)">
            <summary>
            Returns an eumlated static file system that includes some or all of an assembly's
            embedded resources.  This method returns the root <see cref="T:Neon.IO.IStaticDirectory"/>
            for the file system.
            </summary>
            <param name="assembly">The target assembly.</param>
            <param name="resourcePrefix">
            <para>
            Specifies the resource name prefix to be used to identify the embedded resources
            to be included in the static file system.  See the remarks for more information.
            </para>
            </param>
            <returns>The root <see cref="T:Neon.IO.IStaticDirectory"/>.</returns>
            <remarks>
            <para>
            This method maps Linux style paths (using forward not back slashes) to embedded
            resources in the assembly.  Resources in .NET projects are embedded and named
            like:
            </para>
            <example>
            ASSEMBLY-NAMESPACE [ "." DIR ] "." RESOURCE-FILENAME
            </example>
            <para>
            where <b>ASSEMBLY-NAME</b> is the name of the source assembly, <b>DIR</b> optionally
            specifies the directoriea to the resource and <b>RESOURCE-FILENAME</b> specifies the name
            of the resource file.
            </para>
            <para>
            When a .NET project is built, any source files with build actions set to <b>Embedded Resource</b>
            will be included in the assembly using the naming convention described above.  The 
            <b>ASSEMBLY-NAMESPACE</b> will be set to the source projects default namespace and the <b>DIR</b>s
            will be set to the relative path from the project file to the source resource file.  For
            example, if your project is structured like:
            </para>
            <code>
            my-project/
                my-project.csproj
                
                top-level.txt
                resources/
                    resource1.dat
                    resource2.dat
                    tests/
                        test1.txt
                        test2.txt
                    samples/
                        sample1.txt
                        sample2.txt
            </code>
            <para>
            and its default namespace is <b>company.mproject</b>, then the following resources embedded 
            in your project assembly:
            </para>
            <code>
            company.my-project.top-level.txt
            company.my-project.resources.resource1.dat
            company.my-project.resources.resource2.dat
            company.my-project.resources.tests.test1.txt
            company.my-project.resources.tests.test2.txt
            company.my-project.resources.samples.sample1.txt
            company.my-project.resources.samples.sample2.txt
            </code>
            <para>
            By default, calling <see cref="M:Neon.Common.NeonAssemblyExtensions.GetResourceFileSystem(System.Reflection.Assembly,System.String)"/> on your project assembly 
            will return a <see cref="T:Neon.IO.IStaticDirectory"/> with a directory structure holding all of the resources.  
            The paths are mapped from the resource names by converting any dots except for the last one into forward
            slashes. 
            </para>
            <code>
            /
                company/
                    my-project/
                        top-level.txt
                        resources/
                            resource1.dat
                            resource2.dat
                            tests/
                                test1.txt
                                test2.txt
                            samples/
                                sample1.txt
                                sample2.txt
            </code>
            <para>
            You can also pass an optional resource name prefix so that only a subset of the resources
            are included in the file system.  For example, by passing <b>company.my-project.resources</b>,
            file system returned will look like:
            </para>
            <code>
            /
                resource1.dat
                resource2.dat
                tests/
                    test1.txt
                    test2.txt
                samples/
                    sample1.txt
                    sample2.txt
            </code>
            <para><b>RESOURCE NAMING AMBIGUITIES</b></para>
            <para>
            When creating the file system from resource names, it's possible to encounter situations
            where it's not possible to distingish between a a directory and a file name.  For example:
            </para>
            <code>
            company.my-project.resources.resource1.dat
            </code>
            <para>
            Here are some possibilities:
            </para>
            <list type="bullet">
                <item>
                path is <b>/company.my-project.resources.resource1</b> and the file name <b>dat</b>
                </item>
                <item>
                path is <b>/company.my-project.resources</b> and the file name <b>resource1.dat</b>
                </item>
                <item>
                path is <b>/company.my-project</b> and the file name <b>.resources.resource1.dat</b>
                </item>
            </list>
            <para>
            There is really no way for this method to know what the original resource source files
            and directory paths were.  To resolve this, we're going to assume that resource file
            names include a file extension with a single dot and that any additional dots will form
            the file's parent directory path.
            </para>
            <note>
            All resource file names must include an extension to be loaded properly.  If you need
            a file to be loaded <b>without an extension</b>, save the file with the special <b>"._"</b>
            extension like <b>test._</b>.  This method will remove that special extension when reading
            files with it.
            </note>
            <para>
            What this means is that your resource file names must include a file extension.  So, file 
            names like this are OK:
            </para>
            <code>
            schema.sql
            config.json
            </code>
            <para>
            You should avoid file names like:
            </para>
            <code>
            schema.1.sql
            </code>
            <para>
            and use something like a dash instead so that <b>schema</b> won't be considered to
            be part of the file's parent directory path:
            </para>
            <code>
            schema-1.sql
            </code>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonAssemblyExtensions.GetExtensionMethodsFor(System.Reflection.Assembly,System.Type,System.Boolean)">
            <summary>
            <para>
            Retrieves all of the extensions methods in an assembly targeting a specific type.
            </para>
            <note>
            This doesn't currently support nested or generic target types.
            </note>
            </summary>
            <param name="assembly">The source assembly.</param>
            <param name="targetType">The type being extended.</param>
            <param name="allowPrivate">Optionally specifies that only private methods are to be returned as well as public ones.</param>
            <returns>The extension methods.</returns>
        </member>
        <member name="T:Neon.Common.NewtonsoftExtensions">
            <summary>
            Newtonsoft JSON Linq extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.NewtonsoftExtensions.TryGetValue``1(Newtonsoft.Json.Linq.JObject,System.String,``0@)">
            <summary>
            Attempts to return the value of a specified <see cref="T:Newtonsoft.Json.Linq.JObject"/> property
            converted to a specific type.
            </summary>
            <typeparam name="T">The desired type.</typeparam>
            <param name="jObject">The <see cref="T:Newtonsoft.Json.Linq.JObject"/> instance.</param>
            <param name="propertyName">The property name.</param>
            <param name="value">Returns as the property value if present.</param>
            <returns><c>true</c> if the property was present and returned.</returns>
        </member>
        <member name="M:Neon.Common.NewtonsoftExtensions.CopyTo(Newtonsoft.Json.JsonSerializerSettings,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Copies the settings from one <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> instance to another.
            </summary>
            <param name="source">The source settings.</param>
            <param name="target">The target instance.</param>
        </member>
        <member name="T:Neon.Common.ProcessExtensions">
            <summary>
            <see cref="T:System.String"/> extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.ProcessExtensions.KillNow(System.Diagnostics.Process)">
            <summary>
            Signals the process to be killed and then waits for it to exit.
            Note that <see cref="M:System.Diagnostics.Process.Kill"/> only initiates process
            termination but that the process actually dies asynchronously,
            whereas the method actually waits for the process to terminate.
            </summary>
            <param name="process">The target process.</param>
        </member>
        <member name="T:Neon.Common.RandomExtensions">
            <summary>
            <see cref="T:System.Random"/> class extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.RandomExtensions.NextIndex(System.Random,System.Int32)">
            <summary>
            Returns a random index into a sequence whose length is specified.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance.</param>
            <param name="length">The sequence length.</param>
            <returns>The random index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if length is &lt;= 0.</exception>
        </member>
        <member name="M:Neon.Common.RandomExtensions.RandomTimespan(System.Random,System.TimeSpan)">
            <summary>
            Returns a random <see cref="T:System.TimeSpan"/> between zero and a specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance.</param>
            <param name="maxInterval">The maximum interval.</param>
            <returns>The random timespan.</returns>
            <remarks>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </remarks>
        </member>
        <member name="M:Neon.Common.RandomExtensions.RandomTimespan(System.Random,System.TimeSpan,System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> between the specified base interval
            plus a random period of the specified fraction of the value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance.</param>
            <param name="baseInterval">The base interval.</param>
            <param name="fraction">The fractional multiplier for the random component.</param>
            <returns>The random timespan.</returns>
            <remarks>
            <para>
            The value returned is at least as large as <paramref name="baseInterval" /> with an
            added random fractional interval if <paramref name="fraction" /> is positive or the value
            returned may be less than <paramref name="baseInterval" /> for a negative <paramref name="fraction" />.  
            This is computed via:
            </para>
            <code language="cs">
            baseInterval + RandTimespan(TimeSpan.FromSeconds(baseInterval.TotalSeconds * fraction));
            </code>
            <para>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Common.ReflectionExtensions">
            <summary>
            Reflection related extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.ReflectionExtensions.Implements``1(System.Type)">
            <summary>
            Determines whether a <see cref="T:System.Type"/> implements a specific interface.
            </summary>
            <typeparam name="TInterface">The required interface type.</typeparam>
            <param name="type">The type being tested.</param>
            <returns><c>true</c> if <paramref name="type"/> implements <paramref name="type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="type"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <typeparamref name="TInterface"/> is not an <c>interface</c>.</exception>
        </member>
        <member name="M:Neon.Common.ReflectionExtensions.Implements(System.Type,System.Type)">
            <summary>
            Determines whether a <see cref="T:System.Type"/> implements a specific interface.
            </summary>
            <param name="type">The type being tested.</param>
            <param name="interfaceType">The interface type.</param>
            <returns><c>true</c> if <paramref name="type"/> implements <paramref name="type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if either of <paramref name="type"/> or <paramref name="interfaceType"/> are <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="interfaceType"/> is not an <c>interface</c>.</exception>
        </member>
        <member name="M:Neon.Common.ReflectionExtensions.Is``1(System.Type)">
            <summary>
            Determines whether a type inherits from (or is) a specified base type.
            </summary>
            <typeparam name="T">Identifies the type we're matching.</typeparam>
            <param name="type">The type being tested.</param>
            <returns><c>true</c> if <paramref name="type"/> inherits or is <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Common.ReflectionExtensions.Is(System.Type,System.Type)">
            <summary>
            Determines whether a type inherits from (or is) a specified base type.
            </summary>
            <param name="type">The type being tested.</param>
            <param name="targetType">Identifies the type we're matching.</param>
            <returns><c>true</c> if <paramref name="type"/> inherits or is <paramref name="targetType"/>.</returns>
        </member>
        <member name="M:Neon.Common.ReflectionExtensions.Inherits``1(System.Type)">
            <summary>
            Determines whether a type inherits from another type.
            </summary>
            <typeparam name="TBase">The required base type.</typeparam>
            <param name="type">The type being tested.</param>
            <returns><c>true</c> if <paramref name="type"/> inherits <paramref name="type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="type"/> is <c>null</c>.</exception>
            <remarks>
            <note>
            This method also returns <c>true</c> when <typeparamref name="TBase"/> is the
            same as <paramref name="type"/>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.ReflectionExtensions.GetParameterTypes(System.Reflection.MethodInfo)">
            <summary>
            Returns the array of types for a method's parameters.
            </summary>
            <param name="method">The method.</param>
            <returns>The parameter type array.</returns>
        </member>
        <member name="T:Neon.Common.StringBuilderExtensions">
            <summary>
            System class extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.StringBuilderExtensions.AppendLineLinux(System.Text.StringBuilder,System.String)">
            <summary>
            Appends a line of text using a Linux-style (LF) line ending.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="line">The line.</param>
        </member>
        <member name="M:Neon.Common.StringBuilderExtensions.AppendWithSeparator(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Appends non-<c>null</c> and non-empty text, separating it from any existing text with a string.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="text">The text to be appended.</param>
            <param name="separator">The separator string, this defaults to a single space.</param>
            <remarks>
            <note>
            The separator string will not be appended if <paramref name="text"/> is <c>null</c>
            or empty.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.StringBuilderExtensions.ToStringWithoutLastNewLine(System.Text.StringBuilder)">
            <summary>
            Converts the <see cref="T:System.Text.StringBuilder"/> passed into a string without
            the last new line character sequence if there is one).
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/>.</param>
            <returns>The string builder as a string without the last new line.</returns>
        </member>
        <member name="T:Neon.Common.StringExtensions">
            <summary>
            <see cref="T:System.String"/> extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.StringExtensions.ToLines(System.String)">
            <summary>
            Splits the string into lines of text.
            </summary>
            <param name="value">The string value.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the extracted lines.  Note
            that an empty string will return a single empty line and a <c>null</c>
            string will return no lines.
            </returns>
        </member>
        <member name="M:Neon.Common.StringExtensions.GetHashCodeIgnoringWhitespace(System.String,System.Boolean)">
            <summary>
            Gets the hash code for a string, optionally ignoring case.
            </summary>
            <param name="obj"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="M:Neon.Common.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>
            Extension method for checking if a string is null or empty.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Neon.Common.StringExtensions.IsNullOrWhiteSpace(System.String)">
            <summary>
            Extension method for checking if a string is null or whitespace.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Neon.Common.TaskExtensions">
            <summary>
            <see cref="T:System.Threading.Tasks.Task"/> extension methods.
            </summary>
        </member>
        <member name="M:Neon.Common.TaskExtensions.WaitWithoutAggregate(System.Threading.Tasks.Task)">
            <summary>
            Waits for the task to complete but rethrows original exceptions rather
            than a wrapper <see cref="T:System.ArgumentException"/>.  Otherwise, this is 
            a replacement for <see cref="M:System.Threading.Tasks.Task.Wait"/>.
            </summary>
            <param name="task">The task</param>
        </member>
        <member name="M:Neon.Common.TaskExtensions.ResultWithoutAggregate``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Waits for the task to complete and then returns the result but rethrows 
            original exceptions rather than a wrapper <see cref="T:System.ArgumentException"/>.
            Otherwise, this is a replacement for <see cref="P:System.Threading.Tasks.Task`1.Result"/>.
            </summary>
            <typeparam name="TResult">The task result type.</typeparam>
            <param name="task">The task</param>
        </member>
        <member name="T:Neon.Common.TimeSpanExtensions">
            <summary>
            <see cref="T:System.TimeSpan"/> extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.TimeSpanExtensions.AdjustToFitDateRange(System.TimeSpan,System.DateTime)">
            <summary>
            Adjusts a <see cref="T:System.TimeSpan"/> such that when it is added to a 
            <see cref="T:System.DateTime"/> the resulting date is within the valid
            possible date range of <see cref="F:System.DateTime.MinValue"/>...<see cref="F:System.DateTime.MaxValue"/>.
            This is useful for timeout related calculations.
            </summary>
            <param name="timespan">The <see cref="T:System.TimeSpan"/>.</param>
            <param name="dateTime">The <see cref="T:System.DateTime"/>.</param>
            <returns>The adjusted <see cref="T:System.TimeSpan"/>.</returns>
        </member>
        <member name="M:Neon.Common.TimeSpanExtensions.RoundToSeconds(System.TimeSpan)">
            <summary>
            Rounds positive values up to the nearest second and negative
            values down to the nearest second.
            </summary>
            <param name="value">The input value.</param>
            <returns>The outpot value rounded to seconds.</returns>
        </member>
        <member name="T:Neon.Common.WeakEventController">
            <summary>
            Implements a weak event listener that allows the owner to be garbage
            collected if it is the only remaining link is an event handler.
            </summary>
            <remarks>
            <para>
            This class is intended to be a drop-in replacement for the <b>WeakEventManager</b> 
            class that is available in .NET 4.5 but is not currently present in the Xamarin
            Mono class libraries.  Use the <see cref="M:Neon.Common.WeakEventController.AddHandler``2(``0,System.String,System.EventHandler{``1})"/>
            and <see cref="M:Neon.Common.WeakEventController.RemoveHandler``2(``0,System.String,System.EventHandler{``1})"/>
            to add or remove event handlers.
            </para>
            <note>
            <b>Important:</b> Take care to remove any handlers when an event listener instance is disposed 
            and/or finalized.  Neglecting to do this will orhpan the objects <see cref="T:Neon.Common.WeakEventController"/>
            uses to track the handler references.
            </note>
            <para>
            This code was adapted from a Code Project article by <b>Samuel Cragg</b> called 
            <a href="www.codeproject.com/Articles/786606/WeakEventManager-for-WinRT">WeakEventManager for WinRT</a>.
            The code is licensed under the <a href="http://www.codeproject.com/info/cpol10.aspx">The Code Project Open License (CPOL)</a>.
            </para>
            <para>
            I enhanced the code by making it threadsafe.
            </para>
            </remarks>
        </member>
        <member name="F:Neon.Common.WeakEventController.registeredEventBuckets">
            <summary>
            We're going to assign events to buckets using the hash of their property
            values.  Each bucket will hold a list of the weak events that were dropped
            in the bucket.  This should improve scalability when there are a lot
            of events.
            </summary>
        </member>
        <member name="M:Neon.Common.WeakEventController.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.WeakEventController.HashToBucket(System.Object,System.String,System.Object)">
            <summary>
            Hashes the event properties to an event bucket index.
            </summary>
            <param name="source">The source object or <c>null</c>.</param>
            <param name="eventName">The event name.</param>
            <param name="handler">The event handler.</param>
            <returns>The event bucket index.</returns>
        </member>
        <member name="M:Neon.Common.WeakEventController.AddHandler``2(``0,System.String,System.EventHandler{``1})">
            <summary>
            Adds the specified event handler to the specified event.
            </summary>
            <typeparam name="TEventSource">The type that raises the event.</typeparam>
            <typeparam name="TEventArgs">The type that holds the event data.</typeparam>
            <param name="source">
            The source object that raises the specified event or <c>null</c>.
            </param>
            <param name="eventName">The name of the event to subscribe to.</param>
            <param name="handler">The delegate that handles the event.</param>
        </member>
        <member name="M:Neon.Common.WeakEventController.RemoveHandler``2(``0,System.String,System.EventHandler{``1})">
            <summary>
            Removes the specified event handler from the specified event.
            </summary>
            <typeparam name="TEventSource">The type that raises the event.</typeparam>
            <typeparam name="TEventArgs">The type that holds the event data.</typeparam>
            <param name="source">
            The source object that raises the specified event, or null if it's
            a static event.
            </param>
            <param name="eventName">
            The name of the event to remove the handler from.
            </param>
            <param name="handler">The delegate to remove.</param>
        </member>
        <member name="T:Neon.Common.YamlDotNetExtensions">
            <summary>
            YamlDotNet related class extensions.
            </summary>
        </member>
        <member name="M:Neon.Common.YamlDotNetExtensions.Load(YamlDotNet.RepresentationModel.YamlStream,System.String)">
            <summary>
            Initializes a <see cref="T:YamlDotNet.RepresentationModel.YamlStream"/> with text.
            </summary>
            <param name="stream">The YAML stream.</param>
            <param name="text">The text to be loaded.</param>
        </member>
        <member name="T:Neon.Common.CpuArchitecture">
            <summary>
            Enumerates the known CPU architectures.
            </summary>
        </member>
        <member name="F:Neon.Common.CpuArchitecture.unknown">
            <summary>
            The CPU architecture is not known.
            </summary>
        </member>
        <member name="F:Neon.Common.CpuArchitecture.amd32">
            <summary>
            32-bit AMD/Intel.
            </summary>
        </member>
        <member name="F:Neon.Common.CpuArchitecture.amd64">
            <summary>
            64-bit AMD/Intel.
            </summary>
        </member>
        <member name="F:Neon.Common.CpuArchitecture.arm32">
            <summary>
            32-bit ARM.
            </summary>
        </member>
        <member name="F:Neon.Common.CpuArchitecture.arm64">
            <summary>
            64-bit ARM.
            </summary>
        </member>
        <member name="T:Neon.Common.ExecuteException">
            <summary>
            Thrown by <see cref="M:Neon.Common.ExecuteResponse.EnsureSuccess(System.Boolean)"/> if the executed command
            did not return a <b>zero</b> exit code.
            </summary>
        </member>
        <member name="M:Neon.Common.ExecuteException.#ctor(Neon.Common.ExecuteResponse,System.String)">
            <summary>
            Constructs an instance from a <see cref="T:Neon.Common.ExecuteResponse"/>.
            </summary>
            <param name="response">The command response.</param>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Neon.Common.ExecuteException.#ctor(System.Int32,System.String,System.String,System.String)">
            <summary>
            Constructs an instance explictly passing the exit code and output streams.
            </summary>
            <param name="exitCode">The program exit code.</param>
            <param name="message">The error message.</param>
            <param name="outputText">Optionally specifies the program standard output text.</param>
            <param name="errorText">Optionally specifies the program standard error text.</param>
        </member>
        <member name="P:Neon.Common.ExecuteException.ExitCode">
            <summary>
            Returns the command exit code.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteException.OutputText">
            <summary>
            Returns the command standard output text.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteException.ErrorText">
            <summary>
            Returns the command standard error text.
            </summary>
        </member>
        <member name="T:Neon.Common.ExecuteResponse">
            <summary>
            Holds the process exit code and captured standard output from a process launched by any of the
            <see cref="M:Neon.Common.NeonHelper.ExecuteCapture(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Action{System.String},System.Action{System.String},System.IO.TextReader,System.Text.Encoding,System.Action{System.Diagnostics.Process})"/>
            related methods.
            </summary>
        </member>
        <member name="M:Neon.Common.ExecuteResponse.#ctor">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.ExecuteResponse.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Constuctor.
            </summary>
            <param name="exitCode">The exit code.</param>
            <param name="outputText">Optionally specifies the output text.</param>
            <param name="errorText">Optionally specifies the error text.</param>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.ExitCode">
            <summary>
            Returns the process exit code.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.Success">
            <summary>
            Returns <c>true</c> zero exit codes.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.OutputText">
            <summary>
            Returns the captured standard output stream text from the process.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.ErrorText">
            <summary>
            Returns the captured standard error stream text from the process.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.AllText">
            <summary>
            Returns the captured standard output and error stream text from the process.
            </summary>
        </member>
        <member name="M:Neon.Common.ExecuteResponse.EnsureSuccess(System.Boolean)">
            <summary>
            Ensure that the command returned a zero exit code.
            </summary>
            <param name="errorOnly">
            Optionally return only the text written to STDERR in the exception
            for errors when something besides whitespace was written to STDERR,
            otherwise include all text written to the output streams.
            </param>
            <returns>The response for fluent-style chaining.</returns>
            <exception cref="T:Neon.Common.ExecuteException">Thrown if the exit code isn't zero.</exception>
        </member>
        <member name="T:Neon.Common.NeonHelper">
            <summary>
            Provides global common utilities and state.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeflateString(System.String)">
            <summary>
            Uses deflate to commpress a string.
            </summary>
            <param name="input">The input string or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.InflateString(System.Byte[])">
            <summary>
            Uses deflate to decompress a string from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeflateBytes(System.Byte[])">
            <summary>
            Uses deflate to commpress a byte array.
            </summary>
            <param name="bytes">The input byte array or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.InflateBytes(System.Byte[])">
            <summary>
            Uses deflate to decompress a byte array from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsGzipped(System.String)">
            <summary>
            Examines a file to determine whether it has been compressed via GZIP.
            </summary>
            <param name="path">The file path.</param>
            <returns><c>true</c> if the file is compressed via GZIP.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsGzipped(System.IO.Stream)">
            <summary>
            Examines a <see cref="T:System.IO.Stream"/> to determine whether it has been compressed via GZIP.
            This assumes that the current position points to the GZIP header if there is one.
            The stream position will be restored before returning.
            </summary>
            <param name="stream">The stream.</param>
            <returns><c>true</c> if the file is compressed via GZIP.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GzipString(System.String)">
            <summary>
            Uses GZIP to commpress a string.
            </summary>
            <param name="input">The input string or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GunzipString(System.Byte[])">
            <summary>
            Uses GZIP to decompress a string from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GzipBytes(System.Byte[])">
            <summary>
            Uses GZIP to commpress a byte array.
            </summary>
            <param name="bytes">The input byte array or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GunzipBytes(System.Byte[])">
            <summary>
            Uses GZIP to decompress a byte array from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GzipFile(System.String,System.String)">
            <summary>
            Use GZIP to compress one file into another.
            </summary>
            <param name="sourcePath">Path to the (uncompressed) source file.</param>
            <param name="targetPath">Path to the (compressed) target file.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.GunzipFile(System.String,System.String)">
            <summary>
            Use GZIP to uncompress one file into another.
            </summary>
            <param name="sourcePath">Path to the (compressed) source file.</param>
            <param name="targetPath">Path to the (uncompressed) target file.</param>
        </member>
        <member name="F:Neon.Common.NeonHelper.NeonSdkProdRegistry">
            <summary>
            Identifies the production NeonSDK container image registry.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.NeonSdkDevRegistry">
            <summary>
            Identifies the development NeonSDK container image registry.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.NeonSdkBranchRegistry">
            <summary>
            Returns the appropriate public container NeonSDK registry to be used for the git 
            branch the assembly was built from.  This returns <see cref="F:Neon.Common.NeonHelper.NeonSdkProdRegistry"/> for
            release branches and <see cref="F:Neon.Common.NeonHelper.NeonSdkDevRegistry"/> for all other branches.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.syncRoot">
            <summary>
            Used for thread synchronization.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.CR">
            <summary>
            Ordinal value of an ASCII carriage return.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.LF">
            <summary>
            Ordinal value of an ASCII linefeed.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.HT">
            <summary>
            Ordinal value of an ASCII horizontal TAB.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.ESC">
            <summary>
            Ordinal value of an ASCII escape character.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.TAB">
            <summary>
            Ordinal value of an ASCII TAB character.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.CRLF">
            <summary>
            A string consisting of a CRLF sequence.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.LineEnding">
            <summary>
            Returns the native text line ending for the current environment.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.FileWildcards">
            <summary>
            Returns the characters used as wildcards for the current file system.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatTZ">
            <summary>
            Returns the date format string used for serialize dates with millisecond
            precision to strings like: <b>2018-06-05T14:30:13.000Z</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatSecondTZ">
            <summary>
            Returns the date format string used for serialize dates with second
            precision to strings like: <b>2018-06-05T14:30:13Z</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatTZOffset">
            <summary>
            Returns the date format string used for serialize dates with millisecond
            precision to strings like: <b>2018-06-05T14:30:13.000+00:00</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatMicroTZ">
            <summary>
            Returns the date format string used for serialize dates with microsecond
            precision to strings like: <b>2018-06-05T14:30:13.000000Z</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatMicroTZOffset">
            <summary>
            Returns the date format string used for serialize dates with microsecond
            precision to strings like: <b>2018-06-05T14:30:13.000000+00:00</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormat100NsTZ">
            <summary>
            Returns the date format string used for serialize dates with 100 nanosecond
            precision to strings like: <b>2018-06-05T14:30:13.000000Z</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormat100NsTZOffset">
            <summary>
            Returns the date format string used for serialize dates with 100 nanosecond
            precision to strings like: <b>2018-06-05T14:30:13.000000+00:00</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.UnixEpoch">
            <summary>
            Returns the Unix epoch time: 01-01-1970 (UTC).
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.NeonMetricsPrefix">
            <summary>
            Returns the prefix to be used for Neon related Prometheus names.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.NeonPublicBucketUri">
            <summary>
            The URI for the public AWS S3 bucket where we persist cluster VM images 
            and other things.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.NeonKubeOtelCollectorUri">
            <summary>
            The URI for Kubernetes <b>Services</b> deployed to namespaces for forwarding OTEL
            Collector log and trace information to the local Tempo installation or elsewhere.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.serviceContainer">
            <summary>
            The <see cref="T:Neon.Common.ServiceContainer"/> instance returned by 
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/>.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.specialUtf8EncodingProvider">
            <summary>
            Set to <c>true</c> when the special UTF-8 encoding provider with the misspelled
            name <b>utf8</b> (without the dash) has been initialized.  See 
            <see cref="M:Neon.Common.NeonHelper.RegisterMisspelledUtf8Provider"/> for more information.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.cachedNeonSdkFolder">
            <summary>
            Set to the user's NeonSDK folder.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.cachedNeonSdkUsbCodeSigningFolder">
            <summary>
            Set to the user's NeonSDK USB token code signing cache folder path.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.cachedNeonSdkAzureCodeSigningFolder">
            <summary>
            Set to the user's NeonSDK Azure code signing cache folder path.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.ServiceContainer">
            <summary>
            The root dependency injection service container used by Neon class libraries. 
            and applications.
            </summary>
            <remarks>
            <para>
            This instance implements both the <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and <see cref="T:System.IServiceProvider"/>
            interfaces and supports adding, removing, and locating services over the lifetime
            of the application.  This is more flexible than the default Microsoft injection
            pattern, where services are added to an <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> at startup
            and then a read-only snapshot is taken via a <b>BuildServiceProvider()</b> call
            that is used throughout the remaining application lifespan.
            </para>
            <para>
            This is implemented by a <see cref="T:Microsoft.Extensions.DependencyInjection.ServiceCollection"/> by default.  It is possible
            to replace this very early during application initialization but the default 
            implementation should suffice for most purposes.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.RegisterMisspelledUtf8Provider">
            <summary>
            Ensures that a special UTF-8 text encoding provider misnamed as <b>utf8</b>
            (without the dash) is registered.  This is required sometimes because
            certain REST APIs may return incorrect <b>charset</b> values.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.NeonSdkFolder">
            <summary>
            Returns the path to the folder used by NeonSDK to persist and cache state, creating
            the directory if it doesn't exist.  This folder is located at: <b>~/.neonsdk</b>
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.NeonSdkUsbCodeSigningFolder">
            <summary>
            Returns the path to the folder used by NeonSDK to cache download local USB token code signing code,
            creating the directory if it doesn't exist.  This folder is located at: <b>~/.neonsdk/codesigning-usb</b>
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.NeonSdkAzureCodeSigningFolder">
            <summary>
            Returns the path to the folder used by NeonSDK to cache download Azure code signing code,
            creating the directory if it doesn't exist.  This folder is located at: <b>~/.neonsdk/codesigning-azure</b>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.UnixEpochNanosecondsToDateTimeUtc(System.Int64)">
            <summary>
            Converts the number of nanoseconds from the Unix Epoch (1/1/1970 12:00:00am)
            into a UTC cref="DateTime"/> (UTC).
            </summary>
            <returns>The converted <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.UnixEpochMillisecondsToDateTimeUtc(System.Int64)">
            <summary>
            Converts the number of milliseconds from the Unix Epoch (1/1/1970 12:00:00am)
            into a UTC cref="DateTime"/> (UTC).
            </summary>
            <returns>The converted <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="P:Neon.Common.NeonHelper.DefaultUserHomeFolder">
            <summary>
            Returns the default user home.  This is not affected by calls to <see cref="M:Neon.Common.NeonHelper.SetUserHomeFolder(System.String)"/>.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.UserHomeFolder">
            <summary>
            Returns the path to the current user's HOME folder.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.SetUserHomeFolder(System.String)">
            <summary>
            Sets the appropriate variables for the operating system to
            change the current user's home folder to the specified path.
            </summary>
            <param name="folder">Specifies the new home folder.</param>
        </member>
        <member name="P:Neon.Common.NeonHelper.UserNeonDevFolder">
            <summary>
            <para>
            Returns the path to the development folder for NEONFORGE developers.  This folder
            is used to hold build and test related files and is named <b>.neondev</b> under
            the current user's home folder.
            </para>
            <para>Related: <see cref="P:Neon.Common.NeonHelper.UserNeonDevBuildFolder"/>, <see cref="P:Neon.Common.NeonHelper.UserNeonDevTestFolder"/></para>
            <note>
            This property ensures that the folder exists.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.UserNeonDevBuildFolder">
            <summary>
            <para>
            Returns the path to the development/build folder for NEONFORGE developers.  This folder
            is used to hold build related files and is named <b>.neondev/build</b> under
            the current user's home folder.
            </para>
            <note>
            This property ensures that the folder exists.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.UserNeonDevTestFolder">
            <summary>
            <para>
            Returns the path to the development/build folder for NEONFORGE developers.  This folder
            is used to hold unit test related files and is named <b>.neondev/test</b> under
            the current user's home folder.
            </para>
            <note>
            This property ensures that the folder exists.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.EscapeCsv(System.String)">
            <summary>
            Escapes a string passed so that is suitable for writing to
            a CSV file as a field.
            </summary>
            <param name="value">The field value.</param>
            <returns>The escaped string.</returns>
            <remarks>
            The method surrounds the value with double quotes if it contains
            a comma or CRLF as well as escaping any double quotes in the
            string with second double quote.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ParseCsv(System.String)">
            <summary>
            Parses a CSV encoded string into its component fields.
            </summary>
            <param name="value">The encoded CSV string.</param>
            <returns>The decoded fields.</returns>
            <exception cref="T:System.FormatException">Thrown if the CSV file format is not valid.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.StartDebugLogStopwatch(System.Boolean)">
            <summary>
            Creates and starts the debug log stopwatch when it's not already running.
            </summary>
            <param name="restart">Optionally restart the stopwatch.</param>
        </member>
        <member name="P:Neon.Common.NeonHelper.DebugLogPath">
            <summary>
            <para>
            The fully qualified path to the file where the simple <see cref="M:Neon.Common.NeonHelper.LogDebug(System.String)"/>
            method will write debug lines.  This defaults to <b>debug-log.txt</b> within the
            current user's home folder.
            </para>
            <para>
            You may change this to a different location.
            </para>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.ClearDebugLog">
            <summary>
            Clears the debug log file if it exists.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.LogDebug(System.String)">
            <summary>
            Appends a line of text to the file at <see cref="P:Neon.Common.NeonHelper.DebugLogPath"/>.  This is intended for
            low-level debugging when normal logging via <see cref="T:Neon.Diagnostics.TelemetryHub"/> isn't suitable (i.e.
            when debugging logging code or application initialization code running before normal 
            logging is configured.
            </summary>
            <param name="line">Optionally specifies the line of text.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.LogDebug(System.Exception)">
            <summary>
            Appends exception information to the file at <see cref="P:Neon.Common.NeonHelper.DebugLogPath"/>.  This is intended for
            low-level debugging when normal logging via <see cref="T:Neon.Diagnostics.TelemetryHub"/> isn't suitable.
            </summary>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToHex(System.Byte[],System.Boolean)">
            <summary>
            Converts the byte buffer passed into a hex encoded string.
            </summary>
            <param name="buf">The buffer</param>
            <param name="uppercase">Optionally renders the hex digits in uppercase.</param>
            <returns>The hex encoded string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.FromHex(System.String)">
            <summary>
            Parses the hex string passed and converts it a byte array.   
            </summary>
            <param name="s">The string to convert from hex.</param>
            <returns>The corresponding byte array.</returns>
            <exception cref="T:System.FormatException">Thrown if the input is not valid.</exception>
            <remarks>
            <note>
            The method ignores whitespace characters 
            (SP,CR,LF, and TAB) in the string so that HEX strings
            copied directly from typical hex dump outputs can
            be passed directly with minimal editing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseHex(System.String,System.Byte[]@)">
            <summary>
            Attempts to parse a hex string into a byte array.   
            </summary>
            <param name="s">The string to convert from hex.</param>
            <param name="output">Returns as the parsed byte array on success.</param>
            <returns><c>true</c> if the string was parsed successfully.</returns>
            <remarks>
            <note>
            The method ignores whitespace characters 
            (SP,CR,LF, and TAB) in the string so that HEX strings
            copied directly from typical hex dump outputs can
            be passed directly with minimal editing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsHex(System.Char)">
            <summary>
            Returns <c>true</c> if the character passed is a hex digit.
            </summary>
            <param name="ch">The character to test.</param>
            <returns><c>true</c> if the character is in one of the ranges: 0..9, a..f or A..F.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToHex(System.Byte,System.Boolean)">
            <summary>
            Converts a single byte into its hexidecimal equivalent.
            </summary>
            <param name="value">The input byte.</param>
            <param name="uppercase">Optionally return the hex value as uppercase.</param>
            <returns>The hex string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.HexValue(System.Char)">
            <summary>
            Returns the decimal value of the hex digit passed.
            </summary>
            <param name="ch">The hex digit.</param>
            <returns>The corresponding decimal value.</returns>
            <remarks>
            Throws a FormatException if the character is not a hex digit.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseHex(System.String,System.Int32@)">
            <summary>
            Attempts to parse a hex encoded string into an integer.
            </summary>
            <param name="input">The input string.</param>
            <param name="value">The parsed integer.</param>
            <returns><c>true</c> if the input could be parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,System.Int32,System.Int32,Neon.Common.HexDumpOption)">
            <summary>
            Returns a byte array as a formatted hex dump.
            </summary>
            <param name="data">The buffer to be dumped.</param>
            <param name="start">The first byte to be dumped.</param>
            <param name="count">The number of bytes to be dumped.</param>
            <param name="bytesPerLine">The number of bytes to dump per output line.</param>
            <param name="options">The formatting options.</param>
            <returns>The hex dump string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,Neon.Common.HexDumpOption)">
            <summary>
            Returns a byte array as a formatted hex dump.
            </summary>
            <param name="data">The buffer to be dumped.</param>
            <param name="bytesPerLine">The number of bytes to dump per output line.</param>
            <param name="options">The formatting options.</param>
            <returns>The hex dump string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ReadConsolePassword(System.String)">
            <summary>
            Reads a password from the <see cref="T:System.Console"/> terminated by <b>Enter</b>
            without echoing the typed characters.
            </summary>
            <param name="prompt">Optional prompt.</param>
            <returns>The password entered.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeleteFile(System.String)">
            <summary>
            Deletes a file if it exists.
            </summary>
            <param name="path">The target file.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeleteFolder(System.String)">
            <summary>
            Recursively deletes a file system folder, ignoring any errors.
            </summary>
            <param name="folder">The folder path.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeleteFolderContents(System.String)">
            <summary>
            Recursively deletes the contents of a file folder, ignoring any errors.
            </summary>
            <param name="folder">The folder path.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeleteFolder(System.String,System.Int32,System.Boolean)">
            <summary>
            <para>
            Recursively deletes a directory.  Note that this assumes that any files
            have already been deleted.
            </para>
            <note>
            This method intentially ignores any errors.
            </note>
            </summary>
            <param name="path">The directory path.</param>
            <param name="level">The nesting level (top == 0).</param>
            <param name="deleteTop">Optionally deletes the top directory.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.CopyFolder(System.String,System.String)">
            <summary>
            Recursively copies the files within one folder to another, creating
            target folders as required.
            </summary>
            <param name="sourceFolder">The source folder.</param>
            <param name="targetFolder">The target folder.</param>
            <remarks>
            <note>
            This method does not currently copy empty folders.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.OpenStandardInput">
            <summary>
            Opens the current process standard inout stream.
            </summary>
            <returns>The open <see cref="T:System.IO.Stream"/>.</returns>
            <remarks>
            <note>
            <para>
            This method integrates with <see cref="T:Neon.Common.ProgramRunner"/> such that
            program executions simulated by calls to <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.String,System.String[])"/>
            or <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.Byte[],System.String[])"/>
            can read the simulated input.
            </para>
            <para>
            Should generally call this instead of calling <see cref="M:System.Console.OpenStandardInput"/>
            directly.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ReadStandardInputText">
            <summary>
            Reads the <b>standard input</b> file to the end and returns the
            result as a string.
            </summary>
            <returns>The standard input.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ReadStandardInputBytes">
            <summary>
            Reads the <b>standard input</b> file to the end and returns the
            result as bytes.
            </summary>
            <returns>The standard input.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.FileWildcardRegex(System.String)">
            <summary>
            Generates a case insensitive <see cref="T:System.Text.RegularExpressions.Regex"/> equivalent to a standard file name wildcard
            pattern using <b>[*]</b> and <b>[?]</b> characters.
            </summary>
            <param name="pattern">The file name wildcard pattern.</param>
            <returns>The corresponding <see cref="T:System.Text.RegularExpressions.Regex"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.EncryptFile(System.String)">
            <summary>
            Encrypts a file or directory when supported by the underlying operating system
            and file system.  Currently, this only works on non-HOME versions of Windows
            and NTFS file systems.
            </summary>
            <param name="path">The file or directory path.</param>
            <returns><c>true</c> if the operation was successful.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DecryptFile(System.String)">
            <summary>
            Decrypts a file or directory when supported by the underlying operating system
            and file system.  Currently, this only works on non-HOME versions of Windows
            and NTFS file systems.
            </summary>
            <param name="path">The file or directory path.</param>
            <returns><c>true</c> if the operation was successful.</returns>
        </member>
        <member name="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings">
            <summary>
            The global <b>relaxed</b> JSON serializer settings.  These settings 
            <b>do not require</b> that all source JSON properties match those 
            defined by the type being deserialized.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings">
            <summary>
            The global <b>strict</b> JSON serializer settings.  These settings 
            <b>do require</b> that all source JSON properties match those defined 
            by the type being deserialized.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.JsonConverters">
            <summary>
            <para>
            Returns the list of <see cref="T:Newtonsoft.Json.JsonConverter"/> instances that will be automatically
            recognized by the JSON deserializers.  This is initialized with converters for some
            common types like <see cref="T:System.DateTime"/>, <see cref="T:System.TimeSpan"/>, and 
            <see cref="T:System.Version"/>.
            </para>
            <note>
            <b>IMPORTANT:</b> You may customize this list but for that to have any impact,
            you must make the modifications <b>very early</b> in your application startup sequence,
            <b>before any JSON serialization operations</b> have been performed.  Any changes
            made after this will be ignored.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.AddTypeConverters(Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Adds the standard type converters to serializer settings.
            </summary>
            <param name="settings">The target settings.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerialize(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to JSON text.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <returns>The JSON text.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerializeToBytes(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to UTF-8 encoded JSON bytes.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <returns>The UTF-8 encoded JSON bytes.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize``1(System.String,System.Boolean)">
            <summary>
            Deserializes JSON text, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="json">The JSON text.</param>
            <param name="strict">Optionally require that all input properties map to <typeparamref name="T"/> properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize``1(System.Byte[],System.Boolean)">
            <summary>
            Deserializes UITF-8 encoded JSON bytes, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="jsonBytes">The UTF-8 encoded JSON bytes.</param>
            <param name="strict">Optionally require that all input properties map to <typeparamref name="T"/> properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize(System.Type,System.String,System.Boolean)">
            <summary>
            Non-generic method that deserializes JSON text, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <param name="type">The target type.</param>
            <param name="json">The JSON text.</param>
            <param name="strict">Optionally require that all input properties map to <paramref name="type"/> properties.</param>
            <returns>The parsed <c>object</c>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize(System.Type,System.Byte[],System.Boolean)">
            <summary>
            Non-generic method that deserializes UTF-8 encoded JSON bytes, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <param name="type">The target type.</param>
            <param name="jsonBytes">The UTF-8 encoded JSON bytes.</param>
            <param name="strict">Optionally require that all input properties map to <paramref name="type"/> properties.</param>
            <returns>The parsed <c>object</c>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerialize(System.Object,Newtonsoft.Json.JsonSerializerSettings,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to JSON text using custom settings.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <param name="settings">The optional settings or <c>null</c> to use <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/>.</param>
            <returns>The JSON text.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerializeToBytes(System.Object,Newtonsoft.Json.JsonSerializerSettings,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to UTF-8 encoded JSON bytes using custom settings.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <param name="settings">The optional settings or <c>null</c> to use <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/>.</param>
            <returns>The ITF-8 encoded JSON bytes.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes JSON text using custom settings.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="json">The JSON text.</param>
            <param name="settings">The optional settings or <c>null</c> to use <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/>.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonClone``1(``0)">
            <summary>
            Creates a deep clone of an object by first serializing to JSON and then
            deserializing it.
            </summary>
            <typeparam name="T">The object type.</typeparam>
            <param name="value">The object being clonned or <c>null</c>.</param>
            <returns>The clone.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonEquals(System.Object,System.Object)">
            <summary>
            Compares two object instances for equality by serializing them JSON and
            comparing the output.
            </summary>
            <param name="v1">Value 1</param>
            <param name="v2">Value 2</param>
            <returns><c>true</c> if the instances are the same.</returns>
            <remarks>
            This is a convienent and safe way of comparing two objects without having
            to comparing a potentially complex tree of members and then maintaining
            that as code changes over time at the cost of having to perform the
            serializations.
            </remarks>
        </member>
        <member name="F:Neon.Common.NeonHelper.EnumMemberSerializationInfo.EnumToStrings">
            <summary>
            Maps serialized enum [EnumMember] strings to their ordinal values.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.EnumMemberSerializationInfo.EnumToOrdinals">
            <summary>
            Maps enum ordinal values to their [EnumMember] string.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.TestModeFolderVar">
            <summary>
            The environment variable used for unit testing that indicates
            that <c>Neon.Service.NeonService</c> should run in test mode and 
            locate user test files in the folder specified by this variable
            (when set).
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsOdd(System.Int32)">
            <summary>
            Determines whether an integer is odd.
            </summary>
            <param name="value">The value.</param>
            <returns><c>true</c> if the value is odd.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.NullableEquals``1(System.Nullable{``0},System.Nullable{``0})">
            <summary>
            Determines whether two nullable values are equal.
            </summary>
            <typeparam name="T">The base value type.</typeparam>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <returns><c>true</c> if the values are equal.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToLinuxLineEndings(System.String)">
            <summary>
            Converts Windows line endings (CR-LF) to Linux/Unix line endings (LF).
            </summary>
            <param name="input">The input string or <c>null</c>.</param>
            <returns>The input string with converted line endings.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExceptionError(System.Exception,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Returns a string representation of an exception suitable for logging.
            </summary>
            <param name="e">The exception.</param>
            <param name="stackTrace">Optionally include the stack track.</param>
            <param name="excludeInner">Optionally exclude information about any inner exception.</param>
            <param name="depth"><b>INTERNAL USE ONLY:</b> Used to prevent infinite recursion when inner exceptions cycle.</param>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.StartThread(System.Action,System.Int32)">
            <summary>
            Starts a new <see cref="T:System.Threading.Thread"/> to perform an action.
            </summary>
            <param name="action">The action to be performed.</param>
            <param name="maxStackSize">
            <para>
            Optionally specifies the maximum stack size, in bytes, to be used by the thread, or 
            0 to use the default maximum stack size specified in the header for the executable.
            Important for partially trusted code, <paramref name="maxStackSize"/> is ignored if 
            it is greater than the default stack size.  No exception is thrown in theis case.
            </para>
            <para>
            This <b>defaults to 0</b> which generally means the stack size will be limited
            to <b>1 MiB for 32-bit</b> applications or <b>4 MiB for 64-bit</b> applications.
            </para>
            </param>
            <returns>The <see cref="T:System.Threading.Thread"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.StartThread(System.Action{System.Object},System.Object,System.Int32)">
            <summary>
            Starts a new <see cref="T:System.Threading.Thread"/> to perform a parameterized action with
            an object parameter.
            </summary>
            <param name="action">The action to be performed.</param>
            <param name="parameter">The parameter to be passed to the thread action.</param>
            <param name="maxStackSize">
            <para>
            Optionally specifies the maximum stack size, in bytes, to be used by the thread, or 
            0 to use the default maximum stack size specified in the header for the executable.
            Important for partially trusted code, <paramref name="maxStackSize"/> is ignored if 
            it is greater than the default stack size.  No exception is thrown in theis case.
            </para>
            <para>
            This <b>defaults to 0</b> which generally means the stack size will be limited
            to <b>1 MiB for 32-bit</b> applications or <b>4 MiB for 64-bit</b> applications.
            </para>
            </param>
            <returns>The <see cref="T:System.Threading.Thread"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.StartTypedThread``1(System.Action{``0},``0,System.Int32)">
            <summary>
            Starts a new <see cref="T:System.Threading.Thread"/> to perform a parameterized action with
            a typed parameter.
            </summary>
            <typeparam name="TParam">Identifies the type of the thread action parameter.</typeparam>
            <param name="action">The action to be performed.</param>
            <param name="parameter">The parameter to be passed to the thread action.</param>
            <param name="maxStackSize">
            <para>
            Optionally specifies the maximum stack size, in bytes, to be used by the thread, or 
            0 to use the default maximum stack size specified in the header for the executable.
            Important for partially trusted code, <paramref name="maxStackSize"/> is ignored if 
            it is greater than the default stack size.  No exception is thrown in theis case.
            </para>
            <para>
            This <b>defaults to 0</b> which generally means the stack size will be limited
            to <b>1 MiB for 32-bit</b> applications or <b>4 MiB for 64-bit</b> applications.
            </para>
            </param>
            <returns>The <see cref="T:System.Threading.Thread"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DoesNotThrow(System.Action)">
            <summary>
            Verfies that an action does not throw an exception.
            </summary>
            <param name="action">The action.</param>
            <returns><c>true</c> if no exception was thrown.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DoesNotThrow``1(System.Action)">
            <summary>
            Verfies that an action does not throw a <typeparamref name="TException"/>.
            </summary>
            <param name="action">The action.</param>
            <typeparam name="TException">The exception type.</typeparam>
            <returns><c>true</c> if no exception was thrown.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExpandTabs(System.String,System.Int32)">
            <summary>
            Expands any embedded TAB <b>(\t)</b> characters in the string passed
            into spaces such that the tab stops will be formatted correctly.
            </summary>
            <param name="input">The input string.</param>
            <param name="tabStop">
            Optionally expands TABs into spaces when greater than zero or converts 
            a series of leading spaces into tabs if less than zero.  This defaults
            to <b>4</b>.
            </param>
            <returns>The expanded string.</returns>
            <remarks>
            <note>
            If the string passed includes line ending characters (CR or LF) then 
            the output will include line endings for every line, including the
            last one.
            </note>
            <para>
            A positive <paramref name="tabStop"/> does what you'd expect by converting
            spaces in the string into TABs such that the tab stops align to the value
            passed.  This works a bit differently for negative values.
            </para>
            <para>
            A negative <paramref name="tabStop"/> indicates that leading spaces in each
            line will be converted into TABs.  A value of -1 indicates that each leading
            two spaces will bve converted into a TAB, a value of -2 indicates that each
            leading 2 spaces will be converted into a TAB, and so on.
            </para>
            <para>
            Conversion to TABs will cease when the first non space is ecountered and
            any odd number of spaces remaining will be included in the output.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitFor(System.Func{System.Boolean},System.TimeSpan,System.Nullable{System.TimeSpan},System.String,System.Threading.CancellationToken)">
            <summary>
            Waits for a boolean function to return <c>true</c>.
            </summary>
            <param name="predicate">The boolean predicate.</param>
            <param name="timeout">Optionally specifies the maximum time to wait.</param>
            <param name="pollInterval">Optionally specifies time to wait between each predicate call or <c>null</c> for a reasonable default.</param>
            <param name="timeoutMessage">Optionally overrides the <see cref="T:System.TimeoutException"/> message.</param>
            <param name="cancellationToken">Optionally specifies a cancellation token.</param>
            <exception cref="T:System.TimeoutException">Thrown if the never returned <c>true</c> before the timeout.</exception>
            <remarks>
            This method periodically calls <paramref name="predicate"/> until it returns
            <c>true</c> or the timeout is exceeded.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitForAsync(System.Func{System.Threading.Tasks.Task{System.Boolean}},System.TimeSpan,System.Nullable{System.TimeSpan},System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for a boolean function to return <c>true</c>.
            </summary>
            <param name="predicate">The boolean predicate.</param>
            <param name="timeout">Optionally specifies the maximum time to wait.</param>
            <param name="pollInterval">Optionally specifies time to wait between each predicate call or <c>null</c> for a reasonable default.</param>
            <param name="timeoutMessage">Optionally overrides the <see cref="T:System.TimeoutException"/> message.</param>
            <param name="cancellationToken">Optionally specifies a <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the never returned <c>true</c> before the timeout.</exception>
            <remarks>
            This method periodically calls <paramref name="predicate"/> until it returns
            <c>true</c> or the timeout is exceeded.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Compares two <c>null</c> or non-<c>null</c> enumerable sequences for equality.
            </summary>
            <typeparam name="T">The enumerable item type.</typeparam>
            <param name="sequence1">The first list or <c>null</c>.</param>
            <param name="sequence2">The second list or <c>null</c>.</param>
            <returns><c>true</c> if the sequences have matching elements.</returns>
            <remarks>
            <note>
            This method is capable of comparing <c>null</c> arguments and also
            uses <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to compare individual 
            elements.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.SequenceEqual``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Compares two <c>null</c> or non-<c>null</c> lists for equality.
            </summary>
            <typeparam name="T">The enumerable item type.</typeparam>
            <param name="list1">The first list or <c>null</c>.</param>
            <param name="list2">The second list or <c>null</c>.</param>
            <returns><c>true</c> if the sequences have matching elements.</returns>
            <remarks>
            <note>
            This method is capable of comparing <c>null</c> arguments and also
            uses <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to compare 
            individual elements.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitAllAsync(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            Asynchronously waits for all of the <see cref="T:System.Threading.Tasks.Task"/>s passed to complete.
            </summary>
            <param name="tasks">The tasks to wait on.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitAllAsync(System.Threading.Tasks.Task[])">
            <summary>
            Asynchronously waits for all of the <see cref="T:System.Threading.Tasks.Task"/>s passed to complete.
            </summary>
            <param name="tasks">The tasks to wait on.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.Thread})">
            <summary>
            Waits for all of the threads passed to complete.  This method does nothing
            when <paramref name="threads"/> is <c>null</c> or empty.  Also and <c>null</c>
            threads passed will be ignored.
            </summary>
            <param name="threads">The threads being waited on.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitAllAsync(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task},System.Nullable{System.TimeSpan},System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for all of the <see cref="T:System.Threading.Tasks.Task"/>s passed to complete.
            </summary>
            <param name="tasks">Specifies the tasks being waited on.</param>
            <param name="timeout">Optionally specifies a timeout.</param>
            <param name="cancellationToken">Optionally a cancellation token.</param>
            <param name="timeoutMessage">
            Optionally specifies a message to be included in any <see cref="T:System.TimeoutException"/>
            thrown to help the what failed.
            </param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the <paramref name="timeout"/> was exceeded.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.JTokenEquals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Compares the two Newtonsoft JSON.NET <see cref="T:Newtonsoft.Json.Linq.JToken"/> instances along
            with their decendants for equality.  This is an alternative to <see cref="P:Newtonsoft.Json.Linq.JToken.EqualityComparer"/> 
            which seems to have some problems, as outlined in the remarks.
            </summary>
            <param name="token1">The first token.</param>
            <param name="token2">The second token.</param>
            <returns><c>true</c> if the tokens are to be considered as equal.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.StripFileScheme(System.String)">
            <summary>
            Removes a <b>file://</b> scheme from the path URI if this is scheme
            is present.  The result will be a valid file system path.
            </summary>
            <param name="path">The path/URI to be converted.</param>
            <returns>The file system path.</returns>
            <remarks>
            <note>
            <para>
            This method behaves slightly differently when running on Windows and
            when running on Unix/Linux.  On Windows, file URIs are absolute file
            paths of the form:
            </para>
            <code language="none">
            FILE:///C:/myfolder/myfile
            </code>
            <para>
            To convert this into a valid file system path this method strips the
            <b>file://</b> scheme <i>and</i> the following forward slash.  On
            Unix/Linux, file URIs will have the form:
            </para>
            <code language="none">
            FILE:///myfolder/myfile
            </code>
            <para>
            In this case, the forward shlash following the <b>file://</b> scheme
            is part of the file system path and will not be removed.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ArrayEquals(System.Byte[],System.Byte[])">
            <summary>
            Determines whether two byte arrays contain the same values in the same order.
            </summary>
            <param name="v1">Byte array #1.</param>
            <param name="v2">Byte array #2.</param>
            <returns><c>true</c> if the arrays are equal.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEnumMembers``1">
            <summary>
            Returns the serialization information for an enumeration type.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEnumMembers(System.Type)">
            <summary>
            Returns the serialization information for an enumeration type.
            </summary>
            <param name="type">The enumeration type.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.ParseEnum``1(System.String,System.Nullable{``0})">
            <summary>
            Type-safe <c>enum</c> parser that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.  This is case insensitive.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="input">The input string.</param>
            <param name="defaultValue">
            Optionally specifies the value to be returned if the input cannot
            be parsed instead of throwing an exception.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="input"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="input"/> is not valid.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParse``1(System.String,``0@)">
            <summary>
            Type-safe <c>enum</c> parser that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.  This is case insensitive.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="input">The input string.</param>
            <param name="output">Returns as the parsed value.</param>
            <returns><c>true</c> if the value was parsed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseEnum(System.Type,System.String,System.Object@)">
            <summary>
            <c>enum</c> parser that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.  This is case insensitive.
            </summary>
            <param name="type">The enumeration type.</param>
            <param name="input">The input string.</param>
            <param name="output">Returns as the parsed value.</param>
            <returns><c>true</c> if the value was parsed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseEnum``1(System.String,``0@)">
            <summary>
            <c>enum</c> parser that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.  This is case insensitive.
            </summary>
            <typeparam name="TEnum">Specifies the enumeration type.</typeparam>
            <param name="input">The input string.</param>
            <param name="output">Returns as the parsed value.</param>
            <returns><c>true</c> if the value was parsed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.EnumToString``1(``0)">
            <summary>
            Type-safe <c>enum</c> serializer that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="input">The input value.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.EnumToString(System.Type,System.Object)">
            <summary>
            Type-safe <c>enum</c> serializer that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.
            </summary>
            <param name="type">The enumeration type.</param>
            <param name="input">The input value.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEnumNames``1">
            <summary>
            Returns the value names for an enumeration type.  This is similar to <see cref="M:System.Enum.GetNames(System.Type)"/>
            but also honors value names customized via <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>.
            </summary>
            <returns>The array of value names.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.UrlTokenEncode(System.Byte[])">
            <summary>
            Encodes a byte array into a form suitable for using as a URI path
            segment or query parameter.
            </summary>
            <param name="input">The byte array.</param>
            <returns>The encoded string.</returns>
            <exception cref="T:System.NullReferenceException">Thrown if <paramref name="input"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.UrlTokenDecode(System.String)">
            <summary>
            Decodes a string encoded by <see cref="M:Neon.Common.NeonHelper.UrlTokenEncode(System.Byte[])"/> back
            into a byte array.
            </summary>
            <param name="input">The input string.</param>
            <returns>The decoded bytes.</returns>
            <exception cref="T:System.NullReferenceException">Thrown if <paramref name="input"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.Base64UrlEncode(System.Byte[],System.Boolean)">
            <summary>
            Encodes a byte array using <b>Base64Url</b> encoding as specifed here: <a href="">RFC 4648</a>
            </summary>
            <param name="bytes">The input byte array.</param>
            <param name="retainPadding">
            Optionally onverts any '=' characters padding into escaped "%3D", otherwise
            any padding will be omitted from the output.
            </param>
            <returns>The Base64Url encoded string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.Base64UrlDecode(System.String)">
            <summary>
            Decodes a base64url encoded string.  This is a URL and filename safe base-64 based 
            encoding scheme: <a href="https://tools.ietf.org/html/rfc4648#section-5">RFC6448</a>.
            </summary>
            <param name="encoded">The encoded string.</param>
            <returns>The decoded bytes.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToBase64(System.String,System.Text.Encoding)">
            <summary>
            Converts the string passed into base64 string.
            </summary>
            <param name="value">The plaintext string to be encoded (cannot be <c>null</c>).</param>
            <param name="encoding">
            Optionally specifies the encoding to use to convert the input to bytes 
            before base64 encoding it.  This defaults to <see cref="P:System.Text.Encoding.UTF8"/>.
            </param>
            <returns>The converted base-64 string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.FromBase64(System.String,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="encodedValue">The base64 encoded input.</param>
            <param name="encoding">
            Optionally specifies the encoding to use to convert the decoded bytes 
            to the result.  This defaults to <see cref="P:System.Text.Encoding.UTF8"/>.
            </param>
            <returns>The converted string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetApplicationFolder">
            <summary>
            Returns the fully qualified path to the folder where the current executable 
            resides.  This includes a terminating "\".
            </summary>
            <returns>Path to the folder holding the executable</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetAssemblyFolder(System.Reflection.Assembly)">
            <summary>
            Returns the fully qualified path to the folder holding the
            assembly passed (includes the terminating "\").
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>Path to the folder holding the assembly.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetAssemblyPath(System.Reflection.Assembly)">
            <summary>
            Returns the fully qualified path to the assembly file.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The assembly's path.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEntryAssemblyPath">
            <summary>
            Returns the fully qualified path the entry assembly for the current process.
            </summary>
            <returns>The entry assembly file path.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonOrYamlDeserialize``1(System.String,System.Boolean)">
            <summary>
            Deserializes JSON or YAML text using, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="input">The input text (JSON or YAML).</param>
            <param name="strict">Optionally require that all input properties map to <typeparamref name="T"/> properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            <note>
            This method works by looking for leading '{' or '[' as the first non-whitespace character
            in the string to detect whether the input is JSON.  The method assumes YAML otherwise.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseBool(System.String,System.Boolean@)">
            <summary>
            Attempts to parse a boolean from common literals.
            </summary>
            <param name="input">The input string being parsed.</param>
            <param name="value">Returns as the parsed value on success.</param>
            <returns><c>true</c> on success.</returns>
            <remarks>
            <para>
            This method recognizes the following case insensitive literals:
            </para>
            <list type="table">
            <item>
            <term><c>false</c></term>
            <description>
            <para><b>0</b></para>
            <para><b>off</b></para>
            <para><b>no</b></para>
            <para><b>disabled</b></para>
            <para><b>false</b></para>
            </description>
            </item>
            <item>
            <term><c>true</c></term>
            <description>
            <para><b>1</b></para>
            <para><b>on</b></para>
            <para><b>yes</b></para>
            <para><b>enabled</b></para>
            <para><b>true</b></para>
            </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ParseBool(System.String)">
            <summary>
            Parses common boolean literals.
            </summary>
            <param name="input">The input string being parsed.</param>
            <returns>The parsed output.</returns>
            <exception cref="T:System.FormatException">Thrown if the value is not valid.</exception>
            <remarks>
            <para>
            This method recognizes the following case insensitive literals:
            </para>
            <list type="table">
            <item>
            <term><c>false</c></term>
            <description>
            <para><b>0</b></para>
            <para><b>off</b></para>
            <para><b>no</b></para>
            <para><b>disabled</b></para>
            <para><b>false</b></para>
            </description>
            </item>
            <item>
            <term><c>true</c></term>
            <description>
            <para><b>1</b></para>
            <para><b>on</b></para>
            <para><b>yes</b></para>
            <para><b>enabled</b></para>
            <para><b>true</b></para>
            </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ParseNullableBool(System.String)">
            <summary>
            Parses a nullable <see cref="T:System.Boolean"/>.
            </summary>
            <param name="input">
            The input string being parsed.  <c>null</c>, empty or <paramref name="input"/> == <b>"null"</b> 
            will return <c>null</c>.  Otherwise we'll expect either <b>"true"</b> or <b>"false"</b> or
            one of the other literals supported by <see cref="M:Neon.Common.NeonHelper.ParseBool(System.String)"/>.
            </param>
            <note>
            This method is case insensitive.
            </note>
            <returns><c>true</c>, <c>false</c>, or <c>null</c>.</returns>
            <exception cref="T:System.FormatException">Thrown for invalid input strings.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseNullableBool(System.String,System.Nullable{System.Boolean}@)">
            <summary>
            Attempts to parse a nullable <see cref="T:System.Boolean"/>.  <c>null</c>, empty or <paramref name="input"/> == <b>"null"</b> 
            will return <c>null</c>.  Otherwise we'll expect either <b>"true"</b> or <b>"false"</b> or
            one of the other literals supported by <see cref="M:Neon.Common.NeonHelper.ParseBool(System.String)"/>.
            </summary>
            <param name="input">The input string being parsed.</param>
            <param name="value">Returns as the parsed value.</param>
            <returns><c>true</c> if the input was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.StripAnsibleWarnings(System.String)">
            <summary>
            <b>HACK:</b> This method attempts to trim warnings generated by Ansible because
            it writes these warnings to STDOUT instead of STDERR.  This is super fragile.
            </summary>
            <param name="text">The text to be adjusted.</param>
            <returns>The adjusted text.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToBoolString(System.Boolean)">
            <summary>
            Renders a <c>bool</c> value as either <b>true</b> or <b>false</b>
            (lowercase).
            </summary>
            <param name="value">The value.</param>
            <returns><b>true</b> or <b>false</b>,</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.NoAwait(System.Threading.Tasks.Task)">
            <summary>
            Do nothing method that is used when you explicitly don't want to
            <c>await</c> a task and you don't want to see warning <b>CS4014</b>.
            </summary>
            <param name="task">The task.</param>
        </member>
        <member name="P:Neon.Common.NeonHelper.OpenEditorHandler">
            <summary>
            Used for implementing unit tests against the <see cref="M:Neon.Common.NeonHelper.OpenEditor(System.String)"/>
            method.  <see cref="M:Neon.Common.NeonHelper.OpenEditor(System.String)"/> will call this action when it's
            non-null passing the file path, rather than actually opening the file in
            an editor.  The handler can then simulate editing the file.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.OpenEditor(System.String)">
            <summary>
            Launches the platform text editor to create or edit a file.
            </summary>
            <param name="path">The file path.</param>
            <remarks>
            <para>
            This method will launch the editor specified in the <b>EDITOR</b>
            environment variable otherwise it will launch NotePad on Windows
            and Vim on Linux and OS/X.  <b>EDITOR</b> should be set to the
            command line used to launch the editor with special <b>$FILE</b> 
            parameter.  This will be replaced with the path to the file being 
            edited.
            </para>
            <note>
            We'll simply append the file path if <b>$FILE</b> isn't found in
            the <b>EDITOR</b> environment variable.
            </note>
            <para>
            This method will block until the editor is closed.
            </para>
            <note>
            For unit testing, you may set <see cref="P:Neon.Common.NeonHelper.OpenEditorHandler"/> to
            an action that will simulate editing the file.  This action will
            be called instead of actually opening an editor when set.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.PackageReferenceToNeonCommonIsRequired">
            <summary>
            <para>
            This method may be called to ensure that the <b>Neon.Common</b> assembly
            is required at compile in a project that doesn't reference <b>Neon.Common</b>.
            The method does nothing.
            </para>
            <note>
            A call to this is currently included by <b>Neon.ModelGen</b> to ensure that
            the enclosing project references <b>Neon.Common</b>.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetMethod(System.Type,System.String,System.Type[])">
            <summary>
            Uses reflection to locate a specific public, non-public, instance or static method on a type.
            </summary>
            <param name="type">The target type.</param>
            <param name="name">The method name.</param>
            <param name="parameterTypes">The parameter types.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/>.</returns>
            <exception cref="T:System.MissingMethodException">Thrown if the method does not exist.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetConstructor(System.Type,System.Type[])">
            <summary>
            Uses reflection to locate a specific public or non-public constructor for a type.
            </summary>
            <param name="type">The target type.</param>
            <param name="parameterTypes">The parameter types.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/>.</returns>
            <exception cref="T:System.MissingMethodException">Thrown if the method does not exist.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetTaskResultAsObjectAsync(System.Threading.Tasks.Task)">
            <summary>
            Used to await a generic <see cref="T:System.Threading.Tasks.Task`1"/> and return its result as
            an <see cref="T:System.Object"/>.  This is handy for situations where the task
            result type is unknown at compile time.
            </summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task`1"/>.</param>
            <returns>The task result.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEnhancedJsonConverters">
            <summary>
            Returns instances of the types that implement <see cref="T:Neon.Data.IEnhancedJsonConverter"/> from the
            <b>Neon.Common</b> assembly.
            </summary>
            <returns>The list of converters.</returns>
        </member>
        <member name="P:Neon.Common.NeonHelper.DockerCli">
            <summary>
            Returns the name of the Docker CLI execuable for the current platform.  This will
            be the fully qualified path to <b>docker.exe</b> on Windows and just <b>docker</b>
            on Linux and OS/X.
            </summary>
            <returns>The path to the Docker CLI or <c>null</c> when it couldn't be located.</returns>
        </member>
        <member name="P:Neon.Common.NeonHelper.VerifiedDockerCli">
            <summary>
            Returns the path to the Docker CLI on the current machine or throws
            an exception when the CLI cannot be located.
            </summary>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when the Docker CLI could not be located.</exception>
        </member>
        <member name="P:Neon.Common.NeonHelper.DockerComposeCli">
            <summary>
            Returns the name of the Docker Compose CLI execuable for the current platform.  This will
            be <b>docker-compose.exe</b> on Windows and just <b>docker-compose</b> on Linux and OS/x.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsWithin(System.DateTime,System.DateTime,System.TimeSpan)">
            <summary>
            Determines whether a <paramref name="value"/> is within <paramref name="expected"/> - <paramref name="maxDelta"/>
            and <paramref name="value"/> + <paramref name="maxDelta"/> inclusive.  This is useful for unit tests 
            where there might be an minor allowable variance due to clock skew, etc.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="value">The value being tested.</param>
            <param name="maxDelta">The allowed variance.</param>
            <returns><c>true</c> when the two datetime values are within <paramref name="maxDelta"/> of each other.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsWithin(System.DateTimeOffset,System.DateTimeOffset,System.TimeSpan)">
            <summary>
            Determines whether a <paramref name="value"/> is within <paramref name="expected"/> - <paramref name="maxDelta"/>
            and <paramref name="value"/> + <paramref name="maxDelta"/> inclusive.  This is useful for unit tests 
            where there might be an minor allowable variance due to clock skew, etc.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="value">The value being tested.</param>
            <param name="maxDelta">The allowed variance.</param>
            <returns><c>true</c> when the two datetime values are within <paramref name="maxDelta"/> of each other.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.CastTo``1(System.Object)">
            <summary>
            Attempts to cast an object into a specific type.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="value">The value to be cast.</param>
            <returns>The casted result.</returns>
            <exception cref="T:System.InvalidCastException">Thrown if the value could not be cast into the type.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.PartitionCount(System.Int32,System.Int32)">
            <summary>
            Computes the <see cref="T:System.Int32"/> number of partitions that would be required to divide a
            set of items where the number of items in each partition is limited.
            </summary>
            <param name="itemCount">The number of items to be partitioned.</param>
            <param name="partitionSize">The maximim number of items in any partition.</param>
            <returns>The number of partitions required.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PartitionCount(System.UInt32,System.UInt32)">
            <summary>
            Computes the <see cref="T:System.UInt32"/> number of partitions that would be required to divide a
            set of items where the number of items in each partition is limited.
            </summary>
            <param name="itemCount">The number of items to be partitioned.</param>
            <param name="partitionSize">The maximim number of items in any partition.</param>
            <returns>The number of partitions required.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PartitionCount(System.Int64,System.Int64)">
            <summary>
            Computes the <see cref="T:System.Int64"/> number of partitions that would be required to divide a
            set of items where the number of items in each partition is limited.
            </summary>
            <param name="itemCount">The number of items to be partitioned.</param>
            <param name="partitionSize">The maximim number of items in any partition.</param>
            <returns>The number of partitions required.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PartitionCount(System.UInt64,System.UInt64)">
            <summary>
            Computes the <see cref="T:System.UInt64"/> number of partitions that would be required to divide a
            set of items where the number of items in each partition is limited.
            </summary>
            <param name="itemCount">The number of items to be partitioned.</param>
            <param name="partitionSize">The maximim number of items in any partition.</param>
            <returns>The number of partitions required.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.Min(System.TimeSpan[])">
            <summary>
            Determines the minimum <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="values">The values to compare.</param>
            <returns>The minimum of the values passed or <see cref="F:System.TimeSpan.Zero"/> when nothing is passed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.Max(System.TimeSpan[])">
            <summary>
            Determines the maximum <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="values">The values to compare.</param>
            <returns>The minimum of the values passed or <see cref="F:System.TimeSpan.Zero"/> when nothing is passed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DetectOS">
            <summary>
            Detects the current operating system.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.OSDescription">
            <summary>
            Returns the operation system description.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.Is32BitOS">
            <summary>
            Returns <c>true</c> for 32-bit operating systems.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.Is64BitOS">
            <summary>
            Returns <c>true</c> for 64-bit operating systems.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.CpuArchitecture">
            <summary>
            Returns the current CPU architecture.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.MemoryMib">
            <summary>
            <para>
            Returns the system RAM in MiB.
            </para>
            <note>
            For applications running in containers, this will return information about
            the RAM available to the container, not the host system RAM.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.FrameworkDescription">
            <summary>
            Returns the .NET runtime description.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.Framework">
            <summary>
            Identifies the .NET runtime hosting the current process.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.FrameworkVersion">
            <summary>
            Returns the current .NET runtime version hosting the current process.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.Is64BitBuild">
            <summary>
            Returns <c>true</c> if the application was built as 64-bit.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.Is32BitBuild">
            <summary>
            Returns <c>true</c> if the client was built as 32-bit.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsDevWorkstation">
            <summary>
            Indicates whether the current application is running on a developer workstation.
            This is determined by the presence of the <b>DEV_WORKSTATION</b> environment variable.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsMaintainer">
            <summary>
            Indicates whether the current user is a NEONFORGE maintainer.  This is determined by the
            presence of the <b>NF_MAINTAINER</b> environment variable.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsWindows">
            <summary>
            Returns <c>true</c> if the current process is running on a Windows variant
            operating system.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.EnsureWindows">
            <summary>
            Ensures that the Windows is the current operating system.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.WindowsEdition">
            <summary>
            Identifies the current Windows edition (home, pro, server,...).
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when not running on Windows.</exception>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsLinux">
            <summary>
            Returns <c>true</c> if the current process is running on a Linux variant
            operating system.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsOSX">
            <summary>
            Returns <c>true</c> if the current process is running on Mac OSX.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsARM">
            <summary>
            Returns <c>true</c> if the current process is runniong on an ARM processor.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsCI">
            <summary>
            Returns <c>true</c> if the current process is running within a CI environment
            such as GitHub Actions.  This checks for this environment variable: <b>CI=true</b>.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsKubernetes">
            <summary>
            Returns <c>true</c> if the current process is running as a container on Kubernetes.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetWindowsOptionalFeatures">
            <summary>
            <para>
            Returns a dictionary mapping optional Windows feature names to a <see cref="T:Neon.Common.WindowsFeatureStatus"/>
            indicating feature installation status.
            </para>
            <note>
            This method requires elevated permissions.
            </note>
            </summary>
            <returns>The feature dictionary.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when not running on Windows.</exception>
            <exception cref="T:Neon.Common.ExecuteException">Thrown when the current process doesn't have elevated permissions.</exception>
            <remarks>
            <note>
            The feature names are in English and the lookup is case-insensitive.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetWindowsOptionalFeatureStatus(System.String)">
            <summary>
            Returns the installation status for the named feature.
            </summary>
            <param name="feature">Specifies the <b>English</b> name for the feature.</param>
            <returns>The <see cref="T:Neon.Common.WindowsFeatureStatus"/> for the feature.</returns>
            <remarks>
            <para>
            You'll need to pass the feature name in English.  You can list possible feature
            names by executing this in your command shell:
            </para>
            <example>
            dism /Online /English /Get-Features /Format:table
            </example>
            <note>
            <see cref="F:Neon.Common.WindowsFeatureStatus.Unknown"/> will be returned for unknown features.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.EnableOptionalWindowsFeature(System.String)">
            <summary>
            Enables an optional Windows feature, returning an indication of whether a 
            Windows restart is required to complete the installation.
            </summary>
            <returns><c>true</c> if a restart is required.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the feature does't exist.</exception>
            <remarks>
            This method does nothing when the feature is already enabled
            or has been enabled but is waiting for a restart.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.DisableOptionalWindowsFeature(System.String)">
            <summary>
            Disables an optional Windows feature.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the feature does't exist or is enabled and waiting for a Windows restart.
            </exception>
            <remarks>
            This method does nothing when the feature is already disabled.
            </remarks>
        </member>
        <member name="P:Neon.Common.NeonHelper.HasElevatedPermissions">
            <summary>
            Determines whether the current process is running with elevated permissions.  This
            corresponds to running with administrator privileges for Windows or as the <b>root</b>
            user for Linux and OS/X.
            </summary>
            <exception cref="T:System.PlatformNotSupportedException">Thrown for unsupported platforms.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.EnsureElevatedPermissions">
            <summary>
            Ensures that the current process has elevated permissions.  See <see cref="P:Neon.Common.NeonHelper.HasElevatedPermissions"/>.
            </summary>
            <exception cref="T:System.Security.SecurityException">Thrown when the process does not have elevated permissions.</exception>
            <exception cref="T:System.PlatformNotSupportedException">Thrown for unsupported platforms.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetProgramPath(System.String)">
            <summary>
            Returns the path to an executable. 
            </summary>
            <param name="program">The program file name or fully qualified path.</param>
            <returns>The executable path.</returns>
            <remarks>
            <para>
            The behavior of this method varies based on whether the host operating system
            is Windows or Linux/OSX.
            </para>
            <para>
            For Windows, the <see cref="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)"/> method does not 
            search the PATH for the application so this method attempts to convert the program
            file name into a fully qualified path by actually searching the PATH.
            </para>
            <para>
            For Linux/OSX, the <paramref name="program"/> value is returned unchanged.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.NormalizeExecArgs(System.Object[])">
            <summary>
            Normalizes an array of argument objects into a form that can
            be passed to an invoked process by adding a quotes and escape
            characters as necessary. 
            </summary>
            <param name="args">The arguments.</param>
            <returns>The formatted argument string.</returns>
            <remarks>
            <note>
            <c>null</c> and empty arguments are ignored.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.NormalizeArg(System.String)">
            <summary>
            Normalizes a string argument.
            </summary>
            <param name="argValue">The argument.</param>
            <returns>The argument string with any required quotes and escapes.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.Fork(System.String,System.Object[])">
            <summary>
            Forks a child process that will run in parallel with the current process.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <returns>The <see cref="T:System.Diagnostics.Process"/> information.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetExecuteCommandLine(System.String,System.Object[])">
            <summary>
            Returns the actual command line that will be executed from the command 
            and arguments passed.
            </summary>
            <param name="command">The command to be executed.</param>
            <param name="args">Optional command arguments.</param>
            <returns>The actual command line to be executed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.Execute(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextReader,System.Action{System.Diagnostics.Process})">
            <summary>
            Starts a process with an array of arguments to run an executable file and
            then waits for the process to terminate.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as input.
            </param>
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.Execute(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextReader,System.Action{System.Diagnostics.Process})">
            <summary>
            Starts a process to run an executable file and then waits for the process to terminate.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as input.
            </param>
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteAsync(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextReader,System.Action{System.Diagnostics.Process})">
            <summary>
            Asynchronously starts a process to run an executable file with an array of
            arguments and then and waits for the process to terminate.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as input.
            </param>
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteAsync(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextReader,System.Action{System.Diagnostics.Process})">
            <summary>
            Asynchronously starts a process to run an executable file and then waits for the process to terminate.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as input.
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Common.NeonHelper.ProcessStreamRedirector">
            <summary>
            Used to redirect process output streams.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCapture(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Action{System.String},System.Action{System.String},System.IO.TextReader,System.Text.Encoding,System.Action{System.Diagnostics.Process})">
            <summary>
            Starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="outputAction">Optional action that will be called when the process outputs some text.</param>
            <param name="errorAction">Optional action that will be called when the process outputs some error text.</param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as standard input.
            </param>
            <param name="outputEncoding">
            Optionally specifies the expected standard output/error encoding.  This defaults to 
            <c>null</c> which sets the default system codepage.
            </param>
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            <para>
            You can optionally specify the <paramref name="outputAction"/> and/or <paramref name="errorAction"/>
            callbacks to receive the process output text as it is received.  <paramref name="outputAction"/> will 
            be called with both the STDOUT and STDERR streams if <paramref name="errorAction"/> is <c>null</c>
            otherwise it will called only with STDOUT text.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCapture(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Action{System.String},System.Action{System.String},System.IO.TextReader,System.Text.Encoding,System.Action{System.Diagnostics.Process})">
            <summary>
            Starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="outputAction">Optional action that will be called when the process outputs some text.</param>
            <param name="errorAction">Optional action that will be called when the process outputs some error text.</param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as standard input.
            </param>
            <param name="outputEncoding">
            Optionally specifies the expected standard output/error encoding.  This defaults to 
            <c>null</c> which sets the default system codepage.
            </param>
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            <para>
            You can optionally specify the <paramref name="outputAction"/> and/or <paramref name="errorAction"/>
            callbacks to receive the process output text as it is received.  <paramref name="outputAction"/> will 
            be called with both the STDOUT and STDERR streams if <paramref name="errorAction"/> is <c>null</c>
            otherwise it will called only with STDOUT text.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCaptureAsync(System.String,System.Object[],System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.IO.TextReader,System.Text.Encoding,System.Action{System.Diagnostics.Process})">
            <summary>
            Asynchronously starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as input.
            </param>
            <param name="outputEncoding">
            Optionally specifies the expected standard output/error encoding.  This defaults to 
            <c>null</c> which sets the default system codepage.
            </param>
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCaptureAsync(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextReader,System.Text.Encoding,System.Action{System.Diagnostics.Process})">
            <summary>
            Asynchronously starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">
            <para>
            Name or path to the executable file.
            </para>
            <note>
            The <c>PATH</c> environment variable will be searched for the executable file 
            when no path is specified.
            </note>
            </param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            Optional existing <see cref="T:System.Diagnostics.Process"/> instance used to launch the process.
            </param>
            <param name="workingDirectory">
            Optionally specifies the working directory for executing the program.
            </param>
            <param name="clearEnvironment">
            Optionally clears all environment variables that would be passed to the program.
            This happens before setting any environment variables passed as <paramref name="environmentVariables"/>.
            </param>
            <param name="environmentVariables">
            Optionally specifies the environment variables to be passed into the process.
            The new process inherits the current processes variables when this is <c>null</c>.
            </param>
            <param name="input">
            Optionally specifies a <see cref="T:System.IO.TextReader"/> with text to be sent 
            to the process as input.
            </param>
            <param name="outputEncoding">
            Optionally specifies the expected standard output/error encoding.  This defaults to 
            <c>null</c> which sets the default system codepage.
            </param>
            <param name="processCallback">
            Optionally passed to obtain the details of the process created to execute the command.
            When a non-null value is passed, the callback will be called with the <see cref="T:System.Diagnostics.Process"/> 
            instances just after it is launched.
            </param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not completed in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.StartProcess(System.Reflection.Assembly,System.String)">
            <summary>
            Starts a process for an <see cref="T:System.Reflection.Assembly" /> by calling the assembly's <b>main()</b>
            entry point method. 
            </summary>
            <param name="assembly">The assembly to be started.</param>
            <param name="args">The command line arguments (or <c>null</c>).</param>
            <returns>The process started.</returns>
            <remarks>
            <note>
            This method works only for executable assemblies with
            an appropriate <b>main</b> entry point that reside on the
            local file system.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.OpenBrowser(System.String)">
            <summary>
            Launches the default browser to display the specified URI.
            </summary>
            <param name="uri">The target URI.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteShell(System.String)">
            <summary>
            Executes a command using the local shell, <b>CMD.EXE</b> for Windows and
            <b>Bash</b> for OSX and Linux.
            </summary>
            <param name="command">The command and arguments to be executed.</param>
            <returns>The process exit code.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetProcessById(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Diagnostics.Process"/> associated with an ID
            or <c>null</c> if no process with this ID exists.
            </summary>
            <param name="id">The target process ID.</param>
            <returns>The <see cref="T:System.Diagnostics.Process"/> or <c>null</c>.</returns>
            <remarks>
            This is slightly different from how <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)"/>
            works.  That method throws an <see cref="T:System.ArgumentException"/> if there's
            no process with the ID where as this one will return <c>null</c>.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.CreateRandom">
            <summary>
            <para>
            Creates the <see cref="F:Neon.Common.NeonHelper.rand"/> instance.
            </para>
            <note>
            THIS MUST BE CALLED WHILE <see cref="F:Neon.Common.NeonHelper.randLock"/> IS LOCKED.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomInt">
            <summary>
            Returns an integer pseudo random number.
            </summary>
            <returns>The random integer.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomDouble">
            <summary>
            Returns a double pseudo random number between 0.0 and +1.0
            </summary>
            <returns>The random number.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomDouble(System.Double)">
            <summary>
            Returns a double pseudo random number between 0.0 and the specified limit.
            </summary>
            <param name="limit">The limit.</param>
            <returns>The random number.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomInt(System.Int32)">
            <summary>
            Returns a pseudo random number in the range of 0..limit-1.
            </summary>
            <param name="limit">The value returned will not exceed one less than this value.</param>
            <returns>The random number.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomBytes(System.Int32)">
            <summary>
            Returns the specified number of pseudo random bytes.
            </summary>
            <param name="count">The requested number of bytes.</param>
            <returns>The random bytes.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomIndex(System.Int32)">
            <summary>
            Returns a random index into a sequence whose length is specified.
            </summary>
            <param name="length">The sequence length.</param>
            <returns>The random index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if length is &lt;= 0.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomTimespan(System.TimeSpan)">
            <summary>
            Returns a random <see cref="T:System.TimeSpan"/> between zero and a specified maximum.
            </summary>
            <param name="maxInterval">The maximum interval.</param>
            <returns>The random timespan.</returns>
            <remarks>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomTimespan(System.TimeSpan,System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> between the specified base interval
            plus a random period of the specified fraction of the value.
            </summary>
            <param name="baseInterval">The base interval.</param>
            <param name="fraction">The fractional multiplier for the random component.</param>
            <returns>The random timespan.</returns>
            <remarks>
            <para>
            The value returned is at least as large as <paramref name="baseInterval" /> with an
            added random fractional interval if <paramref name="fraction" /> is positive or the value
            returned may be less than <paramref name="baseInterval" /> for a negative <paramref name="fraction" />.  
            This is computed via:
            </para>
            <code language="cs">
            baseInterval + Helper.RandTimespan(TimeSpan.FromSeconds(baseInterval.TotalSeconds * fraction));
            </code>
            <para>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomTimespan(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a random <see cref="T:System.TimeSpan" /> value between the min/max
            values specified.
            </summary>
            <param name="minInterval">The minimum interval.</param>
            <param name="maxInterval">The maximum interval.</param>
            <returns>The randomized time span.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetCryptoRandomBytes(System.Int32)">
            <summary>
            Generates a byte array filled with a cryptographically strong sequence of random values.
            </summary>
            <param name="count">The number of random bytes to be generated.</param>
            <returns>The random byte array.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetCryptoRandomPassword(System.Int32)">
            <summary>
            Generates a cryptographically random password.
            </summary>
            <param name="length">The password length.</param>
            <returns>The generated password.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.CreateSecureRandom">
            <summary>
            Creates a <see cref="T:System.Random"/> pseudo random number generated
            with a cryptographically random seed.
            </summary>
            <returns>A <see cref="T:System.Random"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.CreateBase36Uuid(System.Boolean)">
            <summary>
            Generates a 13 digit base-36 UUID including only lowercase ASCII
            characters and digits.  This is useful for generating unique shorter
            names for Kubernetes objects etc.
            </summary>
            <param name="secure">
            Optionally specifies that a cryptographically secure algorithm is
            is used to generate the UUID, rather than the default pseudo random
            generator.  Cryptogrphically secure algorithms consume system entropy.
            </param>
            <returns>The new base-36 string.</returns>
        </member>
        <member name="T:Neon.Common.NeonHelper.LowercaseYamlNamingConvention">
            <summary>
            YAML naming convention that renders property names as lowercase
            and is case insensitive.
            </summary>
        </member>
        <member name="T:Neon.Common.NeonHelper.YamlEnumTypeConverter">
            <summary>
            Customizes <c>enum</c> type conversions to/from strings recognizing
            <c>[EnumMember]</c> attributes when present.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlEnumTypeConverter.Accepts(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlEnumTypeConverter.ReadYaml(YamlDotNet.Core.IParser,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlEnumTypeConverter.WriteYaml(YamlDotNet.Core.IEmitter,System.Object,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.NeonHelper.MultilineScalarFlowStyleEmitter">
            <summary>
            We're using this to prevent YamlDotNet from serializing mult-line strings
            as double spaced: https://stackoverflow.com/questions/58431796/change-the-scalar-style-used-for-all-multi-line-strings-when-serialising-a-dynam
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlSerialize(System.Object)">
            <summary>
            <para>
            Serializes an object to YAML. 
            </para>
            <note>
            Property names are always converted to lowercase when serializing to YAML.
            </note>
            </summary>
            <param name="value">The value to be serialized.</param>
            <returns>The YAML text.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlDeserialize``1(System.String,System.Boolean)">
            <summary>
            <para>
            Deserializes YAML text to an object, optionally requiring strict mapping of input properties to the target type.
            </para>
            <note>
            Property names are expected to be lowercase.
            </note>
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="yaml">The YAML text.</param>
            <param name="strict">Optionally require that all input properties map to route properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlDeserializeViaJson``1(System.String,System.Boolean)">
            <summary>
            Deserializes YAML to an object via JSON.NET. This allows the use of <see cref="T:Newtonsoft.Json.JsonConverter"/>s to deserialize complex types.
            Strict requires mapping of input properties in the target type.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="yaml">The YAML text.</param>
            <param name="strict">Optionally require that all input properties map to route properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <exception cref="T:YamlDotNet.Core.YamlException"></exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonToYaml(System.String)">
            <summary>
            Converts a JSON text to YAML.
            </summary>
            <param name="jsonText">The JSON text.</param>
            <returns>The equivalent YAML text.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="jsonText"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="jsonText"/> does not specify a value, array, or object.</exception>
            <remarks>
            <note>
            Property names are always converted to lowercase when converting to YAML.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetYamlValue(Newtonsoft.Json.Linq.JValue)">
            <summary>
            Returns the serialized YAML value for a <see cref="T:Newtonsoft.Json.Linq.JValue"/>.
            </summary>
            <param name="jValue">The value.</param>
            <returns>The serialized value.</returns>
        </member>
        <member name="T:Neon.Common.NetFramework">
            <summary>
            Enumerates the known .NET Framework implementations.
            </summary>
        </member>
        <member name="F:Neon.Common.NetFramework.Unknown">
            <summary>
            The framework could not be determined.
            </summary>
        </member>
        <member name="F:Neon.Common.NetFramework.Core">
            <summary>
            .NET Core
            </summary>
        </member>
        <member name="F:Neon.Common.NetFramework.NetFramework">
            <summary>
            .NET Framework
            </summary>
        </member>
        <member name="F:Neon.Common.NetFramework.Native">
            <summary>
            .NET Native
            </summary>
        </member>
        <member name="F:Neon.Common.NetFramework.Net">
            <summary>
            .NET 5.0 and later
            </summary>
        </member>
        <member name="T:Neon.Common.SpecialUtf8EncodingProvider">
            <summary>
            This is a special class used by <see cref="M:Neon.Common.NeonHelper.RegisterMisspelledUtf8Provider"/>
            to implement UTF-8 encodings with the name <b>utf8</b> misspelled (no dash).
            </summary>
        </member>
        <member name="T:Neon.Common.WindowsEdition">
            <summary>
            Enumerates the known Windows Editions.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsEdition.Unknown">
            <summary>
            The Windows edition could not be identified.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsEdition.Home">
            <summary>
            Windows Home.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsEdition.Professional">
            <summary>
            Windows Professional.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsEdition.ServerStandard">
            <summary>
            Windows Server (standard).
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsEdition.ServerEnterprise">
            <summary>
            Windows Server (enterprise).
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsEdition.ServerDatacenter">
            <summary>
            Windows Server (datacenter).
            </summary>
        </member>
        <member name="T:Neon.Common.WindowsFeatureStatus">
            <summary>
            Enumerates the possible states of an optional Windows feature.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsFeatureStatus.Unknown">
            <summary>
            The feature status couldn't be determined.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsFeatureStatus.Disabled">
            <summary>
            The feature is disabled.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsFeatureStatus.Enabled">
            <summary>
            The feature is enabled.
            </summary>
        </member>
        <member name="F:Neon.Common.WindowsFeatureStatus.EnabledPending">
            <summary>
            The feature is currently partially installed and will be enabled after
            Windows is restarted.
            </summary>
        </member>
        <member name="T:Neon.Common.ByteEncoding">
            <summary>
            Implements a text encoding that simply reads and writes bytes without
            any changes.  This corresponds to the Windows codepage <b>1252</b>.
            </summary>
        </member>
        <member name="P:Neon.Common.ByteEncoding.Instance">
            <summary>
            Returns a <see cref="T:Neon.Common.ByteEncoding"/> instance.
            </summary>
        </member>
        <member name="M:Neon.Common.ByteEncoding.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetMaxByteCount(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetMaxCharCount(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.ByteUnits">
            <summary>
            <para>
            Converts a size string with optional units into a count.
            </para>
            <list type="table">
            <item>
                <term><b>K</b> or <b>KB</b></term>
                <description>1,000</description>
            </item>
            <item>
                <term><b>Ki</b> or <b>kiB</b></term>
                <description>1,024</description>
            </item>
            <item>
                <term><b>M</b> or <b>MB</b></term>
                <description>1000000</description>
            </item>
            <item>
                <term><b>Mi</b> or <b>MiB</b></term>
                <description>1,048,576</description>
            </item>
            <item>
                <term><b>G</b> or <b>GB</b></term>
                <description>1,000,000,000</description>
            </item>
            <item>
                <term><b>Gi</b> or <b>GiB</b></term>
                <description>1,073,741,824</description>
            </item>
            <item>
                <term><b>T</b> or <b>TB</b></term>
                <description>1,000,000,000,000</description>
            </item>
            <item>
                <term><b>Ti</b> or <b>TiB</b></term>
                <description>1,099,511,627,776</description>
            </item>
            <item>
                <term><b>P</b> or <b>PB</b></term>
                <description>1,000,000,000,000,000</description>
            </item>
            <item>
                <term><b>Pi</b> or <b>PiB</b></term>
                <description>1,125,899,906,842,624</description>
            </item>
            <item>
                <term><b>E</b> or <b>EB</b></term>
                <description>1,000,000,000,000,000,000‬</description>
            </item>
            <item>
                <term><b>Ei</b> or <b>EiB</b></term>
                <description>1,152,921,504,606,846,976‬</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.KiloBytes">
            <summary>
            One KB: 1,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.MegaBytes">
            <summary>
            One MB: 1,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.GigaBytes">
            <summary>
            One GB: 1,000,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.TeraBytes">
            <summary>
            The constant 1,000,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.PetaBytes">
            <summary>
            One PB: 1,000,000,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.ExaBytes">
            <summary>
            One PB: 1,000,000,000,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.KibiBytes">
            <summary>
            One KiB: 1,024 (2^10)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.MebiBytes">
            <summary>
            One MiB: 1,048,576 (2^20)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.GibiBytes">
            <summary>
            One GiB: 1,073,741,824 (2^30)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.TebiBytes">
            <summary>
            The constant 1,099,511,627,776 (2^40)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.PebiBytes">
            <summary>
            One PiB: 1,125,899,906,842,624 (2^50)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.ExbiBytes">
            <summary>
            One PiB: 1,152,921,504,606,846,976‬ (2^60)
            </summary>
        </member>
        <member name="M:Neon.Common.ByteUnits.TryParse(System.String,System.Decimal@)">
            <summary>
            Parses a floating point count string that may include one of the optional
            unit suffixes described here <see cref="T:Neon.Common.ByteUnits"/>.
            </summary>
            <param name="input">The input string.</param>
            <param name="value">Returns as the output value.</param>
            <returns><b>true</b> on success</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.Parse(System.String)">
            <summary>
            Parses a size and returns a <c>decimal</c>.
            </summary>
            <param name="text">The value being parsed.</param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.FormatException">Thrown if the value cannot be parsed.</exception>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToByteString(System.Decimal)">
            <summary>
            Converts a size to a string using byte units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in bytes.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToDoubleString(System.Decimal,System.Decimal)">
            <summary>
            Converts the size to the specified units and then renders this
            as an invariant culture fixed point string.
            </summary>
            <param name="size">The byte size.</param>
            <param name="units">The units.</param>
            <returns>The floating point string.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToKB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>KB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in KB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToKiB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>KiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in KiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToMB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>MB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in MB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToMiB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>MiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in MiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToGB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>GB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in GB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToGiB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>GiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in GiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToTB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>TB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in TB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToTiB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>TiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in TiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToPB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>PB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in PB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToPiB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>PiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in PiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToEB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>EB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in EB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToEiB(System.Decimal)">
            <summary>
            Converts a size to a string using <b>EiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in EiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.Humanize(System.Decimal,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Humanizes the size passed into a string using appropriate units.
            This uses power-of-10 based units by default but you can switch
            to power-of-2 units by passing <paramref name="powerOfTwo"/> as
            <c>true</c>.
            </summary>
            <param name="size">The size.</param>
            <param name="powerOfTwo">Optionally returns a power-of-2 based unit.</param>
            <param name="spaceBeforeUnit">Optionally excludes a space between the value and unit (this defaults to <c>true</c>.</param>
            <param name="removeByteUnit">
            Optionally strip any trailing "B" from the unit string.  For example when this
            is set, a decimal value of 1000 will return <b>1K</b> instead of <b>1KB</b>.
            </param>
            <returns>The converted string.</returns>
        </member>
        <member name="T:Neon.Common.ProgramEntrypoint">
            <summary>
            Synchronous main entry point method signature.
            </summary>
            <param name="args">The command line arguments.</param>
            <returns>The exit code.</returns>
        </member>
        <member name="T:Neon.Common.ProgramEntrypointAsync">
            <summary>
            Asynchronous main entry point method signature.
            </summary>
            <param name="args">The command line arguments.</param>
            <returns>The exit code.</returns>
        </member>
        <member name="T:Neon.Common.ProgramRunner">
            <summary>
            Used to implement unit tests on command line tools by simulating
            their execution on a thread rather than forking the tool as a process.
            This is makes debugging easier and also deals with the fact that
            unit tests may leave orphan processes running.
            </summary>
            <remarks>
            <para>
            This class is designed to simulate running a single executable
            by calling its main entry point.  To accomplish this, use the
            default constructor to create a <see cref="T:Neon.Common.ProgramRunner"/> 
            instance.  The constructor will set <see cref="P:Neon.Common.ProgramRunner.Current"/> to
            itself and then you can call <see cref="M:Neon.Common.ProgramRunner.Execute(Neon.Common.ProgramEntrypoint,System.String[])"/>
            to execute the program synchronously (waiting for it to return),
            or <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/> to simulate 
            forking the program by running it on a new thread.
            </para>
            <para>
            <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/> waits to return
            until the program calls <see cref="M:Neon.Common.ProgramRunner.ProgramReady"/>.  This is used
            to ensure that program has completed the activities required 
            by the unit tests before the tests are executed.
            </para>
            <note>
            Only one <see cref="T:Neon.Common.ProgramRunner"/> instance can active at any
            particular time.
            </note>
            <para>
            Simulated program entry points that will be called by <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>
            and that run indefinitely, need to call <see cref="M:Neon.Common.ProgramRunner.WaitForExit"/> when
            after its started the operation.  This returns when the <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/>
            is called.  The simulated program should stop any operations being
            performed, release any important resources and exit cleanly its <c>Main</c>
            method cleanly.
            </para>
            <para>
            The <see cref="P:Neon.Common.ProgramRunner.Arguments"/> dictionary can be used to pass additional
            arguments into the program being tested.  This maps case insensitve keys
            to <c>object</c> values.
            </para>
            <note>
            You should call <see cref="M:Neon.Common.ProgramRunner.Dispose"/> when you're finished with
            the runner.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Common.ProgramRunner.Current">
            <summary>
            Returns the current <see cref="T:Neon.Common.ProgramRunner"/> or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.#ctor(System.TimeSpan)">
            <summary>
            Constructor.
            </summary>
            <param name="forkTimeout">
            Specifies the maximum time for <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>
            to wait for the program to signal that it's ready by calling <see cref="M:Neon.Common.ProgramRunner.ProgramReady"/>.
            This defaults to <b>30 seconds</b>.
            </param>
        </member>
        <member name="M:Neon.Common.ProgramRunner.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Common.ProgramRunner.Arguments">
            <summary>
            Returns a case insensitve dictionary of additional unit test related arguments
            that can be passed to the program being tested.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.Execute(Neon.Common.ProgramEntrypoint,System.String[])">
            <summary>
            Executes a program entry point synchronously, passing arguments and returning the result.
            </summary>
            <param name="main">The program entry point.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ExecuteAsync(Neon.Common.ProgramEntrypointAsync,System.String[])">
            <summary>
            Executes a program entry point asynchronously, passing arguments and returning the result.
            </summary>
            <param name="mainAsync">The program entry point.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.OpenStandardInput">
            <summary>
            Opens the standard input stream.  This will return a stream with the
            input specified when <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.Byte[],System.String[])"/>
            or <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.String,System.String[])"/> were called
            or else it will simply return the result of <see cref="M:System.Console.OpenStandardInput"/>.
            </summary>
            <returns>The input <see cref="T:System.IO.Stream"/>.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.Byte[],System.String[])">
            <summary>
            Executes a program entry point synchronously, streaming some bytes as standard input,
            passing arguments and returning the result.
            </summary>
            <param name="main">The program entry point.</param>
            <param name="inputBytes">The bytes to be passed as standard input.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.String,System.String[])">
            <summary>
            Executes a program entry point synchronously, streaming some text as standard input,
            passing arguments and returning the result.
            </summary>
            <param name="main">The program entry point.</param>
            <param name="inputText">The text to be passed as standard input.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ExecuteWithInputAsync(Neon.Common.ProgramEntrypointAsync,System.Byte[],System.String[])">
            <summary>
            Executes a program entry point asynchronously, streaming some bytes as standard input,
            passing arguments and returning the result.
            </summary>
            <param name="mainAsync">The program entry point.</param>
            <param name="inputBytes">The bytes to be passed as standard input.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ExecuteWithInputAsync(Neon.Common.ProgramEntrypointAsync,System.String,System.String[])">
            <summary>
            Executes a program entry point asynchronously, streaming some text as standard input,
            passing arguments and returning the result.
            </summary>
            <param name="mainAsync">The program entry point.</param>
            <param name="inputText">The text to be passed as standard input.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])">
            <summary>
            <para>
            Executes a program entry point asynchronously, without waiting for the command to complete.
            This is useful for commands that don't terminate by themselves.  Call <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/>
            to kill the running command.
            </para>
            <note>
            <b>IMPORTANT:</b> The <paramref name="main"/> simulated entry point must call
            <see cref="M:Neon.Common.ProgramRunner.WaitForExit"/>.  This will block until the <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/>
            is called, returning when the program is expected to terminate itself.
            </note>
            </summary>
            <param name="main">The program entry point.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ProgramReady">
            <summary>
            <para>
            Called by programs executed via <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>
            when the program has initialized itself enough to be ready for testing.
            </para>
            <note>
            This must be called or else <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/> will
            never return.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.TerminateFork">
            <summary>
            Terminates the forked program if one is running.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.WaitForExit">
            <summary>
            Called by the emulated program entry point for operations that are
            initiated via <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>.  This
            method will block until <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/> is called.  The
            emulated program must exit cleanly when this returns.
            </summary>
        </member>
        <member name="T:Neon.Common.TextIndentor">
            <summary>
            Implements a simple scheme for managing line indentation when writing
            to a <see cref="T:System.Text.StringBuilder"/> or <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:Neon.Common.TextIndentor.#ctor(System.Text.StringBuilder,System.Int32,System.Char,System.Int32)">
            <summary>
            Constructs and instance that outputs to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Specifies the target <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="indentWidth">Optionally specifies the number of spaces to indent for each indentation level.  This defaults to <b>4</b>.</param>
            <param name="indentChar">Optionally specifies the indent character (defaults to a space).</param>
            <param name="indentLevel">Optionally specifies the initial indent level.  This defaults to <b>0</b>.</param>
        </member>
        <member name="M:Neon.Common.TextIndentor.#ctor(System.IO.TextWriter,System.Int32,System.Char,System.Int32)">
            <summary>
            Constructs and instance that outputs to a <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="writer">Specifies the target <see cref="T:System.IO.TextWriter"/>.</param>
            <param name="indentWidth">Optionally specifies the number of spaces to indent for each indentation level.  This defaults to <b>4</b>.</param>
            <param name="indentChar">Optionally specifies the indent character (defaults to a space).</param>
            <param name="indentLevel">Optionally specifies the initial indent level.  This defaults to <b>0</b>.</param>
        </member>
        <member name="M:Neon.Common.TextIndentor.InternalAppend(System.String)">
            <summary>
            Used internally to append text to the the output.
            </summary>
            <param name="text">Specifies the text to be appended.</param>
        </member>
        <member name="M:Neon.Common.TextIndentor.InternalAppendIndent(System.String)">
            <summary>
            Appends the indentation for the the current level when the
            text passed is not <c>null</c> or empty and the current
            line is empty.
            </summary>
            <param name="text">Specifies the text that will (eventually) be written ort <c>null</c>.</param>
        </member>
        <member name="M:Neon.Common.TextIndentor.Append(System.String)">
            <summary>
            Appends text to the the output, writing the current indent if this
            is the first text being written to the current line.
            </summary>
            <param name="text">Specifies the text to be written.</param>
        </member>
        <member name="M:Neon.Common.TextIndentor.AppendLine(System.String)">
            <summary>
            Writes a line of text to the target prefixed by the indentation.
            </summary>
            <param name="text">Optionally specifies the text to be written.</param>
        </member>
        <member name="M:Neon.Common.TextIndentor.Reset">
            <summary>
            Resets the current indentation level zero.
            </summary>
        </member>
        <member name="M:Neon.Common.TextIndentor.Indent">
            <summary>
            Increments the indentation level.
            </summary>
        </member>
        <member name="M:Neon.Common.TextIndentor.UnIndent">
            <summary>
            Decrements the indentation level.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the indentation level is already at zero.</exception>
        </member>
        <member name="T:Neon.Common.TriState">
            <summary>
            Used to specify a tristate boolean with values: <b>true</b>, <b>false</b>, and <b>default</b>.
            </summary>
        </member>
        <member name="F:Neon.Common.TriState.Default">
            <summary>
            Specifies the default behavior.
            </summary>
        </member>
        <member name="F:Neon.Common.TriState.False">
            <summary>
            Specifies <c>false</c>.
            </summary>
        </member>
        <member name="F:Neon.Common.TriState.True">
            <summary>
            Specifies <c>true</c>.
            </summary>
        </member>
        <member name="T:Neon.Common.NamespaceDoc">
            <summary>
            This namespace includes generally useful types that are consumed by
            the remaining NeonSDK libraries and can also be useful for
            end-user applications.
            </summary>
        </member>
        <member name="T:Neon.Csv.CsvReader">
            <summary>
            Parses CSV encoded rows from text.
            </summary>
            <remarks>
            <para>
            Use this class to parse CSV encoded tables.  Use one of the constructors
            to initialize in instance to read from a file, <see cref="T:System.IO.Stream" /> , string, or 
            a <see cref="T:System.IO.TextReader" /> and then call <see cref="M:Neon.Csv.CsvReader.Read" /> to read each
            row of the table.
            </para>
            <para>
            This class handles the all special cases for CSV parsing including quoted
            fields, escaped double quotes, and fields that include CR and LF characters.
            </para>
            <para>
            Be sure to call <see cref="M:Neon.Csv.CsvReader.Close" /> or <see cref="M:Neon.Csv.CsvReader.Dispose" /> when you
            are finished with the class to release any underlying resources.
            </para>
            <note>
            The underlying stream must support seeking for this class to work properly.
            </note>
            </remarks>
            <threadsafety instance="false" />
        </member>
        <member name="M:Neon.Csv.CsvReader.#ctor(System.String)">
            <summary>
            Constructs a reader to parse a string.
            </summary>
            <param name="text">The text string.</param>
        </member>
        <member name="M:Neon.Csv.CsvReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a reader to parse a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The stream's character <see cref="T:System.Text.Encoding" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a reader to parse text from a <see cref="T:System.IO.TextReader" />.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvReader.Close">
            <summary>
            Closes the reader if it is still open.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvReader.Dispose">
            <summary>
            Releases any resources associated with the reader.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvReader.Read">
            <summary>
            Parses and returns the next row of fields.
            </summary>
            <returns>
            A list of parsed field strings or <c>null</c> if the end of the input stream
            has been reached.
            </returns>
        </member>
        <member name="M:Neon.Csv.CsvReader.Rows">
            <summary>
            Returns an enumerator that returns the data rows from a <see cref="T:Neon.Csv.CsvReader"/>.
            </summary>
            <returns>The next row as a <see cref="T:System.Collections.Generic.List`1"/>.</returns>
        </member>
        <member name="T:Neon.Csv.CsvTableReader">
            <summary>
            Used to read a CSV table that includes row headers.
            </summary>
            <remarks>
            <para>
            This class makes it easy to process tabular data loaded from a CSV file,
            where the first row of the file contains the row header strings that
            identify the table columns.
            </para>
            <para>
            Initialize an instance by passing a <see cref="T:Neon.Csv.CsvReader" />, stream, string, or file path to the 
            constructor.  The constructor will read the first row of the file and initialize the <see cref="P:Neon.Csv.CsvTableReader.ColumnMap" />
            dictionary which maps the case insensitive column name to the zero based index of the
            column in the table.
            </para>
            <para>
            You'll process each data row by calling <see cref="M:Neon.Csv.CsvTableReader.ReadRow" />.  This returns a list
            with the next row of data or <c>null</c> if the end of the table has been reached.  You can
            process the row data returned directly or use the <see cref="M:Neon.Csv.CsvTableReader.GetColumn(System.String)" /> method to
            access a column value on the current row directly.
            </para>
            <note>
            This class is tolerant of blank or duplicate column names.  In the case of duplicates, the
            first column matching the requested column name will be used when parsing data.
            </note>
            <para>
            Applications should call the reader's <see cref="M:Neon.Csv.CsvTableReader.Dispose" /> or <see cref="M:Neon.Csv.CsvTableReader.Close" />
            method when they are finished with the reader so that the underlying <see cref="T:Neon.Csv.CsvReader" />
            will be closed as well, promptly releasing any system resources (such as the stream).
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(Neon.Csv.CsvReader)">
            <summary>
            Constructs an instance to read from a <see cref="T:Neon.Csv.CsvReader" />.
            </summary>
            <param name="reader">The <see cref="T:Neon.Csv.CsvReader" /> to read from.</param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs an instance to read from a <see cref="T:System.IO.TextReader" />.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs an instance to read from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The stream's character <see cref="T:System.Text.Encoding" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(System.String)">
            <summary>
            Constructs an instance to read from a CSV string.
            </summary>
            <param name="text">The CSV text.</param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.Dispose">
            <summary>
            Releases any system resources held by the instance,
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.Close">
            <summary>
            Closes the reader if it is still open.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Reader">
            <summary>
            Returns the underlying <see cref="T:Neon.Csv.CsvReader" /> or <c>null</c> if the reader is closed.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Columns">
            <summary>
            Returns the list of table columns in the order read from the source.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.ColumnMap">
            <summary>
            Returns the dictionary that case insensitvely maps a column name to 
            the zero based index of the column.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.ReadRow">
            <summary>
            Reads the next row of table.
            </summary>
            <returns>The list of column values or <c>null</c> if the end of the table has been reached.</returns>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.Rows">
            <summary>
            Returns an enumerator that returns the data rows from a <see cref="T:Neon.Csv.CsvTableReader"/>.
            </summary>
            <returns>The next row as a <see cref="T:System.Collections.Generic.List`1"/>.</returns>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.GetColumn(System.String)">
            <summary>
            Returns the value for the named column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <returns>The column value or <c>null</c> if the column (or row) does not exist.</returns>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Item(System.String)">
            <summary>
            Indexer that returns the value for the named column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <returns>The column value or <c>null</c> if the column (or row) does not exist.</returns>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Item(System.Int32)">
            <summary>
            Indexer that returns the value for a column.
            </summary>
            <param name="column">The column index.</param>
            <returns>The column value or <c>null</c> if the column (or row) does not exist.</returns>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.IsEmpty(System.String)">
            <summary>
            Determines whether a cell in a named column in the current row is empty or
            if the column does not exist.
            </summary>
            <param name="columnName">The column name.</param>
            <returns><c>true</c> if the cell is empty or the named column is not present.</returns>
        </member>
        <member name="T:Neon.Csv.CsvTableWriter">
            <summary>
            Used to generate a CSV table.
            </summary>
            <remarks>
            <para>
            This class is used to generate a CSV table with column headers with the class
            handling the mapping of column names to columns.  The class is easy to use.  Simply
            construct an instance, passing an array of case insensitive table column header names
            and then write table rows by calling <b>Set()</b> methods to set row cell values
            and then <see cref="M:Neon.Csv.CsvTableWriter.WriteRow" /> to write each row to the output.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.#ctor(System.String[],Neon.Csv.CsvWriter)">
            <summary>
            Constructs an instance to write to a <see cref="T:Neon.Csv.CsvWriter" />.
            </summary>
            <param name="columnHeaders">The table column names.</param>
            <param name="writer">The <see cref="T:Neon.Csv.CsvWriter" /> to write to.</param>
            <remarks>
            <note>
            This method writes the column headers passed to the writer so the
            application can begin writing rows of data.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.#ctor(System.String[],System.IO.TextWriter)">
            <summary>
            Constructs an instance to write to a <see cref="T:System.IO.TextWriter" />.
            </summary>
            <param name="columnHeaders">The table column names.</param>
            <param name="writer">The writer.</param>
            <remarks>
            <note>
            This method writes the column headers passed to the writer so the
            application can begin writing rows of data.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.#ctor(System.String[],System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs an instance to write to a stream.
            </summary>
            <param name="columnHeaders">The table column names.</param>
            <param name="stream">The output stream.</param>
            <param name="encoding">The file's character <see cref="T:System.Text.Encoding" />.</param>
            <remarks>
            <note>
            This method writes the column headers passed to the writer so the
            application can begin writing rows of data.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Dispose">
            <summary>
            Releases any system resources held by the instance,
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Close">
            <summary>
            Closes the reader if it is still open.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableWriter.Writer">
            <summary>
            Returns the underlying <see cref="T:Neon.Csv.CsvWriter" /> or <c>null</c> if the writer is closed.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableWriter.ColumnMap">
            <summary>
            Returns the dictionary that case insensitvely maps a column name to 
            the zero base index of the column.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.GetColumnIndex(System.String)">
            <summary>
            Returns the zero-based index of the specified column.
            </summary>
            <param name="columnName">The column name.</param>
            <returns>The index of the column or <b>-1</b> if the column does not exist.</returns>
        </member>
        <member name="P:Neon.Csv.CsvTableWriter.Row">
            <summary>
            Returns the current row array.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.WriteRow">
            <summary>
            Writes the current row of data to the output and then clears the row
            so the application can begin setting the next row. 
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Set(System.String,System.String)">
            <summary>
            Sets the value of a named table column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <param name="value">The column value.</param>
            <remarks>
            <note>
            This method will do nothing if the <paramref name="columnName" /> 
            passed does not map to a table column.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Set(System.String,System.Object)">
            <summary>
            Sets the value of a named table column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <param name="value">The column value.</param>
            <remarks>
            <note>
            This method will do nothing if the <paramref name="columnName" /> 
            passed does not map to a table column.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Csv.CsvWriter">
            <summary>
            Writes lines of CSV encoded columns to a file or <see cref="T:System.IO.TextWriter" />.
            </summary>
            <threadsafety instance="false" />
        </member>
        <member name="M:Neon.Csv.CsvWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a writer to a stream.
            </summary>
            <param name="stream">The output stream.</param>
            <param name="encoding">The stream's character <see cref="T:System.Text.Encoding" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a writer to a <see cref="T:System.IO.TextWriter" />.
            </summary>
            <param name="writer">The <see cref="T:System.IO.TextWriter" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvWriter.Close">
            <summary>
            Closes the writer if it is still open.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvWriter.Dispose">
            <summary>
            Releases any resources associated with the reader.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvWriter.WriteLine(System.Object[])">
            <summary>
            Writes the arguments passed to the output, separating each argument
            with a comma and adding escape characters as necessary.
            </summary>
            <param name="args">The arguments.</param>
        </member>
        <member name="T:Neon.Csv.NamespaceDoc">
            <summary>
            This namespace includes types for reading and writing Comma Separated Value (CSV) formatted data.
            </summary>
        </member>
        <member name="T:Neon.Data.DateTimeJsonConverter">
            <summary>
            <para>
            <b>Newtonsoft:</b> Implements a type converter for <see cref="T:System.DateTime"/> using the culture
            invariant <b>yyyy-MM-ddTHH:mm:ss.fffZ</b> format.
            </para>
            <note>
            This converter assumes that the <see cref="T:System.DateTime"/> being converted is
            relative to UTC.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Data.DateTimeJsonConverter.Type">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.DateTimeJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.DateTime,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.DateTimeJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.DateTime,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.DateTimeJsonConverter.ToSimpleString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Data.DateTimeOffsetJsonConverter">
            <summary>
            <b>Newtonsoft:</b> Implements a type converter for <see cref="T:System.DateTimeOffset"/> using the culture
            invariant <b>yyyy-MM-ddTHH:mm:ss.fffzzz</b> format.
            </summary>
        </member>
        <member name="P:Neon.Data.DateTimeOffsetJsonConverter.Type">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.DateTimeOffsetJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.DateTimeOffset,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.DateTimeOffsetJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.DateTimeOffset,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.DateTimeOffsetJsonConverter.ToSimpleString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Data.IEnhancedJsonConverter">
            <summary>
            <para>
            <b>Newtonsoft:</b> Extends the standard <see cref="T:Newtonsoft.Json.JsonConverter"/> by returning the type
            handled by the converter.
            </para>
            <note>
            <see cref="T:Newtonsoft.Json.JsonConverter"/> classes need to implement this interface to be
            automatically supported by classes generated by <b>Neon.ModelGen</b>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Data.IEnhancedJsonConverter.Type">
            <summary>
            Returns the type handled by the converter.
            </summary>
        </member>
        <member name="M:Neon.Data.IEnhancedJsonConverter.ToSimpleString(System.Object)">
            <summary>
            Converts an object instance to a simple (non-JSON) string.
            </summary>
            <param name="instance">The object instance.</param>
            <returns>The rendered string.</returns>
        </member>
        <member name="T:Neon.Data.IntegerEnumConverter`1">
            <summary>
            <b>Newtonsoft:</b> Implements a type converter that converts between integers and an enum type.
            </summary>
            <typeparam name="TEnum">The enumation type being converted.</typeparam>
            <remarks>
            <note>
            This works for both string and integer values and we don't ensure that 
            an integer input value actually corresponds to an enum value, we just cast
            the integer.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Data.IntegerEnumConverter`1.CanConvert(System.Type)">
            <summary>
            Determines whether the converter is able to convert a value of a specific type.
            </summary>
            <param name="objectType">The value type.</param>
            <returns><c>true</c> if the type can be converted.</returns>
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.IntegerEnumConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes an integer or enum value as an integer.
            </summary>
            <param name="writer">The writer.</param>
            <param name="value">The value.</param>
            <param name="serializer">The serializer.</param>
            <remarks>
            <note>
            The <paramref name="serializer"/> parameter is ignored.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Data.IntegerEnumConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads an integer or enum value as a enum.
            </summary>
            <param name="reader">The reader.</param>
            <param name="objectType">The value type.</param>
            <param name="existingValue">The existing value.</param>
            <param name="serializer">The serializer.</param>
            <returns>The value read.</returns>
            <remarks>
            <note>
            The <paramref name="serializer"/> parameter is ignored.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Data.TimeSpanJsonConverter">
            <summary>
            <para>
            Implements a type converter for <see cref="T:System.TimeSpan"/> using the culture
            invariant <b>"c"</b> format.  This serializes <see cref="T:System.TimeSpan"/> instances
            as:
            </para>
            <code>
            [-][d'.']hh':'mm':'ss['.'fffffff]
            </code>
            </summary>
        </member>
        <member name="P:Neon.Data.TimeSpanJsonConverter.Type">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.TimeSpanJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.TimeSpan,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.TimeSpanJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.TimeSpan,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.TimeSpanJsonConverter.ToSimpleString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Data.VersionJsonConverter">
            <summary>
            Implements a type converter for <see cref="T:System.Version"/>.
            </summary>
        </member>
        <member name="P:Neon.Data.VersionJsonConverter.Type">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.VersionJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Version,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.VersionJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Version,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.VersionJsonConverter.ToSimpleString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Data.IGeneratedServiceClient">
            <summary>
            Used to identify a generated ASP.NET service client.
            </summary>
        </member>
        <member name="P:Neon.Data.IGeneratedServiceClient.GeneratorVersion">
            <summary>
            <para>
            Returns the version of the <b>Neon.ModelGen</b> assembly that generated
            this code plus the generated code schema version.  This is formatted like:
            </para>
            <code>
            SEMANTIC-VERSION:SCHEMA
            </code>
            <para>
            where SCHEMA-VERSION is the <b>Neon.ModelGen</b> assembly version and
            SCHEMA is a simple integer schema version number.  The version will be
            incremented if or when the code generated by future versions of the
            <b>Neon.ModelGen</b> assembly changes enough to become incompatible
            with older versions of the <b>Neon.Xunit.XunitExtensions.ValidateController()</b>
            method.  This is likely to never change, but future proofing is always
            a good idea.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Data.IPersistableType">
            <summary>
            Non generic interface describing an entity that can be persisted to a database.
            See <see cref="T:Neon.Data.IPersistableType`1"/> for more information.
            </summary>
        </member>
        <member name="M:Neon.Data.IPersistableType.GetKey">
            <summary>
            <para>
            Returns the Couchbase or other database key to be used to persist or retrieve the entity.
            By convention for Couchbase, this key includes the entity type plus the unique key
            formatted like <b>entity-type</b>::<b>unique-key</b>.  For example:
            </para>
            <code>
            user::122330
            </code>
            <para>
            This identifies the document as a <b>user</b> with unique ID as <b>122330</b>.  Document
            IDs are formatted like this so that we'll be able to take advantage of document filtering
            by type when we've enabled Couchbase cross datacenter replication.
            </para>
            </summary>
            <returns>The database key for the entity.</returns>
        </member>
        <member name="M:Neon.Data.IPersistableType.__Load(Newtonsoft.Json.Linq.JObject,System.Boolean)">
            <summary>
            Loads the entity properties from the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>
            or from the optional <see cref="T:Newtonsoft.Json.Linq.JObject"/> passed.
            </summary>
            <param name="source">Optional source object.</param>
            <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        </member>
        <member name="M:Neon.Data.IPersistableType.__Save">
            <summary>
            Persists the object properties to the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <returns>The backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</returns>
        </member>
        <member name="P:Neon.Data.IPersistableType.__T">
            <summary>
            Identifies the entity type.
            </summary>
        </member>
        <member name="T:Neon.Data.IPersistableType`1">
            <summary>
            Generic interface describing an entity that can be persisted to a database.
            </summary>
            <typeparam name="T">Specifies the data type being persisted.</typeparam>
            <remarks>
            <para>
            All entities must implement the <see cref="P:Neon.Data.IPersistableType.__T"/> property such that it returns
            the bucket unique string that identifies the entity type.  This string will be
            used to distinguish entity types within a Couchbase bucket.
            </para>
            <para>
            This interface supports the related concepts of entity <b>key</b> and <b>ref</b>.  The
            entity key is the string used to persist an entity instance to Couchbase.  By
            convention, this string is generally prefixed by the entity type and then is
            followed by instance specific properties, a UUID, or a singleton name.
            </para>
            <para>
            Entity <b>ref</b> is the value that other entities can use to reference an entity instance.
            This could be the same as the entity <b>key</b> but typically without the entity
            type prefix for brevity,
            </para>
            <para>
            As a convention, many <see cref="T:Neon.Data.IPersistableType`1"/> implementations also have a <c>static</c>
            <b>GetKey(...)</b> method that returns the Couchbase key for an entity based on parameters passed.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Data.IRoundtripData">
            <summary>
            Used by the <b>Neon.ModelGen</b> assembly to indicate that a class
            was generated as a round-trip data model.
            </summary>
        </member>
        <member name="M:Neon.Data.IRoundtripData.ToString(System.Boolean)">
            <summary>
            Renders the instance as JSON text, optionally formatting the output.
            </summary>
            <param name="indented">Optionally pass <c>true</c> to format the output.</param>
            <returns>The serialized JSON string.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.ToJObject">
            <summary>
            Renders the instance as a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <returns>The new <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.ToBytes">
            <summary>
            Renders the instance as UTF-8 encoded JSON.
            </summary>
            <returns>The serialized JSON bytes.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.__Load(Newtonsoft.Json.Linq.JObject,System.Boolean)">
            <summary>
            Loads the instance properties from the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/> or
            the optional <paramref name="source"/> parameter.
            </summary>
            <param name="source">The optional source <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        </member>
        <member name="M:Neon.Data.IRoundtripData.__Save">
            <summary>
            Persists the instance properties to the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <returns>The backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.WriteJsonTo(System.IO.Stream)">
            <summary>
            Writes the instance as JSON to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:Neon.Data.IRoundtripData.WriteJsonToAsync(System.IO.Stream)">
            <summary>
            Asynchronously writes the instance as JSON to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The output stream.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Data.NamespaceDoc">
            <summary>
            This namespace defines some data converters as well as types and interfaces supporting ModelGen generated data types.
            </summary>
        </member>
        <member name="T:Neon.Data.NotifyPropertyChanged">
            <summary>
            A common implementation of <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            </summary>
        </member>
        <member name="E:Neon.Data.NotifyPropertyChanged.PropertyChanged">
            <summary>
            Raised when an instance property value has changed.
            </summary>
        </member>
        <member name="M:Neon.Data.NotifyPropertyChanged.RaisePropertyChanged(System.String)">
            <summary>
            Derived classes will call this when a property instance property value has changed.
            </summary>
            <param name="propertyName">
            The optional property name.  This defaults to the name of the caller, typically
            the property's setter.  This may also be passed as <c>null</c> signalling that
            all instance properties may have changed.
            </param>
        </member>
        <member name="T:Neon.Data.RoundtripDataFactory">
            <summary>
            Used to instantiate code generated classes that implement <see cref="T:Neon.Data.IRoundtripData"/>
            as generated by the <c>Neon.ModelGen</c> assembly.
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom``1(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Constructs an instance of <typeparamref name="TResult"/> from a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="jObject">The source <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <returns>The new <typeparamref name="TResult"/> instance.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom(System.Type,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Constructs an instance of <paramref name="resultType"/> from a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="jObject">The source <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <returns>The new instance as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom``1(System.Byte[])">
            <summary>
            Constructs an instance of <typeparamref name="TResult"/> from a byte array.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="bytes">The source bytes.</param>
            <returns>The new <typeparamref name="TResult"/> instance.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom(System.Type,System.Byte[])">
            <summary>
            Constructs an instance of <paramref name="resultType"/> from a byte array.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="bytes">The source bytes.</param>
            <returns>The new instance as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFromAsync(System.Type,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs an instance of <paramref name="resultType"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="stream">The source <see cref="T:System.IO.Stream"/>.</param>
            <param name="encoding">Optionally specifies the encoding (defaults to UTF-8).</param>
            <returns>The new instance as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.TryCreateFromAsync(System.Type,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Attempts to construct an instance of <paramref name="resultType"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="stream">The source <see cref="T:System.IO.Stream"/>.</param>
            <param name="encoding">Optionally specifies the encoding (defaults to UTF-8).</param>
            <returns>
            <c>true</c> if the object type implements <see cref="T:Neon.Data.IRoundtripData"/> and the 
            object was successfully deserialized.
            </returns>
        </member>
        <member name="T:Neon.Data.RoundtripDataHelper">
            <summary>
            Serialization related helpers used by the code generated
            by the <b>Neon.ModelGen</b> library.
            </summary>
        </member>
        <member name="F:Neon.Data.RoundtripDataHelper.NoHashPropertiesError">
            <summary>
            The error message used when <see cref="M:System.Object.GetHashCode"/> is called on
            a generated data model that has no properties tagged with [HashSource].
            </summary>
        </member>
        <member name="P:Neon.Data.RoundtripDataHelper.Serializer">
            <summary>
            Returns the Json global serializer.
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.PersistableInitialize">
            <summary>
            <para>
            This examines all loaded assemblies, looking for classes that implement <see cref="T:Neon.Data.IPersistableType"/>
            and then calling each matching type's <c>static PersistableInitialize()</c>  method to ensure that
            the class' type filter is registered with <b>Linq2Couchbase</b>.
            </para>
            <note>
            This method scans the assemblies only the first time the method is called.  Subsequent calls will
            jsut return without doing anything.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.Serialize(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes a value to JSON text.
            </summary>
            <param name="value">The the value to be serialized.</param>
            <param name="format">Optionally format the output.</param>
            <returns>The JSON text.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.Deserialize``1(System.String)">
            <summary>
            Deserializes a value from JSON text.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="jsonText">The JSON text.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.FromObject(System.Object,System.Type,System.String)">
            <summary>
            Used to convert a value into a <see cref="T:Newtonsoft.Json.Linq.JToken"/> suitable for
            assigning as a property to the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/> of
            a generated data model
            </summary>
            <param name="value">The value being assigned.</param>
            <param name="objectType">The generated data model type.</param>
            <param name="propertyName">The property name.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.GetPersistedKey(System.String,System.Object[])">
            <summary>
            Generates an database key for a persisted entity from one or more arguments.
            </summary>
            <param name="persistedType">The entity type string.</param>
            <param name="args">Arguments identifying the entity.</param>
            <returns>The generated database key.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.DeepClone(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Returns a deep clone of a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <param name="jObject">The <see cref="T:Newtonsoft.Json.Linq.JObject"/> or <c>null</c>.</param>
            <returns>The cloned instance.</returns>
        </member>
        <member name="T:Neon.Deployment.DownloadManifest">
            <summary>
            Describes a download including its parts
            </summary>
        </member>
        <member name="M:Neon.Deployment.DownloadManifest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadManifest.Name">
            <summary>
            Identifies the download.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadManifest.Version">
            <summary>
            The download version (this may be <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadManifest.Filename">
            <summary>
            The download file name.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadManifest.Size">
            <summary>
            The overall size of the download.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadManifest.Md5">
            <summary>
            The MD5 hash for the entire download.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadManifest.Parts">
            <summary>
            The download parts.
            </summary>
        </member>
        <member name="T:Neon.Deployment.DownloadPart">
            <summary>
            Downloads may be split into one or more parts.  This class includes the
            zero-based part <see cref="P:Neon.Deployment.DownloadPart.Number"/> which specifies the order in which
            this part will be assembled back into the reconsitituted download.  The
            class also includes the <see cref="P:Neon.Deployment.DownloadPart.Uri"/> used to retrieve the part,
            the part <see cref="P:Neon.Deployment.DownloadPart.Size"/>, as well as the optional <see cref="P:Neon.Deployment.DownloadPart.Md5"/>
            has for the part.
            </summary>
        </member>
        <member name="M:Neon.Deployment.DownloadPart.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadPart.Number">
            <summary>
            The zero-based index specifying where this part will be assembled
            back into the reconsitituted download.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadPart.Uri">
            <summary>
            The URI to the part data.
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadPart.Size">
            <summary>
            Actual size of the part in bytes after being downloaded. 
            </summary>
        </member>
        <member name="P:Neon.Deployment.DownloadPart.Md5">
            <summary>
            Optionally set to the MD5 hash of the part data (without any compression).
            </summary>
        </member>
        <member name="T:Neon.Deployment.DownloadProgressDelegate">
            <summary>
            Describes the callback used to monitor and possibly cancel the download of file composed of
            one or more parts specified by a <see cref="T:Neon.Deployment.DownloadManifest"/>.
            </summary>
            <param name="progressType">Passed indicating the current operation being performed.</param>
            <param name="percentComplete">Passed as the approximate percentage of the file downloaded (between 0..100).</param>
            <returns><c>true</c> if the download is to continue or <c>false</c> to cancel it.</returns>
        </member>
        <member name="T:Neon.Deployment.DownloadProgressType">
            <summary>
            Enumerates the types of progress indications raised when downloading a multi-part
            file specified by a <see cref="T:Neon.Deployment.DownloadManifest"/>.
            </summary>
        </member>
        <member name="F:Neon.Deployment.DownloadProgressType.Check">
            <summary>
            An existing local file is being verified.
            </summary>
        </member>
        <member name="F:Neon.Deployment.DownloadProgressType.Download">
            <summary>
            The file is being downloaded.
            </summary>
        </member>
        <member name="T:Neon.Deployment.IProfileClient">
            <summary>
            Defines the interface for the client used to communicate with the Neon Assistant
            or a custom service.  These services provides access to user and workstation specific 
            settings including secrets and general properties.  This is used for activities such as 
            CI/CD automation and integration testing.
            </summary>
            <remarks>
            <para>
            Implementations of this interface address the following scenarios:
            </para>
            <list type="bullet">
            <item>
            <para>
            Gaining access to secrets.  NEONFORGE has standardized on 1Password for password management
            and the Neon Profile Service abstracts the details of authenticating with 1Password and
            accessing secrets.
            </para>
            <para>
            This interface supports two kinds of secrets: passwords and values.  These are somewhat 
            of an artifact of how we implemented this using 1Password.  Secret passwords are values
            retrieved from a 1Password item's <b>password field</b> and secret values correspond to
            a 1Password item <b>value field.</b>  We found this distinction useful because 1Password
            reports when passwords are insecure or duplicated but we have other secrets where these
            checks can be distracting.  Custom implementation can choose to follow this pattern or
            just treat both types of secret the same.
            </para>
            <para>
            You can also obtain a specific property from a secret password or value by using this syntax:
            </para>
            <example>
            SECRETNAME[PROPERTY]
            </example>
            <para>
            This is useful for obtaining both the username and password from a login, or all of the different
            properties from a credit card, etc.  This blurs the difference between secret passwords and secret
            values a bit but we're going to retain both concepts anyway.
            </para>
            </item>
            <item>
            <para>
            Profile values are also supported.  These are non-secret name/value pairs used for describing
            the local environment as required for CI/CD.  For example, we use this for describing the
            IP addresses available for deploying a test NeonKUBE cluster.  Each developer will often
            need distict node IP addresses that work on the local LAN and also don't conflict with
            addresses assigned to other developers.
            </para>
            <para>
            NEONFORGE's internal implementation simply persists profile values on the local workstation
            as a YAML file which is referenced by our profile service.
            </para>
            </item>
            <item>
            Abstracting access to the user's master password.  NEONFORGE has implemented an internal  
            Windows application that implements a profile service that prompts the developer for their
            master 1Password, optionally caching it for a period of time so the user won't be prompted
            as often.  This server also handles profile and secret lookup.
            </item>
            </list>
            <b>Managing Sign-in:</b>
            <para>
            Some profile service implementations prompt the developer for master credentials and then
            cache these for a period of time, so the developer isn't innundated with password requests.
            </para>
            <para>
            <see cref="M:Neon.Deployment.IProfileClient.EnsureAuthenticated(System.TimeSpan)"/> can be used to have the developer sign-in the profile server, 
            optionally specifiying the number of seconds the server will remain signed-in afterwards.  This is useful
            for situations where an operation requests secrets as the operation progresses and it'll be possible 
            for the sign-in period to expire before the operation completes.
            </para>
            <note>
            We originally tried to manage this by loading any secrets at the beginning of an operation,
            so (hopefully) we'd obtain all of them while the user was still present to enter any credentials.
            This worked for operations executing as a single process, but doesn't really work well for
            operations that span multiple processess.  We tried to address this with client-side caching
            via environment variables, but that introduced other issues, so we removed caching support.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Deployment.IProfileClient.EnsureAuthenticated(System.TimeSpan)">
            <summary>
            Requests that the profile server be signed-in when it's not already signed or extend the
            sign-in period.  By default, the sign-in period will be extended by the default time configured
            for the server but this can be overridden via <paramref name="signinPeriod"/> (which comes in handy
            for operations that may take longer than the profile server default).
            </summary>
            <param name="signinPeriod">
            Optionally how long to extend the sign-in.  Passing zero (the default) or values less than zero,
            will extend the sign-in by the default sign-in period implemented by the profile server.
            </param>
            <exception cref="T:Neon.Deployment.ProfileException">Thrown if the profile server returns an error, i.e. when the server is not currently signed-in..</exception>
            <remarks>
            Profile implementations that don't required that developers sign-in when 
            secrets are requested should treat this as a NOP and just return OK.
            </remarks>
        </member>
        <member name="M:Neon.Deployment.IProfileClient.Signout">
            <summary>
            Requests that the profile server sign-out from it's credential source.
            </summary>
        </member>
        <member name="M:Neon.Deployment.IProfileClient.GetSecretPassword(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Requests the value of a secret password from 1Password via the assistant.
            </summary>
            <param name="name">Specifies the secret name.</param>
            <param name="vault">Optionally specifies the 1Password vault.  This defaults to the current user (as managed by the <see cref="T:Neon.Deployment.IProfileClient"/> implementaton).</param>
            <param name="masterPassword">Optionally specifies the master 1Password when it is already known.</param>
            <param name="nullOnNotFound">Optionally specifies that <c>null</c> should be returned rather than throwing an exception when the secret does not exist.</param>
            <returns>The password value.</returns>
            <exception cref="T:Neon.Deployment.ProfileException">Thrown if the profile server returns an error.</exception>
        </member>
        <member name="M:Neon.Deployment.IProfileClient.GetSecretValue(System.String,System.String,System.String,System.Boolean)">
            <summary>
             Requests the value of a secret value from 1Password via the assistant.
            </summary>
            <param name="name">Specifies the secret name.</param>
            <param name="vault">Optionally specifies the 1Password vault.  This defaults to the current user (as managed by the <see cref="T:Neon.Deployment.IProfileClient"/> implementaton).</param>
            <param name="masterPassword">Optionally specifies the master 1Password when it is already known.</param>
            <param name="nullOnNotFound">Optionally specifies that <c>null</c> should be returned rather than throwing an exception when the secret does not exist.</param>
            <returns>The password value.</returns>
            <exception cref="T:Neon.Deployment.ProfileException">Thrown if the profile server returns an error.</exception>
        </member>
        <member name="M:Neon.Deployment.IProfileClient.GetProfileValue(System.String,System.Boolean)">
            <summary>
            Requests a profile value from the assistant.
            </summary>
            <param name="name">Identifies the profile value.</param>
            <param name="nullOnNotFound">Optionally specifies that <c>null</c> should be returned rather than throwing an exception when the profile value does not exist.</param>
            <returns>The password value.</returns>
            <exception cref="T:Neon.Deployment.ProfileException">Thrown if the profile server returns an error.</exception>
        </member>
        <member name="T:Neon.Deployment.IProfileRequest">
            <summary>
            Abstracts Neon Profile Service named pipe command requests.
            </summary>
        </member>
        <member name="P:Neon.Deployment.IProfileRequest.Command">
            <summary>
            Returns the command.
            </summary>
        </member>
        <member name="P:Neon.Deployment.IProfileRequest.Args">
            <summary>
            Returns the standard command arguments.
            </summary>
        </member>
        <member name="T:Neon.Deployment.IProfileResponse">
            <summary>
            Abstracts Neon Profile Service named pipe command responses.
            </summary>
        </member>
        <member name="P:Neon.Deployment.IProfileResponse.Success">
            <summary>
            Retrurns <c>true</c> for successful requests, <c>false</c> for failed ones.
            </summary>
        </member>
        <member name="P:Neon.Deployment.IProfileResponse.Value">
            <summary>
            Returns the response string (for non-JSON responses).
            </summary>
        </member>
        <member name="P:Neon.Deployment.IProfileResponse.JObject">
            <summary>
            Returns the <see cref="P:Neon.Deployment.IProfileResponse.JObject"/> for JSON responses.
            </summary>
        </member>
        <member name="P:Neon.Deployment.IProfileResponse.Error">
            <summary>
            Returns the error message for failed requests.
            </summary>
        </member>
        <member name="T:Neon.Deployment.ProfileException">
            <summary>
            Thrown by <see cref="T:Neon.Deployment.IProfileClient"/> instance when the profile server
            returned an error.
            </summary>
        </member>
        <member name="M:Neon.Deployment.ProfileException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The error message.</param>
            <param name="status">
            Pass as one of the <see cref="T:Neon.Deployment.ProfileStatus"/> values indicating the
            reason for the failure.
            </param>
            <param name="inner">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Deployment.ProfileException.Status">
            <summary>
            Returns one of the <see cref="T:Neon.Deployment.ProfileStatus"/> values indicating the
            reason for the failure.
            </summary>
        </member>
        <member name="T:Neon.Deployment.ProfileStatus">
            <summary>
            Enumerates the profile error code strings.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.OK">
            <summary>
            The request completed successfully.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.Connect">
            <summary>
            Unable to establish a connection with to the profile server.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.NotReady">
            <summary>
            The profile server is running but it's not ready to accept requests.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.BadRequest">
            <summary>
            The request is malformed.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.MissingArg">
            <summary>
            The request is missing one or more required arguments.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.BadCommand">
            <summary>
            The request command is unknown.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.BadArgument">
            <summary>
            A request argument is invalid..
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.NotFound">
            <summary>
            A secret or profile value could not be found.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.Aborted">
            <summary>
            The user aborted the operation.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.Timeout">
            <summary>
            The operation timed-out.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.BadReference">
            <summary>
            The profile or secret reference is malformed.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.OnePasswordUnavailable">
            <summary>
            The 1Password backend service is not available.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.CallError">
            <summary>
            An arbitrary call to the profile server failed.
            </summary>
        </member>
        <member name="F:Neon.Deployment.ProfileStatus.Other">
            <summary>
            An onspecified error occurred.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.AssertException">
            <summary>
            Thrown by <see cref="M:System.Diagnostics.Contracts.Covenant.Assert(System.Boolean,System.String)"/> to signal logic failures.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.AssertException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.AssertException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs an assertion with a specific message and optional inner exception.
            </summary>
            <param name="message">The custom message.</param>
            <param name="innerException">Optional inner exception.</param>
        </member>
        <member name="T:Neon.Diagnostics.AttributeLogger">
            <summary>
            <para>
            Used for holding a collection of attributes to be included in all logged events.
            This is a very convienient way to ensure that all events logged will share
            a common set of attributes.  This comes with at a performance cost (see the remarks).
            </para>
            <note>
            <para>
            <b>IMPORTANT:</b> You must use the extended <see cref="T:Microsoft.Extensions.Logging.ILogger"/> logging extensions
            like <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})"/>
            for any attributes added to a <see cref="T:Neon.Diagnostics.AttributeLogger"/> instance to be included in the
            log output
            </para>
            <para>
            We recommend that developers consider switch to using our extended logging methods
            from the stock .NET extensions <see cref="T:Microsoft.Extensions.Logging.LoggerExtensions"/>.
            Not only do the NeonSDK <see cref="T:Neon.Diagnostics.LoggerExtensions"/> interoperate
            with the <see cref="T:Neon.Diagnostics.AttributeLogger"/>, we believe our extensions are easier to use,
            especially when specifying attributes.  We also have overrides that make it efficient
            to use string interpolation for generating log messages.
            </para>
            </note>
            </summary>
            <remarks>
            <para>
            This functionally potentially comes at the cost of extra memory allocations
            which could bog down applications that do a lot of logging.  This problem
            surfaces when combining attributes associated with a <see cref="T:Neon.Diagnostics.AttributeLogger"/>
            instance with event attributes.  This won't be an issue if either the logger or
            logged events don't have any attributes.
            </para>
            <para>
            When attributes need to be merged and a <b>null formatter</b> is passed, then this method
            will perform one additional allocation for the combined attribute list.
            </para>
            <para>
            When attributes need to be merged and a <b>non-null formatter</b> is passed, then this method
            will perform three additional allocations: one for the combined attribute list, one
            one for a wrapped formatter function, and one for a closure within thew wrapped
            function.
            </para>
            <para>
            I'd bet that custom formatters are pretty rare in the wild, so this means that
            combining attributes will generally require only a single additional allocation,
            which isn't too bad.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.AttributeLogger.#ctor(Microsoft.Extensions.Logging.ILogger,Neon.Diagnostics.LogAttributes)">
            <summary>
            Constructor.
            </summary>
            <param name="logger">Specifies the logger being wrapped.</param>
            <param name="attributes">Specifies to attributes to be included in events logged to the instance.</param>
            <remarks>
            <note>
            We do not support wrapping another <see cref="T:Neon.Diagnostics.AttributeLogger"/> instance.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Diagnostics.AttributeLogger.Attributes">
            <summary>
            Returns the attributes associated with the logger..
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.AttributeLogger.BeginScope``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.AttributeLogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.AttributeLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.ConfigExtensions">
            <summary>
            Implements extension methods used for configuring <see cref="N:Neon.Diagnostics"/> related 
            exporters and processors.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.ConfigExtensions.AddConsoleJsonExporter(OpenTelemetry.Logs.OpenTelemetryLoggerOptions,System.Action{Neon.Diagnostics.ConsoleJsonLogExporterOptions})">
            <summary>
            Adds a <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/> to a <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> instance
            when configuring a OpenTelemetry pipeline.
            </summary>
            <param name="loggerOptions">The <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> options to where the exporter will be added.</param>
            <param name="configure">Exporter configuration options.</param>
            <returns>The <paramref name="loggerOptions"/> to enable fluent style programming.</returns>
        </member>
        <member name="M:Neon.Diagnostics.ConfigExtensions.AddConsoleTextExporter(OpenTelemetry.Logs.OpenTelemetryLoggerOptions,System.Action{Neon.Diagnostics.ConsoleTextLogExporterOptions})">
            <summary>
            Adds a <see cref="T:Neon.Diagnostics.ConsoleTextLogExporter"/> to a <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> instance
            when configuring a OpenTelemetry pipeline.
            </summary>
            <param name="loggerOptions">The <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> options to where the exporter will be added.</param>
            <param name="configure">Exporter configuration options.</param>
            <returns>The <paramref name="loggerOptions"/> to enable fluent style programming.</returns>
        </member>
        <member name="M:Neon.Diagnostics.ConfigExtensions.AddFileExporter(OpenTelemetry.Logs.OpenTelemetryLoggerOptions,System.Action{Neon.Diagnostics.FileLogExporterOptions})">
            <summary>
            Adds a <see cref="T:Neon.Diagnostics.FileLogExporter"/> to a <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> instance
            when configuring a OpenTelemetry pipeline.
            </summary>
            <param name="loggerOptions">The <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> options to where the exporter will be added.</param>
            <param name="configure">Exporter configuration options.</param>
            <returns>The <paramref name="loggerOptions"/> to enable fluent style programming.</returns>
        </member>
        <member name="M:Neon.Diagnostics.ConfigExtensions.AddLogAsTraceProcessor(OpenTelemetry.Logs.OpenTelemetryLoggerOptions,System.Action{Neon.Diagnostics.LogAsTraceProcessorOptions})">
            <summary>
            Adds a <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/> to a <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> instance
            when configuring a OpenTelemetry pipeline.
            </summary>
            <param name="loggerOptions">The <see cref="T:OpenTelemetry.Logs.OpenTelemetryLoggerOptions"/> options to where the exporter will be added.</param>
            <param name="configure">Exporter configuration options.</param>
            <returns>The <paramref name="loggerOptions"/> to enable fluent style programming.</returns>
        </member>
        <member name="T:Neon.Diagnostics.ConsoleJsonLogExporter">
            <summary>
            <para>
            Exports log records to the console where each record will be written
            as a line of JSON text to standard output and/or standard error when
            configured.
            </para>
            <para>
            This is suitable for production environments like Kubernetes, Docker,
            etc. where logs are captured from the program output.
            </para>
            </summary>
            <remarks>
            <para>
            <b>IMPORTANT:</b> To enable the inclusion of log tags in the output JSON, you must
            set <see cref="P:OpenTelemetry.Logs.OpenTelemetryLoggerOptions.ParseStateValues"/><c>=true</c> when
            configuring your OpenTelemetry options.  This is is <c>false</c> by default.
            </para>
            <code language="C#">
            var loggerFactory = LoggerFactory.Create(
                builder =>
                {
                    builder.AddOpenTelemetry(
                        options =>
                        {
                            options.ParseStateValues = true;    // &lt;--- SET THIS TO TRUE
                            
                            options.SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(serviceName: ServiceName, serviceVersion: ServiceVersion));
                            options.AddLogAsTraceProcessor(options => options.LogLevel = LogLevel.Warning);
                            options.AddConsoleJsonExporter();
                        });
                });
            </code>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.ConsoleJsonLogExporter.#ctor(Neon.Diagnostics.ConsoleJsonLogExporterOptions)">
            <summary>
            Constructs a log exporter that writes log records to standard output and/or
            standard error as single line JSON objects.
            </summary>
            <param name="options">Optionally specifies the exporter options.</param>
        </member>
        <member name="M:Neon.Diagnostics.ConsoleJsonLogExporter.Export(OpenTelemetry.Batch{OpenTelemetry.Logs.LogRecord}@)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.ConsoleJsonLogExporterOptions">
            <summary>
            Specifies the options used to configure a <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.ConsoleJsonLogExporterOptions.#ctor">
            <summary>
            Constructs an instance with reasonable settings.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.Emit">
            <summary>
            <para>
            Used to disable writing events to the output stream.  This can be useful for
            unit testing.  This is enabled by default.
            </para>
            <note>
            Any configured <see cref="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.LogEventInterceptor"/> actions will still be called
            event when <see cref="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.Emit"/> is configured as <c>false</c>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.EmitToAttachedDebugger">
            <summary>
            Used to disable writing logs to an attached debugger's output window.  This
            is enabled by default.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.StandardErrorLevel">
            <summary>
            Used to direct log output for events to <b>standard error</b> based on the
            event log level.
            </summary>
            <remarks>
            <para>
            By default, <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/> writes logs to <b>standard output</b>
            because this property defaults to <see cref="F:Microsoft.Extensions.Logging.LogLevel.None"/>.  You may override this
            by setting this to another level; then events with log levels &gt;= this property will 
            be written to <b>standard error</b> instead.
            </para>
            <para>
            Set this to <see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/> to send all logs to <b>standard output</b>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.SingleLine">
            <summary>
            <para>
            Specifies whether the log event JSON written to the console should be formatted as single 
            lines of JSON (the default) or render these as indented multi-line JSON separated by
            a blank line.
            </para>
            <note>
            This may be useful for debugging but should probably never be used for production.  This
            defaults to <c>true</c>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.ExceptionStackTraces">
            <summary>
            Specifies whether exception stack traces should be included in logged events.
            This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.LogEventInterceptor">
            <summary>
            <para>
            Used to intercept log events just before they are emitted by the exporter.  You can
            use this for implementing logging related unit tests or modifying other event properties 
            like the timestamp, labels, tags, etc.
            </para>
            <note>
            <b>IMPORTANT:</b> <see cref="T:Neon.Diagnostics.LogEvent"/> record instances are reused by the Neon telemetry
            code, so you'll need to call <see cref="M:Neon.Diagnostics.LogEvent.Clone"/> when you're using the interceptor
            to collected logged events for later analysis (i.e. when unit testing).
            </note>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.StdOutInterceptor">
            <summary>
            Used internally by unit tests to intercept JSON records emitted to <b>standard output</b>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleJsonLogExporterOptions.StdErrInterceptor">
            <summary>
            Used internally by unit tests to intercept JSON records emitted to <b>standard error</b>.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.ConsoleTextLogExporter">
            <summary>
            <para>
            Exports log records to the console where each record will be written
            as a line of text to standard output and/or standard error when
            configured.
            </para>
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.ConsoleTextLogExporter.#ctor(Neon.Diagnostics.ConsoleTextLogExporterOptions)">
            <summary>
            Constructs a log exporter that writes log records to standard output and/or
            standard error as single lines.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.ConsoleTextLogExporter.Export(OpenTelemetry.Batch{OpenTelemetry.Logs.LogRecord}@)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.ConsoleTextLogExporterOptions">
            <summary>
            Specifies the options used to configure a <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.ConsoleTextLogExporterOptions.#ctor">
            <summary>
            Constructs an instance with reasonable settings.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.Emit">
            <summary>
            <para>
            Used to disable writing events to the output stream.  This can be useful for
            unit testing.  This is enabled by default.
            </para>
            <note>
            Any configured <see cref="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.LogEventInterceptor"/> actions will still be called
            event when <see cref="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.Emit"/> is configured as <c>false</c>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.EmitToAttachedDebugger">
            <summary>
            Used to disable writing logs to an attached debugger's output window.  This
            is enabled by default.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.StandardErrorLevel">
            <summary>
            Used to direct log output for events to <b>standard error</b> based on the
            event log level.
            </summary>
            <remarks>
            <para>
            By default, <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/> writes logs to <b>standard output</b>
            because this property defaults to <see cref="F:Microsoft.Extensions.Logging.LogLevel.None"/>.  You may override this
            by setting this to another level; then events with log levels &gt;= this property will 
            be written to <b>standard error</b> instead.
            </para>
            <para>
            Set this to <see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/> to send all logs to <b>standard output</b>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.ExceptionStackTraces">
            <summary>
            Specifies whether exception stack traces should be included in logged events.
            This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.LogEventInterceptor">
            <summary>
            <para>
            Used to intercept log events just before they are emitted by the exporter.  You can
            use this for implementing logging related unit tests or modifying other event properties 
            like the timestamp, labels, tags, etc.
            </para>
            <note>
            <b>IMPORTANT:</b> <see cref="T:Neon.Diagnostics.LogEvent"/> record instances are reused by the Neon telemetry
            code, so you'll need to call <see cref="M:Neon.Diagnostics.LogEvent.Clone"/> when you're using the interceptor
            to collected logged events for later analysis (i.e. when unit testing).
            </note>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.StdOutInterceptor">
            <summary>
            Used internally by unit tests to intercept JSON records emitted to <b>standard output</b>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.StdErrInterceptor">
            <summary>
            Used internally by unit tests to intercept JSON records emitted to <b>standard error</b>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ConsoleTextLogExporterOptions.Format">
            <summary>
            Used to set the log format.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.DiagnosticsHelper">
            <summary>
            Internal helpers.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.DiagnosticsHelper.SeverityInfo">
            <summary>
            Used to map .NET log levels to OpenTelemetry severity names and numbers.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.DiagnosticsHelper.SeverityInfo.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The standard OpenTelemetry severity name.</param>
            <param name="number">The standard OpenTelemetry severity number.</param>
        </member>
        <member name="P:Neon.Diagnostics.DiagnosticsHelper.SeverityInfo.Name">
            <summary>
            Returns the standard OpenTelemetry severity name.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.DiagnosticsHelper.SeverityInfo.Number">
            <summary>
            Returns the standard OpenTelementry severity number.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.DiagnosticsHelper.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.DiagnosticsHelper.GetSeverityInfo(Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            Maps a .NET log level to information about the related standard OpenTelemetry
            severity name and number.
            </summary>
            <param name="logLevel">The .NET log level.</param>
            <returns>A <see cref="T:Neon.Diagnostics.DiagnosticsHelper.SeverityInfo"/> with the OpenTelemetry information.</returns>
        </member>
        <member name="M:Neon.Diagnostics.DiagnosticsHelper.SetLogEvent(OpenTelemetry.BaseExporter{OpenTelemetry.Logs.LogRecord},System.Boolean,OpenTelemetry.Logs.LogRecord,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},Neon.Diagnostics.LogEvent)">
            <summary>
            Converts a <see cref="T:OpenTelemetry.Logs.LogRecord"/> into a <see cref="T:Neon.Diagnostics.LogEvent"/>.  This is used
            internally by our custom log exporters.  This method is designed to be called
            within a batch export loop and reuses a <see cref="T:Neon.Diagnostics.LogEvent"/> instances as well
            as tag and resource dictionaries to reduce GC pressure.
            </summary>
            <param name="exporter">The exporter.</param>
            <param name="includeStackTrace">Controls whether exception stack traces are include.</param>
            <param name="record">The input record.</param>
            <param name="resources">Passed as an allocated temporary dictionary used for rendering resources.</param>
            <param name="tags">Passed as an allocated temporary dictionary used for rendering tags.</param>
            <param name="logEvent">Returns as initialized from <paramref name="record"/>.</param>
        </member>
        <member name="M:Neon.Diagnostics.DiagnosticsHelper.CleanExceptionMessage(System.Exception)">
            <summary>
            Returns an exception's message cleaned of extraneous things like 
            stack traces.
            </summary>
            <param name="e">The source exception.</param>
            <returns>The cleaned message.</returns>
            <remarks>
            Some exceptions include extra stuff in their message text.  This method
            removes that and returns just the message.
            </remarks>
        </member>
        <member name="T:Neon.Diagnostics.ExceptionInfo">
            <summary>
            Used for serializing exception information.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ExceptionInfo.Type">
            <summary>
            The fully qualified exception type name.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ExceptionInfo.Message">
            <summary>
            The fully qualified exception name.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ExceptionInfo.Stack">
            <summary>
            The stack trace.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.FileLogExporterFormat">
            <summary>
            Enumerates <see cref="T:Neon.Diagnostics.FileLogExporter"/> output formats.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.FileLogExporterFormat.Human">
            <summary>
            Outputs logs in a human readable format.  This is the
            default.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.FileLogExporterFormat.Json">
            <summary>
            Outputs logs as single-line JSON.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.FileLogExporter">
            <summary>
            Exports log records to a file as specified by <see cref="T:Neon.Diagnostics.FileLogExporterOptions"/>.
            </summary>
            <remarks>
            <para>
            This exporter currently supports writing logs as JSON or a bespoke human readable 
            format (the default).  You can customize this by using options with the 
            <see cref="P:Neon.Diagnostics.FileLogExporterOptions.Format"/> to one of the <see cref="T:Neon.Diagnostics.FileLogExporterFormat"/>
            values (as shown below).
            </para>
            <para>
            <b>IMPORTANT:</b> To enable the inclusion of log tags in the output, you must
            set <see cref="P:OpenTelemetry.Logs.OpenTelemetryLoggerOptions.ParseStateValues"/><c>=true</c> when
            configuring your OpenTelemetry options.  This is is <c>false</c> by default.
            </para>
            <code language="C#">
            var loggerFactory = LoggerFactory.Create(
                builder =>
                {
                    builder.AddOpenTelemetry(
                        options =>
                        {
                            options.ParseStateValues = true;    // &lt;--- SET THIS TO TRUE
                            
                            options.SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(serviceName: ServiceName, serviceVersion: ServiceVersion));
                            options.AddFileExporter(
                                options => 
                                {
                                    options.Format      = FileLogExporterFormat.Human;
                                    options.LogFolder   = NeonHelper.GetBaseDirtectory();
                                    options.LogFileName = "MyProgram.log";
                                });
                        });
                });
            </code>
            <para>
            This exporter supports log file rotation.  This is controlled by the <see cref="P:Neon.Diagnostics.FileLogExporterOptions.FileLimit"/>
            and <see cref="P:Neon.Diagnostics.FileLogExporterOptions.MaxLogFiles"/> options.  When the current log file's size equals or exceeds
            <see cref="P:Neon.Diagnostics.FileLogExporterOptions.FileLimit"/> after writing a log event, the exporter will close and rename the
            current file by appending a timestamp and start logging to a new file named <see cref="P:Neon.Diagnostics.FileLogExporterOptions.LogFileName"/>.
            <see cref="P:Neon.Diagnostics.FileLogExporterOptions.FileLimit"/> defaults to <b>10 MiB</b> and <see cref="P:Neon.Diagnostics.FileLogExporterOptions.MaxLogFiles"/>
            defaults to retain <b>10</b> log files.
            </para>
            <para>
            The rotated files will be named like "LOGFILENAME-YYYY-MM-ddTHH-mm-ss.fffZ.EXT", where <b>LOGFILENAME</b> is the
            filename part of <see cref="P:Neon.Diagnostics.FileLogExporterOptions.LogFileName"/> and <b>EXT</b> is the extension.
            </para>
            <para>
            <see cref="P:Neon.Diagnostics.FileLogExporterOptions.MaxLogFiles"/> controls how many log files will be retained.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.FileLogExporter.#ctor(Neon.Diagnostics.FileLogExporterOptions)">
            <summary>
            Constructs a log exporter that writes log records to standard output and/or
            standard error as single line JSON objects.
            </summary>
            <param name="options">Optionally specifies the exporter options.</param>
        </member>
        <member name="M:Neon.Diagnostics.FileLogExporter.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.FileLogExporter.OnForceFlush(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.FileLogExporter.OnShutdown(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.FileLogExporter.Export(OpenTelemetry.Batch{OpenTelemetry.Logs.LogRecord}@)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.FileLogExporterOptions">
            <summary>
            Specifies the options used to configure a <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.FileLogExporterOptions.#ctor">
            <summary>
            Constructs an instance with reasonable settings.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.FileLogExporterOptions.LogFolder">
            <summary>
            Specifies the folder where the log file will be written.  This must be specified.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.FileLogExporterOptions.LogFileName">
            <summary>
            Specifies the name to use for the log file.  This must be specified.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.FileLogExporterOptions.Format">
            <summary>
            Specifies the export format.  This defaults to <see cref="F:Neon.Diagnostics.FileLogExporterFormat.Human"/>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.FileLogExporterOptions.FileLimit">
            <summary>
            Used to limit the size of log files.  The current log file will be
            rotated when its size reaches or exceeds this value.  This defaults
            to <b>10 MiB</b> and cannot be less than <b>10KiB</b>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.FileLogExporterOptions.MaxLogFiles">
            <summary>
            <para>
            Used to limit how many log files are retained.  This must be greater than zero.
            A value of one indicates that log rotation will be disabled and the current 
            log file will simply be cleared when its size exceeds <see cref="P:Neon.Diagnostics.FileLogExporterOptions.FileLimit"/>,
            effectively starting over.
            </para>
            <para>
            This defaults to <b>10</b> log files.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.FileLogExporterOptions.FlushAgressively">
            <summary>
            Controls whether the target log file will be flushed to disk after writing
            log event batch.  This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.FileLogExporterOptions.LogEventInterceptor">
            <summary>
            Used to intercept log events just before they are emitted by the exporter.  You can
            use this for implementing logging related unit tests or modifying other event properties 
            like the timestamp, labels, tags, etc.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.LogAsTraceProcessor">
            <summary>
            This OpenTelemetry processor submits any logged events that satisfy
            a log level as trace events to the current trace span (if any).  This
            is an easy way to converge logging any tracing while we're waiting for
            the OpenTelemetry folks support this natively.
            </summary>
            <remarks>
            <para>
            This is very easy to use.  Simply call <see cref="M:Neon.Diagnostics.ConfigExtensions.AddLogAsTraceProcessor(OpenTelemetry.Logs.OpenTelemetryLoggerOptions,System.Action{Neon.Diagnostics.LogAsTraceProcessorOptions})"/>,
            optionally passing options that specify the log level for events to be
            added as trace events.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogAsTraceProcessor.#cctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAsTraceProcessor.#ctor(Neon.Diagnostics.LogAsTraceProcessorOptions)">
            <summary>
            Constructs a processor that forwards logged events to the current
            trace as trace events.
            </summary>
            <param name="options">
            Optionally specifies the processor options.  This is used to filter the
            events logged to as trace events by <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.  This defaults
            to forwarding events with log levels greater than or equal to 
            <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>.
            </param>
            <remarks>
            <para>
            All log events added as events in the current span will have their name
            set to <see cref="F:Neon.Diagnostics.TelemetrySpanEventNames.Log"/> and will also include
            the log event tags but with their names prefixed by "neon.log." to avoid
            conflicts with unrelated tags.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogAsTraceProcessor.OnEnd(OpenTelemetry.Logs.LogRecord)">
            <summary>
            Handles the event forwarding.
            </summary>
            <param name="logRecord">The log record.</param>
        </member>
        <member name="T:Neon.Diagnostics.LogAsTraceProcessorOptions">
            <summary>
            Specifies the options used to configure a <see cref="T:Neon.Diagnostics.LogAsTraceProcessor"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAsTraceProcessorOptions.#ctor">
            <summary>
            Constructs an instance with reasonable settings.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogAsTraceProcessorOptions.LogLevel">
            <summary>
            <para>
            Used to filter the log events that are forwarded.  Only events with 
            log levels greater than or equal to this value will be also logged
            as trace events.
            </para>
            <para>
            This defaults to <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.LogAttributeNames">
            <summary>
            Defines attributes names used when emitting log records.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.InternalBody">
            <summary>
            Identifies our internal message body. 
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.InternalOriginalFormat">
            <summary>
            Identifies the MSFT logger implementation's attribute that holds the message format string.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.CategoryName">
            <summary>
            Identifies the MSFT logger implementation's attribute that holds the category name.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.Exception">
            <summary>
            Identifies a related exception.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.Labels">
            <summary>
            Identifies the event labels (also know as tags or attributes).
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.Resources">
            <summary>
            Identifies resources related to the event.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.Severity">
            <summary>
            Identifies the event severity by OpenTelemetry secerity name.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.SeverityNumber">
            <summary>
            Identifies the event severity by OpenTelemetry severity number.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.SpanId">
            <summary>
            Identifies the current span.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.TsNs">
            <summary>
            Identifies the event timetamp formatted as Unix Epoc nanoseconds.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.TraceId">
            <summary>
            Identifies the current trace.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.NeonTransient">
            <summary>
            <b>bool:</b> Indicates that the log event is related to a transient error.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogAttributeNames.NeonIndex">
            <summary>
            <para>
            Indicates the position of the log event in the stream of logs emitted by the 
            application.  The first event emitted by the application will have a zero
            index, and then this is incremented after every logged event.
            </para>
            <para>
            This attribute is useful for listing events in the order they were actually
            logged.  Timestamps often don't have enough resolution to distinguish between
            to events logged logged very quickly in sequence.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.LogAttributes">
            <summary>
            Holds attributes to be included in log events recorded by <see cref="T:Microsoft.Extensions.Logging.ILogger"/> 
            <see cref="T:Neon.Diagnostics.LoggerExtensions"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Neon.Diagnostics.LogAttributes"/> class.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.#ctor(Neon.Diagnostics.LogAttributes)">
            <summary>
            Initializes a new instance of the <see cref="T:Neon.Diagnostics.LogAttributes"/> class by
            cloning another <see cref="T:Neon.Diagnostics.LogAttributes"/> instance.
            </summary>
            <param name="attributes">Initial attributes to store in the collection.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Initializes a new instance of the <see cref="T:Neon.Diagnostics.LogAttributes"/> class from
            a attributes enumerable.
            </summary>
            <param name="attributes">Initial attributes to store in the collection.</param>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributes.Attributes">
            <summary>
            Returns the attribute collection.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributes.Count">
            <summary>
            Returns the number of attributes in the collection.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.Clear">
            <summary>
            Clears the attributes collection.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.Add(System.String,System.Int64)">
            <summary>
            Adds a <c>long</c> attribute.
            </summary>
            <param name="key">Attribute key.</param>
            <param name="value">Attribute value.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.Add(System.String,System.String)">
            <summary>
            Adds a <c>string</c> attribute.
            </summary>
            <param name="key">Attribute key.</param>
            <param name="value">Attribute value.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.Add(System.String,System.Boolean)">
            <summary>
            Adds a <c>bool</c> attribute.
            </summary>
            <param name="key">Attribute key.</param>
            <param name="value">Attribute value.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.Add(System.String,System.Double)">
            <summary>
            Adds a <c>double</c> attribute.
            </summary>
            <param name="key">Attribute key.</param>
            <param name="value">Attribute value.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.Add(System.String,System.Object)">
            <summary>
            Adds an arbitrary object attribute.
            </summary>
            <param name="key">Attribute key.</param>
            <param name="value">Attribute value.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.AddInternal(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Used internally to add a attribute to the collection.
            </summary>
            <param name="item">Attribute item.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributes.AddInternal(System.String,System.Object)">
            <summary>
            Used internally to add a attribute to the collection.
            </summary>
            <param name="key">Attribute key.</param>
            <param name="value">Attribute value.</param>
        </member>
        <member name="T:Neon.Diagnostics.LogAttributesCollection">
            <summary>
            LogTagsCollection is a collection class used to store tracing tags.
            This collection will be used with classes like <see cref="T:System.Diagnostics.ActivityEvent"/> and <see cref="T:System.Diagnostics.ActivityLink"/>.
            This collection behaves as follows:
                - The collection items will be ordered according to how they are added.
                - Don't allow duplication of items with the same key.
                - When using the indexer to store an item in the collection:
                    - If the item has a key that previously existed in the collection and the value is null, the collection item matching the key will be removed from the collection.
                    - If the item has a key that previously existed in the collection and the value is not null, the new item value will replace the old value stored in the collection.
                    - Otherwise, the item will be added to the collection.
                - Add method will add a new item to the collection if an item doesn't already exist with the same key. Otherwise, it will throw an exception.
            </summary>
            <remarks>
            Adapted from .NET Foundation code under their MIT license: 
            https://github.com/dotnet/runtime/blob/215b39abf947da7a40b0cb137eab4bceb24ad3e3/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/ActivityTagsCollection.cs
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.#ctor">
            <summary>
            Create a new instance of the collection.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Create a new instance of the collection and store the input list items in the collection.
            </summary>
            <param name="list">Initial list to store in the collection.</param>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributesCollection.Item(System.String)">
            <summary>
            Get or set collection item
            When setting a value to this indexer property, the following behavior will be observed:
                - If the key previously existed in the collection and the value is null, the collection item matching the key will get removed from the collection.
                - If the key previously existed in the collection and the value is not null, the value will replace the old value stored in the collection.
                - Otherwise, a new item will get added to the collection.
            </summary>
            <value>Object mapped to the key</value>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributesCollection.Keys">
            <summary>
            Get the list of the keys of all stored tags.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributesCollection.Values">
            <summary>
            Get the list of the values of all stored tags.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributesCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributesCollection.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Add(System.String,System.Object)">
            <summary>
            Adds an attribute with the provided key and value to the collection.
            This collection doesn't allow adding two attributes with the same key.
            </summary>
            <param name="key">The attribute key.</param>
            <param name="value">The attribute value.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Adds an item to the collection
            </summary>
            <param name="item">Key and value pair of the attribute to add to the collection.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.ContainsKey(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#String,System#Object}}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Remove(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.TryGetValue(System.String,System.Object@)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.FindIndex(System.String)">
            <summary>
            FindIndex finds the index of item in the list having a key matching the input key.
            We didn't use List.FindIndex to avoid the extra allocation caused by the closure when calling the Predicate delegate.
            </summary>
            <param name="key">The key to search the item in the list</param>
            <returns>The index of the found item, or -1 if the item not found.</returns>
        </member>
        <member name="T:Neon.Diagnostics.LogAttributesCollection.Enumerator">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.LogAttributesCollection.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Enumerator.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogAttributesCollection.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.LogEvent">
            <summary>
            Used for serializing the log records.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.TsNs">
            <summary>
            The event timestamp expressed as Unix Epoch nanoseconds.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.Severity">
            <summary>
            The human readable event severity level. 
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.Body">
            <summary>
            The event message.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.CategoryName">
            <summary>
            The event source category name.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.SeverityNumber">
            <summary>
            The standard OpenTelemetry event severity number.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.Attributes">
            <summary>
            The event tags.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.Resources">
            <summary>
            The related event resources.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.SpanId">
            <summary>
            The associated trace span ID.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogEvent.TraceId">
            <summary>
            The associated trace ID.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogEvent.Clone">
            <summary>
            Clones the current instance.  This is used internally when passing instances to a
            <see cref="T:Neon.Diagnostics.LogEventInterceptor"/> because our logging code reused <see cref="T:Neon.Diagnostics.LogEvent"/>
            instances to reduce GC pressure.
            </summary>
            <returns>The cloned instance.</returns>
        </member>
        <member name="T:Neon.Diagnostics.LogEventInterceptor">
            <summary>
            Use this delegate for filtering, inspecting, or modifying log events immediately
            before they are emitted by <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporter"/> or one of the
            other log exporters in the <see cref="N:Neon.Diagnostics"/> namespace.
            </summary>
            <param name="logEvent">The log event.</param>
            <remarks>
            <note>
            <b>IMPORTANT:</b> <see cref="T:Neon.Diagnostics.LogEvent"/> record instances are reused by the Neon telemetry
            code, so you'll need to call <see cref="M:Neon.Diagnostics.LogEvent.Clone"/> when you're using the interceptor
            to collected logged events for later analysis (i.e. when unit testing).
            </note>
            <para>
            You can configure an interceptor in <see cref="T:Neon.Diagnostics.ConsoleJsonLogExporterOptions"/> or
            the options for other log exporters in the <see cref="N:Neon.Diagnostics"/> namespace.
            This is useful for unit tests that verify that code is logging events correctly.
            </para>
            <para>
            You can also use this to modify the event in other ways like modifing the body,
            timestamp, labels, resources, etc. before the event is emitted.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Diagnostics.LoggerExtensions">
            <summary>
            Extends <see cref="T:Microsoft.Extensions.Logging.ILogger"/> with additional handy logging methods.  We recommend that users
            standardize on calling these logger extensions as opposed to using Microsoft's standard
            <see cref="T:Microsoft.Extensions.Logging.LoggerExtensions"/>.
            </summary>
            <remarks>
            <para><b>EVENT LOGGING:</b></para>
            <para>
            This class extends <see cref="T:Microsoft.Extensions.Logging.ILogger"/> with methods intended to be somewhat easier to
            use than Microsoft's extensions.  Our logging method names end with <b>"Ex"</b> and we
            provide methods for logging critical, error, warning, information, debug and trace events.
            We have overrides for each log level that can be used for different purposes.  We'll discuss
            the information methods below.  The methods for the other log levels folow the same pattern.
            </para>
            <para>
            The first thing to note, is that all logging methods include an optional <b>attributeSetter</b>
            parameter.  This can be set to an <see cref="T:System.Action"/> that adds arbitrary tags to the event
            when logged.  This is an easy and clean way to specify attributes, much cleaner than specifying
            a message format string as required by the <see cref="T:Microsoft.Extensions.Logging.LoggerExtensions"/>
            (e.g. there's no way to include an attribute without having it appear in the event message).
            Here's how this works:
            </para>
            <code language="C#">
            logger.LogInformationEx("Test message",
                attributes => {
                    attributes.Add("my-attr-0", "test-0");
                    attributes.Add("my-attr-1", "test-1");
                });
            </code>
            <note>
            The attributes lambda function is only called when the event is actually going to be logged, based on
            the current log level.
            </note>
            <para>
            Some of our extensions accept the message as a string and others accept a lambda function
            that returns the message string.  The general rule is that you should pass constant strings
            directly to the logging methods but strings generated at runtime via interpolation or other
            mechanisms should be specified by passing a message lambda function.
            </para>
            <note>
            The message lambda function is only called when the event is actually going to be logged, based on
            the current log level.
            </note>
            <para>
            The latter recomendation will improve performance because the lambda function won't be called
            when the event won't actually be logged due to the current log level, avoiding the overhead
            of generating the string.  Imagine if your program logged a lot of TRACE events with dynamically
            generated messages.  This means that when running at the INFORMATION log level, all of those
            trace messages would be created at runtime and then be immediately discarded, resulting in
            wasted CPU used to generate the message as well as extra heap allocations (all for nothing).
            </para>
            <code language="C#">
            // Log a static message:
            
            logger.LogInformationEx("Hello World!");
            
            // Log a dynamic message:
            
            var name = "Sally";
            
            logger.LogInformation(() => $"Hello: {name}");
            
            // YOU DON'T WANT TO DO THIS because the message string will always be generated at runtime,
            // even when the event won't be logged due to the current log level:
            
            logger.LogInformation($"Hello: {name}");
            </code>
            <para>
            <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.String,System.Action{Neon.Diagnostics.LogAttributes})"/>: Used for logging a
            constant message string.  Avoid calling this for dynamically generated messages.
            </para>
            <para>
            <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})"/>: Used for
            logging a dynamically generated message.  This will be much more efficient when the event
            isn't going to be logged due to the current log level setting.
            </para>
            <para>
            <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})"/>: Used for
            logging an exception with a constant or <c>null</c> message.  When message is passed as empty
            or <c>null</c>, a message generated from exception will be used.
            </para>
            <para>
            <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})"/>: Used
            for logging an exception with a dynamic message.  When the message function is passed <c>null</c>,
            a message generated from exception will be used.
            </para>
            <para><b>LOGGER ATTRIBUTES</b></para>
            <para>
            Use the <see cref="M:Neon.Diagnostics.LoggerExtensions.AddAttributes(Microsoft.Extensions.Logging.ILogger,System.Action{Neon.Diagnostics.LogAttributes})"/> method 
            to create a new <see cref="T:Microsoft.Extensions.Logging.ILogger"/> with new attributes such that these attributes will
            be included in subsequent events emitted by the logger.  Note that attributes logged with
            the event will override logger attributes with the same name.
            </para>
            <para>
            Here's how this works:
            </para>
            <code language="C#">
            var logger     = TelemetryHub.CreateLogger("my-logger");
            var attributes = new LogAttributes();
            
            attributes.Add("my-attr-0", "test-0");
            attributes.Add("my-attr-1", "test-1");
            
            logger = logger.AddAttributes(attributes);  // Creates a new logger including the attributes passed.
            
            logger.LogInformationEx("Test message");    // This event will include the new attributes
            
            // This example overrides the logger's "test-1" attribute with the "OVERRIDE" value:
            
            logger.LogInformationEx("Test message", attributes => attributes.Add("test-1", "OVERRIDE"));
            </code>
            <note>
            <b>IMPORTANT:</b> Any additional attributes added to the logger returned will only
            be recognized by the neondSDK logger extensions <see cref="T:Neon.Diagnostics.LoggerExtensions"/> with
            logging method names ending in <b>"Ex"</b>, like: <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})"/>.
            The standard Microsoft logger extension methods implemented by <see cref="T:Microsoft.Extensions.Logging.LoggerExtensions"/>
            will ignore these logger attributes.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.AddAttributes(Microsoft.Extensions.Logging.ILogger,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            <para>
            This wraps the logger passed with another logger that adds a colection of attributes
            to every logged event.
            </para>
            <note>
            <b>IMPORTANT:</b> Any additional attributes added to the logger returned will only
            be recognized by the neondSDK logger extensions <see cref="T:Neon.Diagnostics.LoggerExtensions"/> with
            logging method names ending in <b>"Ex"</b>, like: <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})"/>.
            The standard Microsoft logger extension methods implemented by <see cref="T:Microsoft.Extensions.Logging.LoggerExtensions"/>
            will ignore these logger attributes.
            </note>
            </summary>
            <param name="logger">The logger being wrapped.</param>
            <param name="attributeSetter">Action used to add attributes to the logger.</param>
            <returns>An <see cref="T:Microsoft.Extensions.Logging.ILogger"/> that will include the attributes in every event it logs.</returns>
            <remarks>
            This method returns a new logger that includes the attributes added by the
            <paramref name="attributeSetter"/> action.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogInternal(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Exception,System.String,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Actually emits logs, trying to do something reasonable various combinations of arguments.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="logLevel">Specifies the log level.</param>
            <param name="exception">Optionally specifies an exception.</param>
            <param name="message">Optionally specifies a message text.</param>
            <param name="messageFunc">Optionally specifies a function used to retrieve the message text.</param>
            <param name="attributeSetter">Optionally specifies a function that can add attributes to the event.</param>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWithLevelEx(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a message with the specified <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="logLevel">Specifies the <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.</param>
            <param name="message">Specifies the message.</param>
            <param name="attributeSetter">Specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWithLevelEx(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a message retrieved via a message function with the specified <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="logLevel">Specifies the <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.</param>
            <param name="messageFunc">The message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWithLevelEx(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an exception retrieved via a message function with the specified <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="logLevel">Specifies the <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.</param>
            <param name="exception">Specifies the exception.</param>
            <param name="message">Optionally specifies the event message.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWithLevelEx(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an exception with a message returned by a custom message function with the specified <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="logLevel">Specifies the <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.</param>
            <param name="exception">The exception.</param>
            <param name="messageFunc">Specifies the message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogCriticalEx(Microsoft.Extensions.Logging.ILogger,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a critical message.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="message">Specifies the message.</param>
            <param name="attributeSetter">Specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogCriticalEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a critical message retrieved via a message function.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="messageFunc">The message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogCriticalEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a critical exception.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies the exception.</param>
            <param name="message">Optionally specifies the event message.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogCriticalEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a critical exception with a message returned by a custom message function.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">The exception.</param>
            <param name="messageFunc">Specifies the message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogErrorEx(Microsoft.Extensions.Logging.ILogger,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an error message.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="message">Specifies message.</param>
            <param name="attributeSetter">Specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogErrorEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an error message retrieved via a message function.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogErrorEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an error exception.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="message">Optionally specifies the event message.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogErrorEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an error exception with a message returned by a custom message function..
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWarningEx(Microsoft.Extensions.Logging.ILogger,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a warning message.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="message">Specifies message.</param>
            <param name="attributeSetter">Specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWarningEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a warning message retrieved via a message function.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWarningEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a warning exception.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="message">Optionally specifies the event message.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogWarningEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a warning exception with a message returned by a custom message function..
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an information message.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="message">Specifies message.</param>
            <param name="attributeSetter">Specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an information message retrieved via a message function.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs an information exception.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="message">Optionally specifies the event message.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a information exception with a message returned by a custom message function..
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogDebugEx(Microsoft.Extensions.Logging.ILogger,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a debug message.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="message">Specifies message.</param>
            <param name="attributeSetter">Specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogDebugEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a debug message retrieved via a message function.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogDebugEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a debug exception.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="message">Optionally specifies the event message.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogDebugEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a debug exception with a message returned by a custom message function..
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogTraceEx(Microsoft.Extensions.Logging.ILogger,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a trace message.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="message">Specifies message.</param>
            <param name="attributeSetter">Specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogTraceEx(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a trace message retrieved via a message function.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing interpolated strings and attributes
            when the current log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogTraceEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a trace exception.
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="message">Optionally specifies the event message.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LoggerExtensions.LogTraceEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.Func{System.String},System.Action{Neon.Diagnostics.LogAttributes})">
            <summary>
            Logs a trace exception with a message returned by a custom message function..
            </summary>
            <param name="logger">Specifies the logger.</param>
            <param name="exception">Specifies exception.</param>
            <param name="messageFunc">Specifies message function.</param>
            <param name="attributeSetter">Optionally specifies an action that can be used to add attributes to the event being logged.</param>
            <remarks>
            This method is intended mostly to avoid processing attributes when the current 
            log level prevents any log from being emitted, for better performance.
            </remarks>
        </member>
        <member name="T:Neon.Diagnostics.NamespaceDoc">
            <summary>
            This namespace includes the common logging code used throughout Neon applications and libraries.
            </summary>
            <remarks>
            <para>
            <b>Neon.Common</b> nuget releases versions 3.0+ are now fully integrated with OpenTelemetry
            and the standard Microsoft logging extensions.  Before v3.0, we included a custom logging 
            solution that was lightly based on <see cref="T:Microsoft.Extensions.Logging.ILogger"/> and was configured in a completely
            non-standard way.
            </para>
            <para>
            We now support OpenTelemetry for logging as well as for tracing and metrics and this can be
            configured using the standard <b>OpenTelemetry</b> and <b>Microsoft.Logging.Extensions</b> APIs.
            </para>
            <para>
            We've also included some useful types and extension methods.
            </para>
            <list type="table">
            <item>
                <term><see cref="T:Neon.Diagnostics.LoggerExtensions"/></term>
                <description>
                <para>
                This namespace defines several <b><i>extended</i></b> <see cref="T:Microsoft.Extensions.Logging.ILogger"/> extension methods
                whose names end with <b>"Ex"</b>, like <see cref="M:Neon.Diagnostics.LoggerExtensions.LogInformationEx(Microsoft.Extensions.Logging.ILogger,System.Exception,System.String,System.Action{Neon.Diagnostics.LogAttributes})"/>.
                </para>
                <para>
                We recommend that developers consider switch to using our extended logging methods
                from the stock .NET extensions <see cref="T:Microsoft.Extensions.Logging.LoggerExtensions"/>.
                Not only do the NeonSDK <see cref="T:Neon.Diagnostics.LoggerExtensions"/> interoperate
                with the <see cref="T:Neon.Diagnostics.AttributeLogger"/>, we believe our extensions are easier to use,
                especially when specifying attributes.  We also have overrides that make it efficient
                to use string interpolation for generating log messages.
                </para>
                </description>
            </item>
            <item>
                <term><b><see cref="T:Neon.Diagnostics.AttributeLogger"/></b></term>
                <description>
                This is an extended <see cref="T:Microsoft.Extensions.Logging.ILogger"/> that may include tags that will be automatically
                added to all events submitted to the logger.  Typically, you'll use the <see cref="M:Neon.Diagnostics.LoggerExtensions.AddAttributes(Microsoft.Extensions.Logging.ILogger,System.Action{Neon.Diagnostics.LogAttributes})"/>
                method to construct one of these that wraps another logger.
                </description>
            </item>
            <item>
                <term><see cref="T:Neon.Diagnostics.TelemetryHub"/></term>
                <description>
                <para>
                This <c>static</c> class can be used to hold global state such as the 
                <see cref="P:Neon.Diagnostics.TelemetryHub.ActivitySource"/> and <see cref="P:Neon.Diagnostics.TelemetryHub.LoggerFactory"/>
                and also provides easy-to-use methods for obtaining an <see cref="T:Microsoft.Extensions.Logging.ILogger"/> or
                parsing loglevel strings in a backwards compatible way.
                </para>
                <note>
                <b>IMPORTANT:</b> <b>NeonSDK</b> and other Neon libraries won't emit logs or traces unless the
                <see cref="P:Neon.Diagnostics.TelemetryHub.LoggerFactory"/> and <see cref="P:Neon.Diagnostics.TelemetryHub.ActivitySource"/>
                properties are initialized.  Your applications will need set <see cref="P:Neon.Diagnostics.TelemetryHub.LoggerFactory"/>
                and <see cref="P:Neon.Diagnostics.TelemetryHub.ActivitySource"/> immediately after configuring telemetry using the 
                <b>OpenTelemetry</b> and <b>Microsoft.Extensions.Logging</b> APIs to enable logging by Neon libraries.
                </note>
                </description>
            </item>
            <item>
                <term><see cref="T:Neon.Diagnostics.LogAsTraceProcessor"/></term>
                <description>
                This processor can be used to forward logged events to the current trace span, if there is
                one.  I understand that OpenTelemetry may converge log and trace events at somepoint in the
                future, but in the meantime, adding a <see cref="T:Neon.Diagnostics.LogAsTraceProcessor"/> to your OpenTelemetry
                log pipeline is a reasonable alternative.
                </description>
            </item>
            <item>
                <term><see cref="T:System.Diagnostics.Contracts.Covenant"/></term>
                <description>
                This is basically a clone of <see cref="N:System.Diagnostics.Contracts"/>.  We started using
                <see cref="N:System.Diagnostics.Contracts"/> years ago and liked it, but unforunately I ran
                into trouble (with building projects, I believe).  So I cloned the API and put it in the
                <see cref="N:System.Diagnostics"/> namespace so it would be easy access and easier to revert.
                </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Neon.Diagnostics.NullLogger">
            <summary>
            Implements a <b>do-nothing</b> <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.NullLogger.Instance">
            <summary>
            Returns a <see cref="T:Neon.Diagnostics.NullLogger"/> instance.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.NullLogger.BeginScope``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NullLogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NullLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.SeverityNumber">
            <summary>
            The standard OpenTelemetry log severity numbers.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.TelemetryHub">
            <summary>
            <para>
            Provides a standard global place where libraries and applications can gain access to
            the application's <see cref="P:Neon.Diagnostics.TelemetryHub.ActivitySource"/> and <see cref="P:Neon.Diagnostics.TelemetryHub.LoggerFactory"/> for 
            recording traces and logs.  Applications that enable tracing and logging and want 
            to enable logging and tracing by Neon libraries set <see cref="P:Neon.Diagnostics.TelemetryHub.LoggerFactory"/>
            and <see cref="P:Neon.Diagnostics.TelemetryHub.ActivitySource"/> immediately after configuring telemetry using 
            the <b>OpenTelemetry</b> and <b>Microsoft.Extensions.Logging</b> APIs.
            </para>
            <note>
            The <b>Neon.Service.NeonService</b> class initializes these properties by default when
            used by applications based on this class.
            </note>
            <para>
            <see cref="M:Neon.Diagnostics.TelemetryHub.CreateLogger``1(Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)"/>, <see cref="M:Neon.Diagnostics.TelemetryHub.CreateLogger(System.Type,Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)"/>,
            or <see cref="M:Neon.Diagnostics.TelemetryHub.CreateLogger(System.String,Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)"/> are helper methods for obtaining loggers.
            </para>
            <para>
            You can also set the <see cref="T:Neon.Diagnostics.LogAttributes"/> property to attributes you'd like to include
            in the loggers returned by the <c>CreateLogger()</c> methods.  This is a handy way to include
            a common set of attributes with all logged events.
            </para>
            <para>
            The <see cref="M:Neon.Diagnostics.TelemetryHub.ParseLogLevel(System.String,Microsoft.Extensions.Logging.LogLevel)"/> utility can be used to parse a log level
            string obtained from an environment variable or elsewhere.  This returns the parsed log level
            and also sets the <b>Logging__LogLevel__Microsoft</b> environment variable which will be
            honored by any created loggers.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.TelemetryHub.ActivitySource">
            <summary>
            Holds the global activity source used by Neon and perhaps other libraries for emitting
            traces.  This defaults to <c>null</c> which means that libraries won't emit any
            traces by default.  Programs should set this after configuring tracing.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.TelemetryHub.LoggerFactory">
            <summary>
            Holds the global <see cref="T:Microsoft.Extensions.Logging.ILoggerFactory"/> used by the Neon and perhaps other libraries
            for emitting logs.  This defaults to <c>null</c> which means that libraries won't emit any
            logs by default.  Programs should set this after configuring logging.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.TelemetryHub.LogAttributes">
            <summary>
            Optionally holds any <see cref="T:Neon.Diagnostics.LogAttributes"/> that will be added to <see cref="T:Microsoft.Extensions.Logging.ILogger"/>
            instances returned by <see cref="M:Neon.Diagnostics.TelemetryHub.CreateLogger(System.String,Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)"/>, 
            <see cref="M:Neon.Diagnostics.TelemetryHub.CreateLogger(System.Type,Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)"/>, or <see cref="M:Neon.Diagnostics.TelemetryHub.CreateLogger``1(Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.TelemetryHub.CreateLogger``1(Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)">
            <summary>
            Returns an <see cref="T:Microsoft.Extensions.Logging.ILogger"/> using the fully qualified name of the <typeparamref name="T"/>
            type as the logger's category name.
            </summary>
            <typeparam name="T">Identifies the type whose fully-qualified name is to be used as the logger's category name.</typeparam>
            <param name="attributes">Optionally specifies attributes to be included in every event logged.</param>
            <param name="noAttributes">Optionally indicates that the <see cref="T:Neon.Diagnostics.LogAttributes"/> <b>should not</b> be added to the logger returned.</param>
            <param name="nullLogger">Optionally specifies that a do-nothing logger should be returned.  This defaults to <c>false</c>.</param>
            <returns>The <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.</returns>
        </member>
        <member name="M:Neon.Diagnostics.TelemetryHub.CreateLogger(System.Type,Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)">
            <summary>
            Returns an <see cref="T:Microsoft.Extensions.Logging.ILogger"/> using the fully qualified name from <paramref name="type"/>.
            type as the logger's category name.
            </summary>
            <param name="type"></param>
            <param name="attributes">Optionally specifies attributes to be included in every event logged.</param>
            <param name="noAttributes">Optionally indicates that the <see cref="T:Neon.Diagnostics.LogAttributes"/> <b>should not</b> be added to the logger returned.</param>
            <param name="nullLogger">Optionally specifies that a do-nothing logger should be returned.  This defaults to <c>false</c>.</param>
            <returns>The <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.</returns>
        </member>
        <member name="M:Neon.Diagnostics.TelemetryHub.CreateLogger(System.String,Neon.Diagnostics.LogAttributes,System.Boolean,System.Boolean)">
            <summary>
            Returns an <see cref="T:Microsoft.Extensions.Logging.ILogger"/> using the category name passed.
            </summary>
            <param name="categoryName">Specifies the logger's category name.</param>
            <param name="attributes">Optionally specifies attributes to be included in every event logged.</param>
            <param name="noAttributes">Optionally indicates that the <see cref="T:Neon.Diagnostics.LogAttributes"/> <b>should not</b> be added to the logger returned.</param>
            <param name="nullLogger">Optionally specifies that a do-nothing logger should be returned.  This defaults to <c>false</c>.</param>
            <returns>The <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.</returns>
        </member>
        <member name="M:Neon.Diagnostics.TelemetryHub.ParseLogLevel(System.String,Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            Parses a <see cref="T:Microsoft.Extensions.Logging.LogLevel"/> from a string.
            </summary>
            <param name="input">The input string.</param>
            <param name="default">The default value to return when <paramref name="input"/> is <c>null</c> or invalid.</param>
            <returns>The parsed <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.</returns>
        </member>
        <member name="M:Neon.Diagnostics.TelemetryHub.GetNextIndex">
            <summary>
            Returns the next logged event index.  This value will be included as the <see cref="F:Neon.Diagnostics.LogAttributeNames.NeonIndex"/>
            attribute for all events logged by the <see cref="T:Neon.Diagnostics.LoggerExtensions"/> methods.
            </summary>
            <returns>The next index.</returns>
        </member>
        <member name="T:Neon.Diagnostics.TelemetrySpanEventNames">
            <summary>
            NeonSDK related trace/span event names.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.TelemetrySpanEventNames.Log">
            <summary>
            The trace event originated as a logged event that was also emitted as trace
            event, probably via <see cref="T:Neon.Diagnostics.LogAsTraceProcessor"/> or a 
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.TelemetrySpanExtensions">
            <summary>
            Extends the <see cref="T:OpenTelemetry.Trace.TelemetrySpan"/> class.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.TelemetrySpanExtensions.AddEvent(OpenTelemetry.Trace.TelemetrySpan,System.String,System.Action{OpenTelemetry.Trace.SpanAttributes})">
            <summary>
            Adds an event with tags ti a <see cref="T:OpenTelemetry.Trace.TelemetrySpan"/>.
            </summary>
            <param name="span">The span.</param>
            <param name="name">The event name.</param>
            <param name="attributeSetter">The action that sets any tags.</param>
            <remarks>
            <note>
            This method does nothing when the <paramref name="span"/> is not recording.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.IO.BlockStream">
            <summary>
            Implements an in-memory stream based on a collection of <see cref="T:Neon.Common.Block"/> 
            buffers rather than a single byte buffer.  This is more efficient than
            <see cref="T:System.IO.MemoryStream"/> for large streams and also avoids allocations
            in the large object heap.
            </summary>
            <remarks>
            <note>
            Buffer array streams cannot be greater than or equal to 2GiB in length.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor">
            <summary>
            Constructs a zero length stream with default block size.
            </summary>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Int32)">
            <summary>
            Constructs a stream of the specified size using the default
            block size.
            </summary>
            <param name="size">The stream size in bytes.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a stream of the specified size using the 
            specified block size.
            </summary>
            <param name="size">The stream size in bytes.</param>
            <param name="blockSize">The block size in bytes.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a stream of the specified size using the 
            specified block size and offset.
            </summary>
            <param name="size">The stream size in bytes.</param>
            <param name="blockSize">The block size in bytes.</param>
            <param name="blockOffset">Bytes to be reserved at the beginning of each new block.</param>
            <remarks>
            See <see cref="T:Neon.Common.BlockArray"/> for more information on
            the value and use of the blockOffset prarmeter.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(Neon.Common.BlockArray)">
            <summary>
            Constructs a stream from the blocks passed.
            </summary>
            <param name="blocks">The blocks.</param>
            <remarks>
            The stream size will be set to the size of the blocks.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(Neon.Common.Block[])">
            <summary>
            Constructs a stream from the blocks passed.
            </summary>
            <param name="blocks">The blocks.</param>
            <remarks>
            The stream size will be set to the size of the blocks.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Byte[])">
            <summary>
            Constructs a stream from a byte array.
            </summary>
            <param name="buffer">The byte array.</param>
        </member>
        <member name="P:Neon.IO.BlockStream.CanRead">
            <summary>
            Returns <c>true</c> if the stream supports read operations.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.CanWrite">
            <summary>
            Returns <c>true</c> if the stream supports write operations.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.CanSeek">
            <summary>
            Returns <c>true</c> if the stream supports seek operations.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.Length">
            <summary>
            Returns the current size of the stream in bytes.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.Position">
            <summary>
            The current stream position.
            </summary>
            <remarks>
            <note>
            It is valid to set a stream position beyond the current
            end of the stream.  The stream will be extended to this position.
            The contents of the extended portion will be undefined.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream.
            </summary>
            <param name="value">The new length in bytes.</param>
            <remarks>
            The stream will be truncated if the new length is less than
            the current length.  The stream will be extended if the new
            length is greater than the current length.  In this case,
            the contents of the extended portion will be undefined.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.SetLength(System.Int64,System.Boolean)">
            <summary>
            Sets the length of the stream.
            </summary>
            <param name="value">The new length in bytes.</param>
            <param name="modifyBlocks"><c>true</c> to modify the underlying block array if necessary.</param>
            <remarks>
            The modifyBlocks parameter specifies whether the underlying
            block array will be truncated or extended to the length
            specified.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.ReadByte">
            <summary>
            Reads a byte from the current stream position, advancing
            the position by 1.
            </summary>
            <returns>The byte read or <b>-1</b> if the end of the stream has been reached.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from the current stream position, advancing the
            position past the data read.
            </summary>
            <param name="buffer">The destination buffer.</param>
            <param name="offset">Offset where the read data is to be copied.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>The number of bytes actually read.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously reads from the stream.
            </summary>
            <param name="buffer">The destination buffer.</param>
            <param name="offset">Offset where the read data is to be copied.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The number of bytes actually read.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current stream position, advancing the
            position by 1.
            </summary>
            <param name="value">The byte to write.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes to the stream at the current position, advancing
            the position past the data written.
            </summary>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Offset of the first byte to write.</param>
            <param name="count">Number of bytes to read.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously writes bytes to the stream at the current position, advancing
            the position past the data written.
            </summary>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Offset of the first byte to write.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.Flush">
            <summary>
            Flushes any stream buffers.
            </summary>
            <remarks>
            This is a NOP for this implementation.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Moves the current stream position relative to the specified origin.
            </summary>
            <param name="offset">The positional offset.</param>
            <param name="origin">Specifies the seek origin.</param>
            <returns>The stream position after the seek.</returns>
            <remarks>
            It is valid to seek past the current stream length.  In this
            case, the stream will be extended with the contents of the
            extended portion being undefined.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.Append(Neon.Common.Block)">
            <summary>
            Appends a block to the end of the underlying BlockArray.
            </summary>
            <param name="block">The block to append.</param>
            <remarks>
            <para>
            The underyling block array's SetExactSize() method will be
            called before appending the block.  The stream position will
            be set to the end of the stream before the method returns.
            </para>
            <para>
            This method is a performance improvement over writing the
            a buffer to the stream via one of the write methods.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.Append(Neon.Common.BlockArray)">
            <summary>
            Appends a block array to the end of the underlying BlockArray.
            </summary>
            <param name="blocks">The array to append.</param>
            <remarks>
            The underyling block array's SetExactSize() method will be
            called before appending the block.  The stream position will
            be set to the end of the stream before the method returns.
            
            This method is a performance improvement over writing the
            a buffer to the stream via one of the write methods.
            </remarks>
        </member>
        <member name="P:Neon.IO.BlockStream.RawBlockArray">
            <summary>
            Returns the underlying block array without modification.
            </summary>
        </member>
        <member name="M:Neon.IO.BlockStream.ToBlocks(System.Boolean)">
            <summary>
            Returns the underlying buffer array.
            </summary>
            <param name="truncate">
            <c>true</c> if the method will truncate the underlying BlockArray
            to the actual length of the stream before returning the array.
            </param>
            <returns>The <see cref="T:Neon.Common.BlockArray"/>.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.ToArray">
            <summary>
            Assembles a contiguous a byte array from the underlying
            buffer array.
            </summary>
            <returns>The assembled byte array.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.ReadBlocks(System.Int32)">
            <summary>
            Returns requested bytes from the underlying block array as
            as a new block array.
            </summary>
            <param name="cb">The nunber of bytes to read.</param>
            <returns>
            A new block array referencing the requested bytes in the
            same underlying buffers as managed by then stream.
            </returns>
            <remarks>
            This provides a high performance way for code that knows
            how to handle block arrays to extract a portion of a stream.
            
            The array returned will be truncated to the length of the
            underlying stream.  The stream position will be advanced
            past the requested bytes.
            </remarks>
        </member>
        <member name="T:Neon.IO.FixedLengthStream">
            <summary>
            <para>
            Implements a specialized stream that wraps another stream that does not support
            seeking such that the <see cref="P:Neon.IO.FixedLengthStream.Length"/> property will return a specific value.
            </para>
            <para>
            This is useful for situations such as a web request handler that needs to process
            the body stream which does not implement <see cref="P:Neon.IO.FixedLengthStream.Length"/> but where this length
            is required.
            </para>
            <para>
            To use, simply construct an instance, passing the source stream and its length
            (often obtained via an HTTP <b>Content-Length</b> header.
            </para>
            <note>
            <para>
            This stream is really intended just for reading data and does not support:
            </para>
            </note>
            <list type="bullet">
            <item>writing</item>
            <item>seeking</item>
            <item>setting the length</item>
            </list>
            </summary>
        </member>
        <member name="M:Neon.IO.FixedLengthStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="stream">The source stream.</param>
            <param name="length">The stream length.</param>
        </member>
        <member name="P:Neon.IO.FixedLengthStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.FixedLengthStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.FixedLengthStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.FixedLengthStream.Length">
            <summary>
            <para>
            Returns the fixed stream length passed to the constructor.
            </para>
            </summary>
        </member>
        <member name="P:Neon.IO.FixedLengthStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.FixedLengthStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.FixedLengthStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.FixedLengthStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.FixedLengthStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.FixedLengthStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.IStaticDirectory">
            <summary>
            <para>
            Describes a logical file in a static file system.  This is used to abstract access
            to static files read from an assembly's embedded resources or potentially from other
            sources using Linux style paths.
            </para>
            <para>
            This is currently used to emulate a tree of <see cref="T:Neon.IO.IStaticDirectory"/> and 
            <see cref="T:Neon.IO.IStaticFile"/> instances loaded from an assembly's embedded resources
            via the <see cref="M:Neon.Common.NeonAssemblyExtensions.GetResourceFileSystem(System.Reflection.Assembly,System.String)"/> 
            extension method.
            </para>
            <note>
            <b>IMPORTANT: </b>Implementations need to be thread-safe.
            </note>
            <note>
            In general, file and directory name lookup case sensitivity should probably be
            case insensitive for most purposes but this is an implementation specific detail. 
            </note>
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="P:Neon.IO.IStaticDirectory.Name">
            <summary>
            Returns the directory name.
            </summary>
        </member>
        <member name="P:Neon.IO.IStaticDirectory.Path">
            <summary>
            Returns the fully qualified Linux style path for the static directory relative to
            the static root directory.
            </summary>
        </member>
        <member name="P:Neon.IO.IStaticDirectory.Parent">
            <summary>
            Returns a reference to the parent directory or <c>null</c> if this is the root directory
            for a static file system.
            </summary>
        </member>
        <member name="M:Neon.IO.IStaticDirectory.GetDirectories(System.String,System.IO.SearchOption)">
            <summary>
            Returns the directories beneath the current directory, optionally matching directories by
            name as well as optionally searching for directories recursively.
            </summary>
            <param name="searchPattern">
            Optionally specifies a directory name pattern using standard file system wildcards
            like <b>[*]</b> and <b>[?]</b>.  This defaults to including all directories.
            </param>
            <param name="options">Optionally require a recursive search.  This defaults to 
            <see cref="F:System.IO.SearchOption.TopDirectoryOnly"/>.
            </param>
            <returns>The set of matching directories.</returns>
        </member>
        <member name="M:Neon.IO.IStaticDirectory.GetFiles(System.String,System.IO.SearchOption)">
            <summary>
            Returns the files beneath the current directory, optionally matching files by
            name as well as optionally searching recursively searching subdirectories..
            </summary>
            <param name="searchPattern">
            Optionally specifies a file name pattern using standard file system wildcards
            like <b>[*]</b> and <b>[?]</b>.  This defaults to including all files.
            </param>
            <param name="options">Optionally requires a recursive search.  This defaults to 
            <see cref="F:System.IO.SearchOption.TopDirectoryOnly"/>.
            </param>
            <returns>The set of matching files.</returns>
        </member>
        <member name="M:Neon.IO.IStaticDirectory.GetFile(System.String)">
            <summary>
            <para>
            Gets a file via a Linux style path.  This path can be absolute relative to the 
            root directory or it can be relative to the current directory.
            </para>
            <note>
            Relative paths including <b>/../</b> notation to move up a directory or <b>./</b>
            to specify the current directory are not supported.
            </note>
            </summary>
            <param name="path">The file path (absolute or relative).</param>
            <returns>The file.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file doesn't exist.</exception>
        </member>
        <member name="M:Neon.IO.IStaticDirectory.GetDirectory(System.String)">
            <summary>
            <para>
            Gets a directory via a Linux style path.  This path can be absolute relative to the 
            root directory or it can be relative to the current directory.
            </para>
            <note>
            Relative paths including <b>/../</b> notation to move up a directory or <b>./</b>
            to specify the current directory are not supported.
            </note>
            </summary>
            <param name="path">The file path (absolute or relative).</param>
            <returns>The directory.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the directory doesn't exist.</exception>
        </member>
        <member name="T:Neon.IO.IStaticFile">
            <summary>
            <para>
            Describes a logical file in a static file system.  This is used to abstract access
            to static files read from an assembly's embedded resources or potentially from other
            sources using Linux style paths.
            </para>
            <para>
            This is currently used to emulate a tree of <see cref="T:Neon.IO.IStaticDirectory"/> and 
            <see cref="T:Neon.IO.IStaticFile"/> instances loaded from an assembly's embedded resources
            via the <see cref="M:Neon.Common.NeonAssemblyExtensions.GetResourceFileSystem(System.Reflection.Assembly,System.String)"/>
            extension method.
            </para>
            <note>
            <b>IMPORTANT: </b>Implementations need to be thread-safe.
            </note>
            <note>
            In general, file and directory name lookup case sensitivity should probably be
            case insensitive for most purposes but this is an implementation specific detail. 
            </note>
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="P:Neon.IO.IStaticFile.Name">
            <summary>
            Returns the file name.
            </summary>
        </member>
        <member name="P:Neon.IO.IStaticFile.Path">
            <summary>
            Returns the fully qualified Linux style path for the static file relative to
            the static root directory.
            </summary>
        </member>
        <member name="M:Neon.IO.IStaticFile.ReadAllText(System.Text.Encoding)">
            <summary>
            Reads the file contents as a UTF-8 encoded string.
            </summary>
            <param name="encoding">Optionally specifies the text encoding.  This defaults to <b>UTF-8</b>,</param>
            <returns>The file contents.</returns>
        </member>
        <member name="M:Neon.IO.IStaticFile.ReadAllTextAsync(System.Text.Encoding)">
            <summary>
            Asynchronously reads the file contents as a UTF-8 encoded string.
            </summary>
            <param name="encoding">Optionally specifies the text encoding.  This defaults to <b>UTF-8</b>,</param>
            <returns>The file contents.</returns>
        </member>
        <member name="M:Neon.IO.IStaticFile.OpenReader(System.Text.Encoding)">
            <summary>
            <para>
            Opens a text reader for the file contents.
            </para>
            <note>
            You are responsible disposing the reader returned when you're done with it.
            </note>
            </summary>
            <param name="encoding">Optionally specifies the text encoding.  This defaults to <b>UTF-8</b>,</param>
            <returns>The <see cref="T:System.IO.TextReader"/>.</returns>
        </member>
        <member name="M:Neon.IO.IStaticFile.OpenReaderAsync(System.Text.Encoding)">
            <summary>
            <para>
            Asychronously opens a text reader for the file contents.
            </para>
            <note>
            You are responsible disposing the reader returned when you're done with it.
            </note>
            </summary>
            <param name="encoding">Optionally specifies the text encoding.  This defaults to <b>UTF-8</b>,</param>
            <returns>The <see cref="T:System.IO.TextReader"/>.</returns>
        </member>
        <member name="M:Neon.IO.IStaticFile.ReadAllBytes">
            <summary>
            Reads the file contents as bytes.
            </summary>
            <returns>The file contents.</returns>
        </member>
        <member name="M:Neon.IO.IStaticFile.ReadAllBytesAsync">
            <summary>
            Asynchronously reads the file contents as bytes.
            </summary>
            <returns>The file contents.</returns>
        </member>
        <member name="M:Neon.IO.IStaticFile.OpenStream">
            <summary>
            <para>
            Opens a stream on the file contents.
            </para>
            <note>
            You are responsible disposing the reader returned when you're done with it.
            </note>
            </summary>
            <returns>The <see cref="T:System.IO.Stream"/>.</returns>
        </member>
        <member name="M:Neon.IO.IStaticFile.OpenStreamAsync">
            <summary>
            <para>
            Asychronously opens a stream on the file contents.
            </para>
            <note>
            You are responsible disposing the reader returned when you're done with it.
            </note>
            </summary>
            <returns>The <see cref="T:System.IO.Stream"/>.</returns>
        </member>
        <member name="T:Neon.IO.LineEnding">
            <summary>
            Enumerates the possible line ending modes.
            </summary>
        </member>
        <member name="F:Neon.IO.LineEnding.Platform">
            <summary>
            Use platform specific line endings.
            </summary>
        </member>
        <member name="F:Neon.IO.LineEnding.CRLF">
            <summary>
            Windows style line endings using carriage return and line feed characters.
            </summary>
        </member>
        <member name="F:Neon.IO.LineEnding.LF">
            <summary>
            Unix/Linux style line endings using just a line feed.
            </summary>
        </member>
        <member name="T:Neon.IO.LinuxPath">
            <summary>
            Implements functionality much like <see cref="T:System.IO.Path"/>, except for
            this class is oriented towards handling Linux-style paths on
            a remote (possibly a Windows) machine.
            </summary>
        </member>
        <member name="M:Neon.IO.LinuxPath.Normalize(System.String)">
            <summary>
            Ensures that the path passed is suitable for non-Windows platforms
            by conmverting any backslashes to forward slashes.
            </summary>
            <param name="path">The input path (or <c>null</c>).</param>
            <returns>The normalized path.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.ToLinux(System.String)">
            <summary>
            Converts a Windows style path to Linux.
            </summary>
            <param name="path">The source path.</param>
            <returns>The converted path.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.ChangeExtension(System.String,System.String)">
            <summary>
            Changes the file extension.
            </summary>
            <param name="path">The file path.</param>
            <param name="extension">The new extension.</param>
            <returns>The modified path.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.Combine(System.String[])">
            <summary>
            Combines an array of strings into a path.
            </summary>
            <param name="paths">The paths.</param>
            <returns>The combined paths.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetDirectoryName(System.String)">
            <summary>
            Extracts the directory portion of a path.
            </summary>
            <param name="path">The path.</param>
            <returns>The directory portion.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetExtension(System.String)">
            <summary>
            Returns the file extension from a path.
            </summary>
            <param name="path">The path.</param>
            <returns>The file extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetFileName(System.String)">
            <summary>
            Returns the file name and extension from a path.
            </summary>
            <param name="path">The path.</param>
            <returns>The file name and extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetFileNameWithoutExtension(System.String)">
            <summary>
            Returns the file name from a path without the extension.
            </summary>
            <param name="path">The path.</param>
            <returns>The file name without the extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.HasExtension(System.String)">
            <summary>
            Determines whether a path has a file extension.
            </summary>
            <param name="path">The path.</param>
            <returns><c>true</c> if the path has an extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.IsPathRooted(System.String)">
            <summary>
            Determines whether the path is rooted.
            </summary>
            <param name="path">The path.</param>
            <returns><c>true</c> ifc the path is rooted.</returns>
        </member>
        <member name="T:Neon.IO.LinuxPermissions">
            <summary>
            Manipulates Linux style file permissions.
            </summary>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.IsValidDigit(System.Char)">
            <summary>
            Verifies that the character passed is a valid permissions digit.
            </summary>
            <param name="digit">The permissions digit.</param>
            <returns><c>true</c> if the digit is valid.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.TryParse(System.String,Neon.IO.LinuxPermissions@)">
            <summary>
            Attempts to parse permissions from an octal string.
            </summary>
            <param name="input">The input string.</param>
            <param name="permissions">Returns as the parsed permissions.</param>
            <returns><c>true</c> if valid permissions were parsed.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.Set(System.String,System.String,System.Boolean)">
            <summary>
            Sets the Linux file permissions.
            </summary>
            <param name="path">Path to the target file or directory.</param>
            <param name="mode">Linux file permissions.</param>
            <param name="recursive">Optionally apply the permissions recursively.</param>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.#ctor(System.String)">
            <summary>
            Constructs permissions from an octal string.
            </summary>
            <param name="input">The permissions string encoded in their octal form.</param>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.OwnerRead">
            <summary>
            The owner can read the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.OwnerWrite">
            <summary>
            The owner can modify the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.OwnerExecute">
            <summary>
            The owner can execute the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.GroupRead">
            <summary>
            The group can read the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.GroupWrite">
            <summary>
            The group can modify the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.GroupExecute">
            <summary>
            The group can execute the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.AllRead">
            <summary>
            Everyone can read the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.AllWrite">
            <summary>
            Everyone can modify the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.AllExecute">
            <summary>
            Everyone can execute the file.
            </summary>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.ToOctal(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Converts the permissions passed into the equivalent octal character.
            </summary>
            <param name="read">Read flag.</param>
            <param name="write">Write flag.</param>
            <param name="execute">Execute flag.</param>
            <returns>The octal character.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.NamespaceDoc">
            <summary>
            This namespace includes some handy file and stream related types.
            </summary>
        </member>
        <member name="T:Neon.IO.PreprocessReader">
            <summary>
            Preprocesses text returned by a <see cref="T:System.IO.TextReader"/> by removing comments,
            expanding variables, and implementing simple conditionals.
            </summary>
            <remarks>
            <note>
            This class only implements <see cref="M:Neon.IO.PreprocessReader.ReadLine"/>, <see cref="M:Neon.IO.PreprocessReader.ReadLineAsync"/>,
            <see cref="M:Neon.IO.PreprocessReader.ReadToEnd"/>, and <see cref="M:Neon.IO.PreprocessReader.ReadToEndAsync"/>.  The other methods
            will throw a <see cref="T:System.NotImplementedException"/>.
            </note>
            <para>
            The processor removes comment lines from the text returned.  A comment line 
            starts with zero or more whitespace characters followed by "<b>//</b>".
            </para>
            <note>
            Comment lines are indicated by a "<b>//</b>" prefix by default but this can
            be modified via <see cref="M:Neon.IO.PreprocessReader.ClearCommentMarkers"/> and <see cref="M:Neon.IO.PreprocessReader.AddCommentMarker(System.String)"/>.
            </note>
            <para>
            The processor implements simple macro definition and conditional statements.
            These statements are identifying by a line with the pound sign (<b>#</b>) as
            the first non-whitespace character.
            </para>
            <note>
            The processor statement character defaults to the pound sign (<b>#</b>) but
            can be changed by setting <see cref="P:Neon.IO.PreprocessReader.StatementMarker"/>.
            </note>
            <para>
            The following processing statements are supported:
            </para>
            <list type="table">
            <item>
                <term><b>#define NAME [=VALUE]</b></term>
                <description>
                <para>
                Defines a normal variable and setting an optional value.  The empty
                string will be set by default.  These variables can be referenced
                in processing statements or normal text lines as <b>$&lt;name&gt;</b>.
                </para>
                <para>
                Variable names are case sensitive and may include letter, number, dash,
                period, and underscore characters.
                </para>
                <para>
                By default, defined variables may be referenced like <b>$&lt;name&gt;</b> and
                environment variables like <b>$&lt;name&gt;</b>.
                </para>
                </description>
            </item>
            <item>
                <term><b>#if EXPRESSION</b></term>
                <description>
                <para>
                Conditionally includes text up to the next <b>#else</b> or
                <b>#endif</b> statement.  The following expressions are
                supported:
                </para>
                <list type="bullet">
                    <item><b>VALUE1 == VALUE2</b></item>
                    <item><b>VALUE1 != VALUE2</b></item>
                    <item><b>defined(NAME)</b></item>
                    <item><b>undefined(NAME)</b></item>
                </list>
                <para>
                The comparisions are performed after any variables are expanded.  The
                values are trimmed on bothe ends and the string comparision is case
                sensitive.
                </para>
                </description>
            </item>
            <item>
                <term><b>#else</b></term>
                <description>
                This can optionally be used within an <b>#if</b> statement to include lines
                when the condition is false.
                </description>
            </item>
            <item>
                <term><b>#endif</b></term>
                <description>
                This terminates an <b>#if</b> statement.
                </description>
            </item>
            <item>
                <term><b>#switch VALUE</b></term>
                <description>
                Provides an easy to conditionally include statements for multiple conditions.
                The subsequent  <b>#case</b> and <b>#default</b> statements up to the next 
                <b>#endswitch</b> statement will be processed.
                </description>
            </item>
            <item>
                <term><b>#case VALUE</b></term>
                <description>
                This command causes the lines up to the next <b>#case</b>, <b>#default</b>,
                or <b>#endswitch</b> to be outputed if the value matches that specified for
                the parent <b>#switch</b> statement.
                </description>
            </item>
            <item>
                <term><b>#default</b></term>
                <description>
                This command causes the lines up to the next <b>#endswitch</b> to be outputed
                if the value wasn't matched by any of the previous <b>case</b> statements.
                <note>
                <b>#default</b> must appear after all <b>#case</b> statements.
                </note>
                </description>
            </item>
            <item>
                <term><b>#endswitch</b></term>
                <description>
                This command terminates a <b>#switch</b> statement.
                </description>
            </item>
            </list>
            <para>
            Normal variables can be defined within the source text itself using the 
            <b>#define</b> command described above and variables may also be added 
            in code using <see cref="M:Neon.IO.PreprocessReader.Set(System.String,System.String)"/>.  These variables can be 
            referenced as <b>$&lt;NAME&gt;</b>.  Environment variables can be referenced
            like <b>$&lt;env:NAME&gt;</b>, secrets like <b>$&lt;secret:NAME</b>, and
            profile values like: <b>$&lt;profile:NAME</b>.
            </para>
            <note>
            You may encounter situations where the default ways of referencing variables
            conflicts with the syntax of the underlying source text being processed.
            In these cases, you can set <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> to 
            <see cref="P:Neon.IO.PreprocessReader.CurlyVariableExpansionRegex"/> or <see cref="P:Neon.IO.PreprocessReader.ParenVariableExpansionRegex"/>
            to change the format.
            </note>
            <para>
            Variables are always expanded in <b>#if</b> and <b>switch</b> statements and
            are expanded by default in the other source lines.  Variables are expanded
            using the <b>$&lt;NAME&gt;</b> syntax by default.  The syntax can be modified
            by setting <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> and variable expansion can be disabled
            by setting <see cref="P:Neon.IO.PreprocessReader.ExpandVariables"/>=<c>false</c>.
            </para>
            <note>
            By default, the reader will throw a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if an
            undefined normal variable is encountered.  This behavior can be modified by setting
            <see cref="P:Neon.IO.PreprocessReader.DefaultVariable"/> to a non-<c>null</c> string.  In this case,
            undefined variable references will always be replaced by the value set.
            <see cref="P:Neon.IO.PreprocessReader.DefaultVariable"/> defaults to <c>null</c>.
            </note>
            <note>
            By default, the reader will throw a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if an
            undefined environment variable is encountered.  This behavior can be modified by setting
            <see cref="P:Neon.IO.PreprocessReader.DefaultEnvironmentVariable"/> to a non-<c>null</c> string.  In this case,
            undefined environment variable references will always be replaced by the value set.
            <see cref="P:Neon.IO.PreprocessReader.DefaultEnvironmentVariable"/> defaults to <c>null</c>.
            </note>
            <para>
            Processing can also be customized via the <see cref="P:Neon.IO.PreprocessReader.StripComments"/>, <see cref="P:Neon.IO.PreprocessReader.RemoveComments"/>,
            <see cref="P:Neon.IO.PreprocessReader.RemoveBlank"/>,  <see cref="P:Neon.IO.PreprocessReader.ProcessStatements"/>, <see cref="P:Neon.IO.PreprocessReader.Indent"/>, <see cref="P:Neon.IO.PreprocessReader.TabStop"/>, 
            and <see cref="P:Neon.IO.PreprocessReader.StatementMarker"/>
            properties.
            </para>
            <para><b>Secret and profile Values</b></para>
            <para>
            This class can integrate with a <see cref="T:Neon.Deployment.IProfileClient"/> implementation added to
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/>.  This provides a way to abstract access to
            secrets and profile values from an external source.  Three item types are supported:
            </para>
            <list type="table">
            <item>
                <term><b>secret</b></term>
                <description>
                <para>
                Secret passwords are often protected by a password manager.  NEONFORGE has standardized
                internally on 1Password for example.  Passwords are often required to satisfy complexity
                and other rules.
                </para>
                <para>
                Passwords are named by a string and are often persisted to a named location.  1Password stores
                to secrets in <i>vaults</i>.  You'll need the password name and optionally, its location when
                referencing a password value.
                </para>
                <para>
                You may also request a specific secret property using an array syntax like:
                </para>
                <example>
                SECRETNAME[PROPERTY]
                </example>
                <para>
                Doing this overrides the default <b>password</b> property.
                </para>
                </description>
            </item>
            <item>
                <term><b>profile-value</b></term>
                <description>
                <para>
                Profile values are string name/value pairs that include non-secret definitions for
                the user, workstation, or overall environment such as the LAN.  These can come in
                handy when implementing CI/CD where each server/user can be assigned unique profile
                values that reference specific test endpoints, etc.  This is quite powerful.
                </para>
                <para>
                Profile values are simply named by a string.  There is currently no concept of a source, 
                location like secrets may have.
                </para>
                </description>
            </item>
            </list>
            <para>
            Secrets and profile values can be referenced via <b>&lt;TYPE:NAME[:SOURCE]&gt;</b>
            where <b>TYPE</b> is one of <b>env</b>, <b>secret</b> (value), or <b>profile</b> and <b>NAME</b>
            identifies the secret or profile value and <b>source</b> optionally specifies the secret source
            (this is ignored for profile values).
            </para>
            <para>
            By default, a secret reference is replaced by the <b>password</b> property within the 
            named secret.  Use can use the square bracket syntax to select a different secret property.
            </para>
            <para>
            <b>Examples:</b>
            </para>
            <code>
            $&lt;secret:my-secret;my-vault&gt;      # secret from specific source
            $&lt;secret:my-secret&gt;               # secret password from default source
            $&lt;secret:my-secret[username]&gt;     # retrieve [username] from secret
            $&lt;secret:my-secret[password]&gt;     # retrieve [password] from secret
            $&lt;profile:my-profile&gt;             # profile value
            </code>
            <para>
            This class will throw <see cref="T:Neon.Deployment.ProfileException"/> when it encounters a secret/profile
            reference and there no injected <see cref="T:Neon.Deployment.IProfileClient"/> implementation or if the implementation
            has trouble communicating with the profile server.  This class also also throws a 
            <see cref="T:System.Collections.Generic.KeyNotFoundException"/> when a named secret or profile value doesn't exist.
            </para>
            </remarks>
            <threadsafety instance="false"/>
        </member>
        <member name="T:Neon.IO.PreprocessReader.ConditionalType">
            <summary>
            Used to identify the current conditional statement.
            </summary>
        </member>
        <member name="T:Neon.IO.PreprocessReader.State">
            <summary>
            Holds the current processing state.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.AngleVariableExpansionRegex">
            <summary>
            <para>
            A variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/> that matches normal variables like <b>$&lt;NAME&gt;</b>, environment
            variables like <b>$&lt;env:NAME&gt;</b>, profile value references like <b>$&lt;profile:NAME&gt;</b> and
            secret references like <b>$&lt;secret:NAME&gt;</b>, <b>$&lt;secret:NAME:SOURCE&gt;</b>, <b>$&lt;secret:NAME[PROPERTY]&gt;</b>
            or <b>$&lt;secret:NAME[PROPERTY]:SOURCE&gt;</b>
            </para>
            <para>
            You can set the <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> property to this value to change the
            <see cref="T:Neon.IO.PreprocessReader"/> behavior.
            </para>
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.CurlyVariableExpansionRegex">
            <summary>
            <para>
            A variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/> that matches normal variables like <b>${NAME}</b>, environment
            variables like <b>${env:NAME}</b>, profile value references like <b>${profile:NAME}</b> and
            secret references like <b>${secret:NAME}</b>, <b>${secret:NAME:SOURCE}</b>, <b>${secret:NAME[PROPERTY]}</b>
            or <b>${secret:NAME[PROPERTY]:SOURCE}</b>
            </para>
            <para>
            You can set the <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> property to this value to change the
            <see cref="T:Neon.IO.PreprocessReader"/> behavior.
            </para>
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.ParenVariableExpansionRegex">
            <summary>
            <para>
            A variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/> that matches normal variables like <b>$(NAME)</b>, environment
            variables like <b>$(env:NAME)</b>, profile value references like <b>$(profile:NAME)</b> and
            secret references like <b>$(secret:NAME)</b>, <b>$(secret:NAME:SOURCE)</b>, <b>$(secret:NAME[PROPERTY])</b>
            or <b>$(secret:NAME[PROPERTY]:SOURCE)</b>
            </para>
            <para>
            You can set the <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> property to this value to change the
            <see cref="T:Neon.IO.PreprocessReader"/> behavior.
            </para>
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.DefaultVariableExpansionRegex">
            <summary>
            The default variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/> that matches normal variables like <b>$&lt;test&gt;</b>, environment
            variables like <b>&lt;env:test&gt;</b>, profile references like <b>&lt;profile:my-profile&gt;</b>, and secret
            references like <b>&lt;secret:NAME:SOURCE&gt;</b>.  You can set the <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/>
            property to this value to change the <see cref="T:Neon.IO.PreprocessReader"/> behavior.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.VariableValidationRegex">
            <summary>
            <b>INTERNAL USE ONLY:</b> The <see cref="T:System.Text.RegularExpressions.Regex"/> used to validate variable names.
            </summary>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs an over another <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="reader">The source <see cref="T:System.IO.TextReader"/>.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.IO.TextReader,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance over another <see cref="T:System.IO.TextReader"/>, initializing some variables.
            </summary>
            <param name="reader">The source <see cref="T:System.IO.TextReader"/>.</param>
            <param name="variables">The variables.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.String)">
            <summary>
            Constructs an instance from a string.
            </summary>
            <param name="input">The input string.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance from a string, initializing some variables.
            </summary>
            <param name="input">The input string.</param>
            <param name="variables">The variables.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.Byte[])">
            <summary>
            Constructs an instance from UTF-8 encoded bytes.
            </summary>
            <param name="bytes">The input data.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.Byte[],System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance from  UTF-8 encoded bytes, initializing some variables.
            </summary>
            <param name="bytes">The input data.</param>
            <param name="variables">The variables.</param>
        </member>
        <member name="P:Neon.IO.PreprocessReader.StatementMarker">
            <summary>
            The leading character used to identify a preprocessing statement.
            This defaults to the pound sign (<b>#</b>).
            </summary>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ClearCommentMarkers">
            <summary>
            Clears any comment markers, effectively disabling comment stripping.
            </summary>
        </member>
        <member name="M:Neon.IO.PreprocessReader.AddCommentMarker(System.String)">
            <summary>
            Appends a comment marker prefix.  This must be a non-empty string including only
            non-whitespace punctuation characters.
            </summary>
            <param name="marker">The comment prefix.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.SetYamlMode">
            <summary>
            Configures the reader for parsing YAML by setting the <see cref="P:Neon.IO.PreprocessReader.StatementMarker"/> to <b>"~"</b>
            and the comment marker to <b>"#"</b>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.VariableExpansionRegex">
            <summary>
            The <see cref="T:System.Text.RegularExpressions.Regex"/> used to match variable expansions.  This defaults
            to matching variables of the form: <b>${NAME}</b>.
            </summary>
            <remarks>
            <note>
            You may use set encounter situations where the default syntax would
            conflict with the source text being processed.  You map use the
            <see cref="P:Neon.IO.PreprocessReader.CurlyVariableExpansionRegex"/> or <see cref="P:Neon.IO.PreprocessReader.ParenVariableExpansionRegex"/>
            patterns as an alternative.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.IO.PreprocessReader.ExpandVariables">
            <summary>
            Controls whether variables in the source are expanded.  This defaults
            to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.DefaultVariable">
            <summary>
            The default value to use for an undefined normal variable or <c>null</c>
            if a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> is to be thrown when a
            undefined non-environment variable is referenced.  This defaults to 
            <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.DefaultEnvironmentVariable">
            <summary>
            The default value to use for an undefined environment variable or <c>null</c>
            if a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> is to be thrown when a
            undefined environment variable is referenced.  This defaults to 
            <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.StripComments">
            <summary>
            Controls whether comments are stripped out while reading.  This defaults
            to <c>true</c>.
            </summary>
            <remarks>
            <note>
            <see cref="P:Neon.IO.PreprocessReader.StripComments"/> returns a blank line for comments and
            <see cref="P:Neon.IO.PreprocessReader.RemoveComments"/> doesn't return a comment line at all.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.IO.PreprocessReader.RemoveComments">
            <summary>
            Controls whether comments are removed while reading.  This defaults
            to <c>false</c>.
            </summary>
            <remarks>
            <note>
            <see cref="P:Neon.IO.PreprocessReader.StripComments"/> returns a blank line for comments and
            <see cref="P:Neon.IO.PreprocessReader.RemoveComments"/> doesn't return a comment line at all.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.IO.PreprocessReader.RemoveBlank">
            <summary>
            Controls whether blank lines or lines with only whitespace are to
            be removed while reading.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.ProcessStatements">
            <summary>
            Controls whether preprocessor statements are processed.  This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.TabStop">
            <summary>
            Controls whether embedded TAB <b>(\t)</b> characters will be converted into
            spaces to format tab stops correctly.  This defaults to <b>zero</b> which
            will not process any tabs.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.Indent">
            <summary>
            The number of spaces to indent the output.  This defaults to <b>0</b>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.LineEnding">
            <summary>
            Determines the line ending <see cref="M:Neon.IO.PreprocessReader.ReadToEnd"/> and <see cref="M:Neon.IO.PreprocessReader.ReadToEndAsync"/>
            will append to the lines they read.  This defaults to <see cref="F:Neon.IO.LineEnding.Platform"/>
            but may be changed to <see cref="F:Neon.IO.LineEnding.CRLF"/> or <see cref="F:Neon.IO.LineEnding.LF"/>.
            </summary>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Set(System.String,System.String)">
            <summary>
            Sets a variable to a string value.
            </summary>
            <param name="name">The case sensitive variable name.</param>
            <param name="value">The option value (defaults to the empty string).</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Set(System.String,System.Object)">
            <summary>
            Sets a variable to an object value.
            </summary>
            <param name="name">The case sensitive variable name.</param>
            <param name="value">The option value (defaults to the null).</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Set(System.String,System.Boolean)">
            <summary>
            Sets a variable to an boolean value.
            </summary>
            <param name="name">The case sensitive variable name.</param>
            <param name="value">The option value.</param>
            <remarks>
            <note>
            The value set will be lowercase <b>true</b> or <b>false</b>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadLine">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadLineAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadToEnd">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadToEndAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.IsComment(System.String)">
            <summary>
            Determines whether the line passed is a comment.
            </summary>
            <param name="line">The text line.</param>
            <returns><b>true</b> if the line is a comment.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Expand(System.String)">
            <summary>
            Expands any variables and TABs in the string passed.
            </summary>
            <param name="input">The input text.</param>
            <returns>The expanded result.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.IndentLine(System.String)">
            <summary>
            Adds indentation to the input.
            </summary>
            <param name="input">The inpur string.</param>
            <returns>The indented input.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.IsStatement(System.String)">
            <summary>
            Determines whether the line passed is a statement.
            </summary>
            <param name="line">The text line.</param>
            <returns><b>true</b> if the line is a statement.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ProcessStatement(System.String)">
            <summary>
            Processes a statement line.
            </summary>
            <param name="line">The statement.</param>
            <exception cref="T:System.FormatException">Thrown for malformed statements.</exception>
        </member>
        <member name="M:Neon.IO.PreprocessReader.VerifyStatementClosure">
            <summary>
            Verifies that all statements have been closed properly.
            </summary>
            <exception cref="T:System.FormatException">Thrown if an [#if] or {#switch] statement has not been closed.</exception>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Peek">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Read">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Read(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.RelayStream">
            <summary>
            Implements a stream that passes operations to another stream.  This 
            is mainly useful for controlling whether <see cref="M:System.IO.Stream.Dispose"/>
            and <see cref="M:Neon.IO.RelayStream.Dispose(System.Boolean)"/> actually disposes the underlying
            stream or not when the stream is referenced by another class that 
            always disposes the stream.
            </summary>
        </member>
        <member name="M:Neon.IO.RelayStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="stream">The underlying stream being associated.</param>
            <param name="leaveOpen">Optionally leave the underlying stream open when this instance is disposed.</param>
        </member>
        <member name="M:Neon.IO.RelayStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.StaticDirectoryBase">
            <summary>
            <para>
            Helper class that can be used by <see cref="T:Neon.IO.IStaticDirectory"/> implementations.
            </para>
            <note>
            Implementations derived from this class will use case insensitive file and
            directory name mapping.
            </note>
            </summary>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.#ctor(Neon.IO.StaticDirectoryBase,Neon.IO.StaticDirectoryBase,System.String)">
            <summary>
            Protected constructor.
            </summary>
            <param name="root">The root directory or <c>null</c> if this is the root.</param>
            <param name="parent">The parent directory or <c>null</c> for the root directory.</param>
            <param name="name">The directory name (this must be <c>null</c> for the root directory.</param>
        </member>
        <member name="P:Neon.IO.StaticDirectoryBase.Directories">
            <summary>
            Returns the subdirectories present in this directory.
            </summary>
        </member>
        <member name="P:Neon.IO.StaticDirectoryBase.Files">
            <summary>
            Returns the list of files present in this directory.
            </summary>
        </member>
        <member name="P:Neon.IO.StaticDirectoryBase.Parent">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.StaticDirectoryBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.StaticDirectoryBase.Path">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.AddFile(Neon.IO.StaticFileBase)">
            <summary>
            Adds a file.
            </summary>
            <param name="file">The subdirectory.</param>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.AddDirectory(Neon.IO.StaticDirectoryBase)">
            <summary>
            Adds a subdirectory if it doesn't already exist.
            </summary>
            <param name="directory">The child resource directory.</param>
            <returns>The existing <see cref="T:Neon.IO.StaticResourceDirectory"/> or <paramref name="directory"/> if it was added</returns>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.GetFile(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.FindFile(System.String)">
            <summary>
            Implemented by the root directory in a file system to quickly search
            for a file via a fully qualified path.
            </summary>
            <param name="path">The target file path.</param>
            <returns>The <see cref="T:Neon.IO.StaticFileBase"/> for the file if present, otherwise <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this is not the root node.</exception>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.GetDirectory(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.FindDirectory(System.String)">
            <summary>
            Implemented by the root directory in a file system to quickly search
            for a directory via a fully qualified path.
            </summary>
            <param name="path">The target directory path.</param>
            <returns>The <see cref="T:Neon.IO.StaticDirectoryBase"/> for the file if present, otherwise <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this is not the root node.</exception>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.GetPath">
            <summary>
            Returns the fully qualified path to the directory.
            </summary>
            <returns>The Linux style path.</returns>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.GetFiles(System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.GetDirectories(System.String,System.IO.SearchOption)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.AddFiles(System.Collections.Generic.Dictionary{System.String,Neon.IO.StaticFileBase},System.Text.RegularExpressions.Regex,System.IO.SearchOption)">
            <summary>
            Adds files whose names match the search pattern to the list passed, recursively walking
            subdirectories when requested.
            </summary>
            <param name="items">The output directory list.</param>
            <param name="searchPattern">Specifies the search pattern.</param>
            <param name="options">Specifies the recursion option.</param>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.AddDirectories(System.Collections.Generic.Dictionary{System.String,Neon.IO.StaticDirectoryBase},System.Text.RegularExpressions.Regex,System.IO.SearchOption)">
            <summary>
            Adds directories whose names match the search pattern to the list passed, recursively walking
            subdirectories when requested.
            </summary>
            <param name="items">The output directory list.</param>
            <param name="searchPattern">Specifies the search pattern.</param>
            <param name="options">Specifies the recursion option.</param>
        </member>
        <member name="M:Neon.IO.StaticDirectoryBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.StaticFileBase">
            <summary>
            <para>
            Helper class that can be used by <see cref="T:Neon.IO.IStaticFile"/> implementations.
            </para>
            <note>
            Implementations derived from this class will use case insensitive file and
            directory name mapping.
            </note>
            </summary>
        </member>
        <member name="M:Neon.IO.StaticFileBase.#ctor(System.String)">
            <summary>
            Protected constructor.
            </summary>
            <param name="path">The logical path to this file.</param>
        </member>
        <member name="P:Neon.IO.StaticFileBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.StaticFileBase.Path">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.ReadAllBytes">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.ReadAllBytesAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.ReadAllText(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.ReadAllTextAsync(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.OpenReader(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.OpenReaderAsync(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.OpenStream">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.OpenStreamAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticFileBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.StaticResourceDirectory">
            <summary>
            Implements the <see cref="T:Neon.IO.IStaticDirectory"/> abstraction over as virtual
            directory of embedded <see cref="T:System.Reflection.Assembly"/> resources.
            </summary>
        </member>
        <member name="M:Neon.IO.StaticResourceDirectory.#ctor(Neon.IO.StaticResourceDirectory,Neon.IO.StaticResourceDirectory,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="root">The root directory or <c>null</c> if this is the root.</param>
            <param name="parent">The parent directory or <c>null</c> for the root directory.</param>
            <param name="path">Specifies the logical Lunix-style path to directory.</param>
        </member>
        <member name="T:Neon.IO.StaticResourceFile">
            <summary>
            Implements the <see cref="T:Neon.IO.IStaticFile"/> abstractionreferencing an embedded <see cref="T:System.Reflection.Assembly"/> resource.
            </summary>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.#ctor(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="assembly">The source assembly.</param>
            <param name="resourceName">The name of the resource in the assembly manifest.</param>
            <param name="path">The logical path to this file.</param>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.OpenReader(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.OpenReaderAsync(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.OpenStream">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.OpenStreamAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.ReadAllBytes">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.ReadAllBytesAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.ReadAllText(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.StaticResourceFile.ReadAllTextAsync(System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.SubStream">
            <summary>
            <para>
            Implements a <see cref="T:System.IO.Stream"/> that operates on a section of a base stream.
            The base stream must be able to <see cref="P:System.IO.Stream.CanSeek"/>.
            </para>
            <note>
            Thread safety: multiple <see cref="T:Neon.IO.SubStream"/> instances can perform operations on the
            same underlying stream on differents because substreams obtain a lock on the base stream
            before actually performing any I/O operations.
            </note>
            <note>
            <b>WARNING:</b> Avoid performing operations on the underlying stream and any substreams
            within different threads.  This will likey result in unexpected data corruption.
            </note>
            </summary>
            <remarks>
            <note>
            This class doesn't currently implement all of the <see cref="T:System.IO.Stream"/> methods, especially 
            asynchronous methods.  This is something we may add in the future.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.IO.SubStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Constructs a substream that operates on a range of bytes within a base stream.
            </summary>
            <param name="baseStream">The base stream.</param>
            <param name="start">The zero-based index of the first byte within the base stream to be managed by the substream.</param>
            <param name="length">The number of bytes to be managed.</param>
            <exception cref="T:System.IO.IOException">Thrown if the base stream doesn't support seek or the starting position or length is invalid.</exception>
        </member>
        <member name="M:Neon.IO.SubStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.EnsurePosition(System.String,System.Int64,System.Int64)">
            <summary>
            Ensures that the starting and optional ending position for a stream operation are 
            constrained to the substream's data.
            </summary>
            <param name="operation">Identifies the operation.</param>
            <param name="startPos">The logical starting position.</param>
            <param name="endPos">Optionally specifies the logical ending position.</param>
            <exception cref="T:System.IO.IOException">Thrown when the start/end positions are outside of the substream data.</exception>
        </member>
        <member name="M:Neon.IO.SubStream.Execute(System.Action)">
            <summary>
            Saves the base stream position, sets the base position to match the
            virtual substream position, executes the operation and then restores the
            base stream position.
            </summary>
            <param name="operation">The operation to be performed.</param>
        </member>
        <member name="M:Neon.IO.SubStream.ExecuteInt(System.Func{System.Int32})">
            <summary>
            Saves the base stream position, sets the base position to match the
            virtual substream position, executes the operation and then restores the
            base stream position.
            </summary>
            <param name="operation">The operation to be performed.</param>
            <returns>The operation result.</returns>
        </member>
        <member name="P:Neon.IO.SubStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.SubStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.SubStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.SubStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.SubStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.ReadByte">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.SubStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            <b>Not Implemented</b>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Neon.IO.SubStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            <b>Not Implemented</b>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Neon.IO.SubStream.EndRead(System.IAsyncResult)">
            <summary>
            <b>Not Implemented</b>
            </summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:Neon.IO.SubStream.EndWrite(System.IAsyncResult)">
            <summary>
            <b>Not Implemented</b>
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="T:Neon.IO.TempFile">
            <summary>
            Generates a globally unique temporary file name and then 
            ensures that the file is removed when the instance is 
            disposed.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFile.Root">
            <summary>
            Optionally specifies the root directory where the temporary files will
            be created.  This defaults to <see cref="M:System.IO.Path.GetTempPath"/>
            when this is <c>null</c> or empty and can be overridden for specific
            instances by passing a folder path the the constructor.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFile.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="suffix">
            Optionally specifies the file suffix (including the leading period) to be
            appended to the generated file name.  This defaults to <b>.tmp</b>.
            </param>
            <param name="folder">
            Optionally specifies the target folder.  This defaults to the standard
            temporary directory for the current user.
            </param>
        </member>
        <member name="M:Neon.IO.TempFile.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.TempFile.Path">
            <summary>
            Returns the fully qualified path to the temporary file.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFile.Name">
            <summary>
            Returns the file name only.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFile.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.TempFolder">
            <summary>
            Manages a temporary file system folder to be used for the duration of a unit test.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFolder.Root">
            <summary>
            Optionally specifies the root directory where the temporary folders will
            be created.  This defaults to <see cref="M:System.IO.Path.GetTempPath"/>
            when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFolder.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Creates a temporary folder.
            </summary>
            <param name="rootFolder">Optionally overrides <see cref="P:Neon.IO.TempFolder.Root"/> as the parent folder for this instance.</param>
            <param name="prefix">Optionally specifies a prefix to be added to the temporary directory name.</param>
            <param name="create">Optionally controls whether the temporary folder should actually be created.  This defaults to <c>true</c>.</param>
        </member>
        <member name="M:Neon.IO.TempFolder.#ctor(System.String,Neon.Common.Stub.Value)">
            <summary>
            Used to construct an instance referencing an existing folder.
            </summary>
            <param name="existingPath">Specifies the path to the existing folder.</param>
            <param name="stub">Used to disambiguate this constructor from <see cref="M:Neon.IO.TempFolder.#ctor(System.String,System.String,System.Boolean)"/></param>
        </member>
        <member name="P:Neon.IO.TempFolder.Path">
            <summary>
            Returns the fully qualifed path to the temporary folder.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFolder.DisableDelete">
            <summary>
            Optionally used to disable folder deletion when the temporary folder is disposed.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFolder.Dispose">
            <summary>
            Deletes the temporary folder and all of its contents.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFolder.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.ModelGen.ActionResult`1">
            <summary>
            Used to indicate that a service method uses the <c>IActionResult</c>
            pattern to return a <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type being returned.</typeparam>
        </member>
        <member name="T:Neon.ModelGen.ApiVersion">
             <summary>
             Used to specify ASP.NET API versions.
             </summary>
             <remarks>
             <para>
             API versions are formatted like:
             </para>
             <code>
             [VERSIONGROUP.]MAJOR.MINOR[-STATUS]
            
             or:
            
             VERSIONGROUP[MAJOR[.MINOR]][-STATUS]
             </code>
             <para>
             where <b>VERSIONGROUP</b> is a date formatted like <b>YYYY-MM-DD</b>,
             <b>MAJOR</b> and <b>MINOR</b> are non-negative integers, and <b>STATUS</b>
             is an alphanumberic string starting with a letter.  Here are some valid
             version strings:
             </para>
             <list type="table">
             <item>
                 <term><b>1.0</b></term>
                 <description>
                 major and minor version numbers
                 </description>
             </item>
             <item>
                 <term><b>1.0-alpha</b></term>
                 <description>
                 major and minor version numbers with status
                 </description>
             </item>
             <item>
                 <term><b>2023-04-09</b></term>
                 <description>
                 Version group date
                 </description>
             </item>
             <item>
                 <term><b>2023-04-09-alpha</b></term>
                 <description>
                 Version group date with status
                 </description>
             </item>
             <item>
                 <term><b>2023-04-09.1.0</b></term>
                 <description>
                 Version group with major and minor versions
                 </description>
             </item>
             <item>
                 <term><b>2023-04-09.1.0-alpha</b></term>
                 <description>
                 Version group with major and minor versions plus status
                 </description>
             </item>
             <item>
                 <term><b>2023-04.091</b></term>
                 <description>
                 <para>
                 Version group with only major version <b>(1)</b>
                 </para>
                 <note>
                 This format is a bit odd and may be confusing.  We recommend that 
                 you avoid using this.
                 </note>
                 </description>
             </item>
             <item>
                 <term><b>2023-04.091-alpha</b></term>
                 <description>
                 <para>
                 Version group with only major version <b>(1)</b> and status
                 </para>
                 <note>
                 This format is a bit odd and may be confusing.  We recommend that 
                 you avoid using this.
                 </note>
                 </description>
             </item>
             <item>
                 <term><b>2023-04.091.0</b></term>
                 <description>
                 <para>
                 Version group with major and minor versions
                 </para>
                 <note>
                 This format is a bit odd and may be confusing.  We recommend that 
                 you avoid using this.
                 </note>
                 </description>
             </item>
             <item>
                 <term><b>2023-04.091.0-alpha</b></term>
                 <description>
                 <para>
                 Version group with major and minor versions with status
                 </para>
                 <note>
                 This format is a bit odd and may be confusing.  We recommend that 
                 you avoid using this.
                 </note>
                 </description>
             </item>
             </list>
             </remarks>
        </member>
        <member name="M:Neon.ModelGen.ApiVersion.Parse(System.String)">
             <summary>
             <para>
             Parses a <see cref="T:Neon.ModelGen.ApiVersion"/>, formatted like:
             </para>
             <para>
             API versions are formatted like:
             </para>
             <code>
             [VERSIONGROUP.]MAJOR.MINOR[-STATUS]
            
             or:
            
             VERSIONGROUP[MAJOR[.MINOR]][-STATUS]
             </code>
             <para>
             where <b>VERSIONGROUP</b> is a date formatted like <b>YYYY-MM-DD</b>,
             <b>MAJOR</b> and <b>MINOR</b> are non-negative integers, and <b>STATUS</b>
             is an alphanumberic string starting with a letter.
             </para>
             </summary>
             <param name="version">The version string,</param>
             <returns>The parsed <see cref="T:Neon.ModelGen.ApiVersion"/>.</returns>
             <exception cref="T:System.FormatException">Thrown for an invalid version string.</exception>
        </member>
        <member name="M:Neon.ModelGen.ApiVersion.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.ApiVersion.VersionGroup">
            <summary>
            <para>
            Returns the version group date.
            </para>
            <note>
            This returns as <b>0001-01-01</b> when the parsed version string
            didn't include a version group.
            </note>
            </summary>
        </member>
        <member name="P:Neon.ModelGen.ApiVersion.Major">
            <summary>
            <para>
            Returns the major version number.
            </para>
            <note>
            This returns as <b>-1</b> when the parsed version string didn't include a major version.
            </note>
            </summary>
        </member>
        <member name="P:Neon.ModelGen.ApiVersion.Minor">
            <summary>
            <para>
            Returns the minor version number.
            </para>
            <note>
            This returns as <b>-1</b> when the parsed version string didn't include a minor version.
            </note>
            </summary>
        </member>
        <member name="P:Neon.ModelGen.ApiVersion.Status">
            <summary>
            <para>
            Returns the status part.
            </para>
            <note>
            This return an empty string when the parse version string didn't include status.
            Note also that versions with a <see cref="P:Neon.ModelGen.ApiVersion.Status"/> are considered to be <b>greater</b>
            than a version without a <see cref="P:Neon.ModelGen.ApiVersion.Status"/> when all other properties are the same.
            </note>
            </summary>
        </member>
        <member name="M:Neon.ModelGen.ApiVersion.CompareTo(Neon.ModelGen.ApiVersion)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.ModelGen.ApiVersion.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.ModelGen.ApiVersionAttribute">
             <summary>
             <para>
             Used to tag an ASP.NET controller interface or method with an API version.  Versions
             are formatted like:
             </para>
             <code>
             [VERSIONGROUP.]MAJOR.MINOR[-STATUS]
            
             or:
            
             VERSIONGROUP[MAJOR[.MINOR]][-STATUS]
             </code>
             <para>
             where <b>VERSIONGROUP</b> is a date formatted like <b>YYYY-MM-DD</b>, <b>MAJOR</b>
             and <b>MINOR</b> are non-negative integers and <b>STATUS</b> is a string of like
             <b>alphs</b>, <b>preview</b>, etc. consisting of the following characters:
             <b>a-z</b>, <b>A-Z</b>, <b>0-9</b>, <b>"."</b> and <b>"-"</b>.
             </para>
             </summary>
        </member>
        <member name="M:Neon.ModelGen.ApiVersionAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="version">Specifies the API version string.</param>
        </member>
        <member name="P:Neon.ModelGen.ApiVersionAttribute.Version">
            <summary>
            Returns parsed <see cref="T:Neon.ModelGen.ApiVersion"/>.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.BodyStreamAttribute">
            <summary>
            <para>
            Used to indicate that clients generated by <b>Neon.ModelGen</b> should
            include a <c>System.IO.Stream stream</c> parameter holding the data to 
            be included as the body of the request to the remote service.
            </para>
            <note>
            You may not combine <see cref="T:Neon.ModelGen.BodyStreamAttribute"/> and <see cref="T:Neon.ModelGen.FromBodyAttribute"/>
            attributes on the same model method.
            </note>
            <para>
            See the remarks for additional details.
            </para>
            </summary>
            <remarks>
            <para>
            Model methods tagged with the <see cref="T:Neon.ModelGen.BodyStreamAttribute"/> will be generated
            with <c>System.IO.Stream stream</c> as the first parameter and the generated client
            method will transmit bytes from the current stream position up to the end of the 
            stream up to the remote service.  By default, this will be accomplished using a
            <b>8 KiB</b> buffer but this can be customized via <see cref="P:Neon.ModelGen.BodyStreamAttribute.BufferSize"/>.
            </para>
            <para>
            By default the request <b>Content-Type</b> header will be set to <b>application/octet-stream</b>.
            You can customize this via <see cref="P:Neon.ModelGen.BodyStreamAttribute.ContentType"/>.
            </para>
            <para>
            For input streams that support <see cref="P:System.IO.Stream.CanSeek"/> the generated method will also include
            the <b>Content-Length</b> header.  This will be computed by subtracting the current stream position
            from the stream length.
            </para>
            <note>
            For some situations, you may need to upload from a stream that doesn't support <see cref="P:System.IO.Stream.CanSeek"/>
            but you already know how many bytes will be transmitted and the server method is expecting a 
            <b>Content-Length</b> header.  In this case, you can wrap your stream with a <see cref="T:Neon.IO.SubStream"/>
            configured with the starting and ending positions of the data in the original stream and then
            pass the <see cref="T:Neon.IO.SubStream"/> as the service client method's <c>stream</c> argument.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.ModelGen.BodyStreamAttribute.ContentType">
            <summary>
            Optionally overrides the uploaded content's MIME type.  This defaults 
            to <b>application/octet-stream</b>.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.BodyStreamAttribute.IncludeContentSize">
            <summary>
            Indicates that a <b>Content-Size</b> header will be included in the request,
            passing the size of the input stream.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.BodyStreamAttribute.BufferSize">
            <summary>
            Optionally specifies the size of the buffer in bytes that will be used
            by the generated API method for uploading the source stream to the server.
            This defaults to <b>8 KiB</b>.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.ControllerValidationAttribute">
            <summary>
            <para>
            Used to have the <c>Neon.Xunit.XunitExtensions.ValidateController&lt;T&gt;()</c>
            method including the tagged method when validating the service controller
            against its definining interface.  This is useful for rare situations where a
            service controller inherits from another class that implements some endpoints.
            </para>
            <note>
            By default, <c>Neon.Xunit.XunitExtensions.ValidateController&lt;T&gt;()</c>
            only considers service methods implemented directly in the service controller
            during validation.
            </note>
            </summary>
        </member>
        <member name="T:Neon.ModelGen.DataModelAttribute">
            <summary>
            Used to provide the model code generator additional information
            about a specific data type.  Use of this optional because the code
            generator assumes that all types that are not specifically tagged
            by <see cref="T:Neon.ModelGen.ServiceModelAttribute"/> are data types.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.DataModelAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.DataModelAttribute.Name">
            <summary>
            <para>
            Optionally specifies the type identifier that will be used by
            generated code to identify the object type at runtime. This
            will be used when deserializing the object.
            </para>
            <para>
            This defaults to the fully qualified name of the type as it
            appears in the source assembly as it is scanned by the code 
            generator.  You may want to set this to reduce the length
            or just to customize how your data is persistedd.
            </para>
            </summary>
        </member>
        <member name="T:Neon.ModelGen.FromBodyAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by parsing the request body as JSON.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.FromBodyAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.FromBodyAttribute.Name">
            <summary>
            This is ignored.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.FromHeaderAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by parsing a request header value.
            </summary>
            <remarks>
            By default, this option will look for the HTTP header with the same
            name as the tagged endpoint parameter.  This can be overriden by setting
            the <see cref="P:Neon.ModelGen.FromHeaderAttribute.Name"/> property.
            </remarks>
        </member>
        <member name="M:Neon.ModelGen.FromHeaderAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.FromHeaderAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method property
            name when generating the client code.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.FromQueryAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by parsing a request URI query parameter.
            </summary>
            <remarks>
            By default, this option will look for the query parameter with the same
            name as the tagged endpoint parameter.  This can be overriden by setting
            the <see cref="P:Neon.ModelGen.FromQueryAttribute.Name"/> property.
            </remarks>
        </member>
        <member name="M:Neon.ModelGen.FromQueryAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies URI query parameter name.  This defaults to 
            the actual parameter name.
            </param>
        </member>
        <member name="P:Neon.ModelGen.FromQueryAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method property
            name when generating the client code.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.FromRouteAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by extracting it from the URI route template.
            </summary>
            <remarks>
            By default, this option will look for the query parameter with the same
            name as the tagged endpoint parameter.  This can be overriden by setting
            the <see cref="P:Neon.ModelGen.FromRouteAttribute.Name"/> property.
            </remarks>
        </member>
        <member name="M:Neon.ModelGen.FromRouteAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies URI query parameter name.  This defaults to 
            the actual parameter name.
            </param>
        </member>
        <member name="P:Neon.ModelGen.FromRouteAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method property
            name when generating the client code.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.GeneratedClientAttribute">
            <summary>
            Used to tag generated service client classes with additional
            metadata that will be used when validatating the a generated service
            client actually matches an ASP.NET service implementation.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.GeneratedClientAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="routeTemplate">The controller's route template.</param>
        </member>
        <member name="P:Neon.ModelGen.GeneratedClientAttribute.RouteTemplate">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.GeneratedMethodAttribute">
            <summary>
            Used to tag generated service client methods with additional
            metadata that will be used when validatating the a generated service
            client actually matches an ASP.NET service implementation.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.GeneratedMethodAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.GeneratedMethodAttribute.DefinedAs">
            <summary>
            The method name from the service model definition.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.GeneratedMethodAttribute.Returns">
            <summary>
            The method result type.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.GeneratedMethodAttribute.RouteTemplate">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.GeneratedMethodAttribute.HttpMethod">
            <summary>
            The HTTP method for the endpoint.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.GeneratedMethodAttribute.ApiVersion">
            <summary>
            The API version used when calling this method or <c>null</c> when no version is specified.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.GeneratedParamAttribute">
            <summary>
            Used to tag generated service client method parameters with additional
            metadata that will be used when validatating the a generated service
            client actually matches an ASP.NET service implementation.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.GeneratedParamAttribute.#ctor(Neon.ModelGen.PassAs)">
            <summary>
            Constructor.
            </summary>
            <param name="passAs">Indicates how the client passes the tagged parameter to the service.</param>
        </member>
        <member name="P:Neon.ModelGen.GeneratedParamAttribute.PassAs">
            <summary>
            Indicates how the client passes the tagged parameter to the service.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.GeneratedParamAttribute.Name">
            <summary>
            Parameter name as it appears on the wire for parameters passed
            as a query, header, or route.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.HashSourceAttribute">
            <summary>
            Used to tag data model properties that should be included in the
            <see cref="M:System.Object.GetHashCode"/> computation.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HashSourceAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.HttpAttribute">
            <summary>
            Base class for the HTTP related attributes below.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.HttpAttribute.Template">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.HttpAttribute.HttpMethod">
            <summary>
            Returns the HTTP method.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.HttpAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method name when
            generating the client code.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.HttpAttribute.Order">
            <summary>
            <b>NOT SUPPORTED:</b> The order in which the route is to be applied.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.HttpDeleteAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>DELETE</b> method.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HttpDeleteAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.ModelGen.HttpGetAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>GET</b> method.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HttpGetAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.ModelGen.HttpHeadAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>HEAD</b> method.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HttpHeadAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.ModelGen.HttpOptionsAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>OPTIONS</b> method.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HttpOptionsAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.ModelGen.HttpPatchAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>PATCH</b> method.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HttpPatchAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.ModelGen.HttpPostAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>POST</b> method.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HttpPostAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.ModelGen.HttpPutAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>PUT</b> method.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.HttpPutAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.ModelGen.IActionResult">
            <summary>
            Used to indicate that a service method uses the <c>IActionResult</c>
            pattern to return <c>void</c>.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.NoCodeGenAttribute">
            <summary>
            Used to indicate that a class or interface should be ignored
            during code generation.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.NoControllerValidationAttribute">
            <summary>
            Used to prevent the <c>Neon.Xunit.XunitExtensions.ValidateController&lt;T&gt;()</c>
            method from including the tagged method when validating the service controller
            against its definining interface.  This is useful for rare situations where a
            service controller implements some extra endpoints that are not covered by the
            generated client.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.PassAs">
            <summary>
            Identifies how a generated service client will pass a parameter to 
            an ASP.NET service.
            </summary>
        </member>
        <member name="F:Neon.ModelGen.PassAs.Query">
            <summary>
            Passes the parameter is passed as a URI query parameter.
            </summary>
        </member>
        <member name="F:Neon.ModelGen.PassAs.Route">
            <summary>
            Passes the parameter within the URI route template. 
            </summary>
        </member>
        <member name="F:Neon.ModelGen.PassAs.Header">
            <summary>
            Passes the parameter as an HTTP header.
            </summary>
        </member>
        <member name="F:Neon.ModelGen.PassAs.Body">
            <summary>
            Passes the parameter as the HTTP request body. 
            </summary>
        </member>
        <member name="T:Neon.ModelGen.PersistableAttribute">
            <summary>
            <para>
            Used to customize the database related code generated for the tagged
            data model interface.
            </para>
            <para>
            By default, a <c>public static string GetKey(param object[] args)</c> method
            is included in generated entity classes so that a database key for a specific
            entity can be easialy obtained.  This method simply generates a string by
            calling <see cref="M:System.Object.ToString"/> on all of arguments or using <b>"NULL"</b>
            for <c>null</c> values which each of these being separated by a single colon
            and then prepending the entire thing with the entity type.  The generated code 
            will look something like this:
            </para>
            <code lang="C#">
            public class PersonEntity : Entity&lt;Person&gt;
            {
                public static string GetKey(params object[] args)
                {
                    if (args.Length == 0)
                    {
                        throw new ArgumentException("At least one argument is expected.");
                    }
                    
                    var key = "entity-type::";
                    
                    for (int i=0; i $lt; args.Length; i++)
                    {
                        var arg = args[i];
                        
                        if (i &gt; 0)
                        {
                            key += ":";
                        }
                        
                        key += arg != null ? arg.ToString() : "NULL";
                    }
            
                    return key;
                }
                
                ...
            }
            </code>
            </summary>
        </member>
        <member name="P:Neon.ModelGen.PersistableAttribute.GetKeyArgs">
            <summary>
            This property combined with <see cref="P:Neon.ModelGen.PersistableAttribute.GetKeyString"/> is used
            to generate a <c>public static string GetKey(...)</c> method.
            See the class remarks for more information.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.PersistableAttribute.GetKeyString">
            <summary>
            This property combined with <see cref="P:Neon.ModelGen.PersistableAttribute.GetKeyArgs"/> is used
            to generate a <c>public static string GetKey(...)</c> method.
            See the class remarks for more information.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.PersistableKeyAttribute">
            <summary>
            Used to tag the property acting as the database key for an <see cref="T:Neon.Data.IRoundtripData"/>.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.RouteAttribute">
            <summary>
            Used to customize request routing at the service level.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.RouteAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="P:Neon.ModelGen.RouteAttribute.Template">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.RouteAttribute.Name">
            <summary>
            The route name.
            </summary>
        </member>
        <member name="P:Neon.ModelGen.RouteAttribute.Order">
            <summary>
            <b>NOT SUPPORTED:</b> The order in which the route is to be applied.
            </summary>
        </member>
        <member name="T:Neon.ModelGen.ServiceModelAttribute">
            <summary>
            Used to indicate that an <c>interface</c> should be included when
            generating a service client class.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.ServiceModelAttribute.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies the name to be used for the generated
            service client class.  This defaults to the tagged controller
            class name with a "Controller" suffix being stripped off if
            present.
            </param>
            <param name="group">
            <para>
            Optionally specifies that the methods from this controller
            should be grouped together in a generated controller class
            composed from multiple service controllers.  Set this to the
            name to be used for the client property under which these 
            methods will be generated.
            </para>
            <note>
            <paramref name="name"/> must also be specified when <paramref name="group"/>
            is set.
            </note>
            </param>
        </member>
        <member name="P:Neon.ModelGen.ServiceModelAttribute.Name">
            <summary>
            <para>
            Returns the name to be used for the generated client class
            and for transmitting requests to the server or <c>null</c>
            if the name is to be derived from the tagged class name.
            </para>
            <note>
            The tagged controller class name will be used as the default
            name, stripping "Controller" off the end of the class name
            if present.
            </note>
            </summary>
        </member>
        <member name="P:Neon.ModelGen.ServiceModelAttribute.Group">
            <summary>
            <para>
            Optionally used to group multiple methods from different
            controllers with the same <see cref="P:Neon.ModelGen.ServiceModelAttribute.Name"/> together
            into the same generated service client class or subclass.
            </para>
            <para>
            This defaults to <c>null</c> which means that the service
            methods from the different controllers will be generated
            directly within the generated service client.  When this
            is not <c>null</c> or empty, a subclass using this name
            with "Client" appended will be generated with the methods
            from the controllers with this group name.
            </para>
            </summary>
        </member>
        <member name="T:Neon.ModelGen.TargetAttribute">
            <summary>
            Used to group data models and service definitions so that the
            class included in the generated code can filtered.
            </summary>
        </member>
        <member name="M:Neon.ModelGen.TargetAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The target name.</param>
        </member>
        <member name="P:Neon.ModelGen.TargetAttribute.Name">
            <summary>
            Returns the group name.
            </summary>
        </member>
        <member name="T:Neon.Net.HttpApiException">
            <summary>
            Thrown by ASP.NET web API implementations to optionally specify an error code
            that can ultimately be deserialized as the HTTP reason phrase by clients.
            </summary>
            <remarks>
            <para>
            The basic idea here is that non-type REST services will typically need to return
            a computer readable code to specify business logic level errors so that client
            programs can easily identify and handle problems without the need for parsing
            a potentially localized error message.
            </para>
            <note>
            We're restricting error codes to 1-32 characters including ASCII letters, digits, 
            undercores, dots, or dashes.
            </note>
            <note>
            This error code will be transmitted back to the client as the <b>>HTTP reason phrase</b>
            when specified or the standard reason phrase associated with the HTTP status code otherwise.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.HttpApiException.#ctor(System.String,System.String,System.Net.HttpStatusCode)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies the exception message.</param>
            <param name="errorCode">Optionally specifies the <see cref="T:System.Net.HttpStatusCode"/>.  This </param>
            <param name="statusCode">Optionally specifies the HTTP status code.  This defaults to <see cref="F:System.Net.HttpStatusCode.BadRequest"/>.</param>
            <remarks>
            <note>
            <paramref name="errorCode"/> is restricted to 1-32 characters including ASCII letters, digits, 
            undercores, dots, or dashes.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Net.HttpApiException.StatusCode">
            <summary>
            Returns the HTTP status code.
            </summary>
        </member>
        <member name="P:Neon.Net.HttpApiException.ErrorCode">
            <summary>
            Returns the business logic error code or <c>null</c>.
            </summary>
        </member>
        <member name="T:Neon.Net.HttpException">
            <summary>
            Describes an HTTP error.  These are commonly thrown by <see cref="T:Neon.Net.JsonClient"/> as well as
            HTTP clients generated by <b>neon-modelgen</b>.
            </summary>
            <remarks>
            <note>
            The <see cref="P:Neon.Net.HttpException.ReasonPhrase"/> property may be used as a way for services to return the computer
            readable specific error type.  This is configured by default by <b>Neon.Web</b> builder extensions
            and REST services may specify these codes to our base controller <b>Requires()</b> methods or
            by throwning a <b>HttpApiException</b>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.HttpException.GetMessage(System.String,System.String,System.String,System.Net.HttpStatusCode)">
            <summary>
            Constructs the exception message using the parameters passed.
            </summary>
            <param name="reasonPhrase">The HTTP response peason phrase (or <c>null</c>).</param>
            <param name="requestUri">Optionally specifies the request URL.</param>
            <param name="requestMethod">Optionally specifies the request method.</param>
            <param name="statusCode">Optionally specifies the response status code.</param>
        </member>
        <member name="M:Neon.Net.HttpException.#ctor(System.String,System.String,System.String,System.Net.HttpStatusCode)">
            <summary>
            Constructs an exception from the request and response details passed.
            </summary>
            <param name="reasonPhrase">The HTTP response reason phrase (or <c>null</c>).</param>
            <param name="requestUri">Optionally specifies the request URL.</param>
            <param name="requestMethod">Optionally specifies the request method.</param>
            <param name="statusCode">Optionally specifies the response status code.</param>
        </member>
        <member name="M:Neon.Net.HttpException.#ctor(System.Net.Http.HttpRequestException,System.String,System.String)">
            <summary>
            <para>
            Constructs an exception from a <see cref="T:System.Net.Http.HttpRequestException"/> and optionals
            request details.
            </para>
            <note>
            This constructor does not initialize the <see cref="P:Neon.Net.HttpException.StatusCode"/> property for 
            .NET Standard 2.x, .NET Core 3.x, and .NET Framework and the <see cref="P:Neon.Net.HttpException.ReasonPhrase"/>
            is set to the message from <paramref name="requestException"/>.
            </note>
            </summary>
            <param name="requestException">The <see cref="T:System.Net.Http.HttpRequestException"/>.</param>
            <param name="requestUri">Optionally specifies the request URL.</param>
            <param name="requestMethod">Optionally specifies the request method.</param>
        </member>
        <member name="M:Neon.Net.HttpException.#ctor(System.Net.Http.HttpResponseMessage)">
            <summary>
            Constructs an exception from an <see cref="T:System.Net.Http.HttpResponseMessage"/>.
            </summary>
            <param name="response"></param>
            <exception cref="T:System.InvalidOperationException">Thrown when the response message does not indicate an error.</exception>
        </member>
        <member name="P:Neon.Net.HttpException.ReasonPhrase">
            <summary>
            Returns the HTTP response status message.
            </summary>
        </member>
        <member name="P:Neon.Net.HttpException.RequestUri">
            <summary>
            Returns the request URI when known.
            </summary>
        </member>
        <member name="P:Neon.Net.HttpException.RequestMethod">
            <summary>
            Returns the request requestMethod when known.
            </summary>
        </member>
        <member name="P:Neon.Net.HttpException.StatusCode">
            <summary>
            Returns the HTTP response status code.
            </summary>
        </member>
        <member name="T:Neon.Net.JsonClient">
            <summary>
            Implements a light-weight JSON oriented HTTP client.
            </summary>
            <remarks>
            <para>
            Use <see cref="M:Neon.Net.JsonClient.GetAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, 
            <see cref="M:Neon.Net.JsonClient.PutAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, 
            <see cref="M:Neon.Net.JsonClient.PostAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, 
            <see cref="M:Neon.Net.JsonClient.DeleteAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>,
            <see cref="M:Neon.Net.JsonClient.OptionsAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>,
            <see cref="M:Neon.Net.JsonClient.HeadAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, or
            <see cref="M:Neon.Net.JsonClient.PatchAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>
            to perform HTTP operations that ensure that a non-error HTTP status code is returned by the servers.
            </para>
            <para>
            Use <see cref="M:Neon.Net.JsonClient.GetUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, 
            <see cref="M:Neon.Net.JsonClient.PutUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, 
            <see cref="M:Neon.Net.JsonClient.PostUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, 
            <see cref="M:Neon.Net.JsonClient.DeleteUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>,
            <see cref="M:Neon.Net.JsonClient.OptionsUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>,
            <see cref="M:Neon.Net.JsonClient.HeadUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>, or
            <see cref="M:Neon.Net.JsonClient.PatchUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)"/>
            to perform an HTTP without ensuring a non-error HTTP status code.
            </para>
            <para>
            This class can also handle retrying operations when transient errors are detected.  Customize 
            <see cref="P:Neon.Net.JsonClient.SafeRetryPolicy"/> and/or <see cref="P:Neon.Net.JsonClient.UnsafeRetryPolicy"/> by setting a <see cref="T:Neon.Retry.IRetryPolicy"/> 
            implementation such as <see cref="T:Neon.Retry.LinearRetryPolicy"/> or <see cref="T:Neon.Retry.ExponentialRetryPolicy"/>.
            </para>
            <note>
            This class initializes <see cref="P:Neon.Net.JsonClient.SafeRetryPolicy"/> to a reasonable <see cref="T:Neon.Retry.ExponentialRetryPolicy"/> by default
            and <see cref="P:Neon.Net.JsonClient.UnsafeRetryPolicy"/> to <see cref="T:Neon.Retry.NoRetryPolicy"/>.  You can override the default
            retry policy for specific requests using the methods that take an <see cref="T:Neon.Retry.IRetryPolicy"/> as 
            their first parameter.
            </note>
            <note>
            <para>
            The <see cref="T:Neon.Net.JsonClientPayload"/> class can be used to customize both the <b>Content-Type</b> header
            and the actual payload uploaded with <b>POST</b> and <b>PUT</b> requests.  This can be used for those
            <i>special</i> REST APIs that don't accept JSON payloads.
            </para>
            <para>
            All you need to do is construct a <see cref="T:Neon.Net.JsonClientPayload"/> instance, specifying the value to
            be used as the <b>Content-Type</b> header and the payload data as text or a byte array and then pass
            this as the <b>document</b> parameter to the methods that upload content.  The methods will recognize
            this special type and just send the specified data rather than attempting to serailize the document
            to JSON.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.JsonClient.#ctor(System.Net.Http.HttpMessageHandler,System.Boolean)">
            <summary>
            Used to construct a client for most situations, optionally specifying a custom <see cref="T:System.Net.Http.HttpMessageHandler"/>.
            </summary>
            <param name="handler">The optional message handler.</param>
            <param name="disposeHandler">Indicates whether the handler passed will be disposed automatically (defaults to <c>false</c>).</param>
        </member>
        <member name="M:Neon.Net.JsonClient.#ctor(System.Net.Http.HttpClient)">
            <summary>
            Used in special situations (like ASP.NET Blazor) where a special <see cref="P:Neon.Net.JsonClient.HttpClient"/> needs
            to be created and provided.
            </summary>
            <param name="httpClient">The special <see cref="P:Neon.Net.JsonClient.HttpClient"/> instance to be wrapped.</param>
        </member>
        <member name="M:Neon.Net.JsonClient.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClient.Dispose">
            <summary>
            Releases all resources associated with the instance.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClient.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="P:Neon.Net.JsonClient.BaseAddress">
            <summary>
            The default base <see cref="T:System.Uri"/> the client will use when relative
            URIs are specified for requests.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.Timeout">
            <summary>
            The default base <see cref="T:System.Uri"/> the client will use when relative
            URIs are specified for requests.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.DefaultRequestHeaders">
            <summary>
            Returns the base client's default request headers property to make it easy
            to customize request headers.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.DocumentType">
            <summary>
            Specifies the MIME type to use posting or putting documents to the endpoint.
            This defaults to the standard <b>application/json</b> but some services
            may require custom values.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.HttpClient">
            <summary>
            Returns the underlying <see cref="T:System.Net.Http.HttpClient"/>.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.SafeRetryPolicy">
            <summary>
            <para>
            The <see cref="T:Neon.Retry.IRetryPolicy"/> to be used to detect and retry transient network and HTTP
            errors for the <b>safe</b> methods.  This defaults to <see cref="T:Neon.Retry.ExponentialRetryPolicy"/> with 
            the transient detector function set to <see cref="M:Neon.Retry.TransientDetector.NetworkOrHttp(System.Exception)"/>.
            </para>
            <note>
            You may set this to <c>null</c> to disable safe transient error retry.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.UnsafeRetryPolicy">
            <summary>
            <para>
            The <see cref="T:Neon.Retry.IRetryPolicy"/> to be used to detect and retry transient network errors for the
            <b>unsafe</b> methods.  This defaults to <see cref="T:Neon.Retry.NoRetryPolicy"/>.
            </para>
            <note>
            You may set this to <c>null</c> to disable unsafe transient error retry.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClient.AbsoluteUri(System.String)">
            <summary>
            Converts a relative URI into an absolute URI if necessary.
            </summary>
            <param name="uri">The URI.</param>
            <returns>The absolute URI.</returns>
        </member>
        <member name="M:Neon.Net.JsonClient.FormatUri(System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Formats the URI by appending query arguments as required.
            </summary>
            <param name="uri">The base URI.</param>
            <param name="args">The query arguments.</param>
            <returns>The formatted URI.</returns>
        </member>
        <member name="M:Neon.Net.JsonClient.CreateContent(System.Object,System.IO.Stream)">
            <summary>
            <para>
            Converts the object passed into JSON content suitable for transmitting in
            an HTTP request.
            </para>
            <note>
            This method handles <see cref="T:Neon.Net.JsonClientPayload"/> documents specially 
            as described in the <see cref="T:Neon.Net.JsonClient"/> remarks.
            </note>
            </summary>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="stream">
            Optionally passed as the <see cref="T:System.IO.Stream"/> being uploaded as the body.  If this stream
            supports <see cref="P:System.IO.Stream.CanSeek"/> then this method will compute the number of bytes
            that will be uploaded and add a <b>Content-Length</b> header to the request when <paramref name="document"/>
            is a <see cref="T:Neon.Net.StreamDocument"/>.
            </param>
            <returns>Tne <see cref="T:System.Net.Http.HttpContent"/>.</returns>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>DELETE</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteAsync``1(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>DELETE</b> returning a specific type and ensuring that a success cxode was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>DELETE</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring 
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>DELETE</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>DELETE</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring 
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>GET</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetAsync``1(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>GET</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>GET</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/>" and ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>GET</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>GET</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and 
            without ensuring that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>HEAD</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>HEAD</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>HEAD</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>HEAD</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>HEAD</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PATCH</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PATCH</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PATCH</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PATCH</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PATCH</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>POST</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>POST</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>POST</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>POST</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>POST</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PUT</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PUT</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PUT</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/>" and ensuring that a 
            success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PUT</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken)">
            <summary>
            Performs an HTTP <b>PUT</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/>" and without 
            ensuring that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The target URI.</param>
            <param name="document">
            The optional object to be uploaded as the request payload.  This may be JSON text, a plain
            old object that will be serialized as JSON or a <see cref="T:Neon.Net.StreamDocument"/> to upload body
            data from a <see cref="T:System.IO.Stream"/>.
            </param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="T:Neon.Net.JsonClientPayload">
            <summary>
            Passed as the <b>document</b> to be uploaded with a <see cref="T:Neon.Net.JsonClient"/> <b>POST</b>
            or <b>PUT</b> request to customize the payload data and content-type.  This can be used
            in special situations where a REST API needs to push <b>application/x-www-form-urlencoded</b>
            data or other formats.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClientPayload.#ctor(System.String,System.String)">
            <summary>
            <para>
            Constructs an instance from the <b>Content-Type</b> header and text to be 
            included with the POST/PUT.
            </para>
            <note>
            The uploaded text will be <b>UTF-8</b> encoded.
            </note>
            </summary>
            <param name="contentType">The value to be passed as the request's <b>Content-Type</b> header.</param>
            <param name="text">The text payload.</param>
        </member>
        <member name="M:Neon.Net.JsonClientPayload.#ctor(System.String,System.Byte[])">
            <summary>
            Constructs an instance from the <b>Content-Type</b> header and byte data to be 
            included with the POST/PUT.
            </summary>
            <param name="contentType">The value to be passed as the request's <b>Content-Type</b> header.</param>
            <param name="bytes">The bytes to be uploaded.</param>
        </member>
        <member name="P:Neon.Net.JsonClientPayload.ContentType">
            <summary>
            Returns the HTTP <b>Content-Type</b> header to be included in the POST/PUT request.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClientPayload.ContentBytes">
            <summary>
            Returns the payload bytes to be included in the POST/PUT request.
            </summary>
        </member>
        <member name="T:Neon.Net.JsonResponse">
            <summary>
            Encapsulates the response returned from a <see cref="T:Neon.Net.JsonClient"/> 
            server call.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonResponse.#ctor(System.String,System.String,System.Net.Http.HttpResponseMessage,System.String)">
            <summary>
            Constructs a <see cref="T:Neon.Net.JsonResponse"/> from a lower level <see cref="T:System.Net.Http.HttpResponseMessage"/>.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="requestMethod">The request method.</param>
            <param name="httpRespose">The low-level HTTP response.</param>
            <param name="responseText">The response text.</param>
        </member>
        <member name="P:Neon.Net.JsonResponse.RequestUri">
            <summary>
            Returns the request URI.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonResponse.RequestMethod">
            <summary>
            Returns the request method.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonResponse.HttpResponse">
            <summary>
            Returns the low-level HTTP response.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonResponse.JsonText">
            <summary>
            Returns the response as JSON text or <c>null</c> if the server didn't
            respond with JSON.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonResponse.AsDynamic">
            <summary>
            Returns the dynamic JSON response document, array, value or <c>null</c> if the server didn't return
            JSON content.
            </summary>
            <returns>The dynamic document or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Net.JsonResponse.As``1">
            <summary>
            Converts the response document to a specified type or <c>null</c> if the server didn't 
            return JSON content.
            </summary>
            <typeparam name="TResult">The specified type.</typeparam>
            <returns>The converted document or its default value.</returns>
        </member>
        <member name="P:Neon.Net.JsonResponse.StatusCode">
            <summary>
            Returns the HTTP response status code.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonResponse.IsSuccess">
            <summary>
            Returns <c>true</c> if the response status code indicates success.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonResponse.EnsureSuccess">
            <summary>
            Ensures that the status code indicates success by throwing an 
            exception for any error related status codes.
            </summary>
            <exception cref="T:Neon.Net.HttpException">Thrown if the response doesn't indicate success.</exception>
        </member>
        <member name="T:Neon.Net.Jwt">
            <summary>
            A lightweight implementation of Json Web Token (JWT) suitable for use by
            client applications.  The JWT structure is described <a href="https://jwt.io/introduction/">here</a>.
            </summary>
        </member>
        <member name="M:Neon.Net.Jwt.Parse(System.String)">
            <summary>
            <para>
            Parses a <see cref="T:Neon.Net.Jwt"/> from an encoded string.
            </para>
            <note>
            <b>WARNING:</b> This method <b>does not verify the signature</b> so it is <b>not suitable for
            verifying a JWT's authenticity</b>.
            </note>
            </summary>
            <param name="jwtString">The encoded JWT string.</param>
            <returns>The parsed <see cref="T:Neon.Net.Jwt"/> instance.</returns>
            <exception cref="T:System.FormatException">Thrown if the JWT format is invalid.</exception>
        </member>
        <member name="M:Neon.Net.Jwt.#ctor(System.String)">
            <summary>
            Private constructor.
            </summary>
            <param name="jwtString">The encoded JWT string.</param>
            <exception cref="T:System.FormatException">Thrown if the JWT format is invalid.</exception>
        </member>
        <member name="P:Neon.Net.Jwt.Header">
            <summary>
            Returns a Newtonsoft <see cref="T:Newtonsoft.Json.Linq.JObject"/> with the JWT <b>header</b> properties.
            </summary>
        </member>
        <member name="P:Neon.Net.Jwt.Payload">
            <summary>
            Returns a Newtonsoft <see cref="T:Newtonsoft.Json.Linq.JObject"/> with the JWT <b>payload</b> properties.
            </summary>
        </member>
        <member name="P:Neon.Net.Jwt.Signature">
            <summary>
            Returns the JWT <b>signature</b> as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Net.Jwt.ToString">
            <summary>
            <para>
            Renders the JWT back into its encoded string format.
            </para>
            <note>
            This method currently returns the original string used to parse the JWT.  It does
            not actually perform any encoding so any changes made to the properties will not
            be included in the output.
            </note>
            </summary>
            <returns>The encode JWT.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the JWT wasn't parsed from a string.</exception>
        </member>
        <member name="T:Neon.Net.LocalHostSection">
            <summary>
            Returned by <see cref="M:Neon.Net.NetHelper.ListLocalHostsSections"/> holding information about
            a named section of host entries within the local <b>$/etc/hosts</b> file.
            </summary>
        </member>
        <member name="M:Neon.Net.LocalHostSection.#ctor(System.String,System.Collections.Generic.Dictionary{System.String,System.Net.IPAddress})">
            <summary>
            Constructor.
            </summary>
            <param name="name">Identifies the section.</param>
            <param name="hostEntries">The dictionary of hostname/address entries.</param>
        </member>
        <member name="P:Neon.Net.LocalHostSection.Name">
            <summary>
            Returns the section name.
            </summary>
        </member>
        <member name="P:Neon.Net.LocalHostSection.HostEntries">
            <summary>
            Returns the dictionary of hostname/address entries.
            </summary>
        </member>
        <member name="T:Neon.Net.NamespaceDoc">
            <summary>
            This namespace defines <see cref="T:Neon.Net.JsonClient"/> which makes calling REST APIs easier as well
            as a handful of other network related utilities provided by <see cref="T:Neon.Net.NetHelper"/> and
            <see cref="T:Neon.Net.Pinger"/>.
            </summary>
        </member>
        <member name="T:Neon.Net.NetConst">
            <summary>
            Network related constants.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.DefaultMTU">
            <summary>
            <para>
            The default message transmission unit that is commonly configured
            across the internet.  This is the size in bytes of the largest
            packet including all of the protocol headers from OSI layers 3
            and above.  This does not include the data link (e.g. Ethernet)
            overhead.
            </para>
            <para>
            Packets larger than this may need to be fragmented (if allowed)
            to be transmitted end-to-end across several connected networks.
            </para>
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.VXLANHeader">
            <summary>
            The size of VXLAN headers in bytes.  <a href="VXLAN">https://en.wikipedia.org/wiki/Virtual_Extensible_LAN</a>
            is a protocol used in cloud and other virtualization environments
            to scale and separate network traffic between multiple tenants.
            Network traffic is empasulated in UDP packets with a header added
            to that identifies the virtual network.  This constant specifies
            the header overhead in bytes.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.IPHeader">
            <summary>
            The size in bytes of an IP packet header.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.TCPHeader">
            <summary>
            The size in bytes of all headers (IP and TCP) added to a TCP packet.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.ICMPHeader">
            <summary>
            The size in bytes of an ICMP packet header.
            </summary>
        </member>
        <member name="T:Neon.Net.NetHelper">
            <summary>
            Useful network related utilities.
            </summary>
        </member>
        <member name="M:Neon.Net.NetHelper.IsValidDnsLabel(System.String)">
            <summary>
            Verifies that a string is a valid DNS label.
            </summary>
            <param name="label">The label being tested.</param>
            <returns></returns>
        </member>
        <member name="M:Neon.Net.NetHelper.IsValidDnsHost(System.String)">
            <summary>
            Verifies that a string is a valid DNS hostname.
            </summary>
            <param name="host">The hostname being tested.</param>
            <returns><c>true</c> if the hostname is valid.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.ParseIPv4Address(System.String)">
            <summary>
            Parses an IPv4 address.
            </summary>
            <param name="input">The address text.</param>
            <returns>The <see cref="T:System.Net.IPAddress"/>.</returns>
            <exception cref="T:System.FormatException">Thrown for an invalid address.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.TryParseIPv4Address(System.String,System.Net.IPAddress@)">
            <summary>
            Attempts to parse an IPv4 address.
            </summary>
            <param name="input">The address text.</param>
            <param name="address">Set to the parsed address on success.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.ParseIPv6Address(System.String)">
            <summary>
            Parses an IPv6 address.
            </summary>
            <param name="input">The address text.</param>
            <returns>The <see cref="T:System.Net.IPAddress"/>.</returns>
            <exception cref="T:System.FormatException">Thrown for an invalid address.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.TryParseIPv6Address(System.String,System.Net.IPAddress@)">
            <summary>
            Attempts to parse an IPv4 address.
            </summary>
            <param name="input">The address text.</param>
            <param name="address">Set to the parsed address on success.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.AddressEquals(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Determines whether two IP addresses are equal.
            </summary>
            <param name="address1">Address 1.</param>
            <param name="address2">Address 2.</param>
            <returns><c>true</c> if the addresses are equal.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.AddressIncrement(System.Net.IPAddress,System.Int32)">
            <summary>
            Increments an IPv4 address by adding an integer value.
            </summary>
            <param name="address">The input IPv4 address.</param>
            <param name="incrementBy">The increment value (defaults to <b>+1</b>).</param>
            <returns>The next address or <b>0.0.0.0</b> when we wrap-around the address space.</returns>
            <exception cref="T:System.NotSupportedException">Thrown for non-IPv4 addresses.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.AddressToUint(System.Net.IPAddress)">
            <summary>
            Converts an IPv4 address into a 32-bit unsigned integer equivalent.
            </summary>
            <param name="address">The input IPv4 address.</param>
            <returns>The 32-bit unsigned integer equivalent.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.UintToAddress(System.UInt32)">
            <summary>
            Converts an unsigned 32-bit integer into an IPv4 address.
            </summary>
            <param name="value">The input value.</param>
            <returns>The <see cref="T:System.Net.IPAddress"/>.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.IsValidPort(System.Int32)">
            <summary>
            Determines whether an integer is a valid network port number.
            </summary>
            <param name="port">The port.</param>
            <returns><c>true</c> if the port is valid.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.GetRandomAddress">
            <summary>
            Returns a usable random IP address for use for DNS reolutions.
            </summary>
            <returns>The generated <see cref="T:System.Net.IPAddress"/>.</returns>
        </member>
        <member name="F:Neon.Net.NetHelper.HostsSectionBeginMarker">
            <summary>
            Line prefix indicating the start of an <b>$/etc/hosts</b> section.
            </summary>
        </member>
        <member name="F:Neon.Net.NetHelper.HostsSectionEndMarker">
            <summary>
            Line prefix indicating the end of an <b>$/etc/hosts</b> section.
            </summary>
        </member>
        <member name="M:Neon.Net.NetHelper.ValidateHostsSection(System.String)">
            <summary>
            Validates a hosts section name.
            </summary>
            <param name="section">The section name being checked.</param>
            <exception cref="T:System.ArgumentNullException">Thrown for empty or <c>null</c> sections.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the exception includes an invalid character.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.ModifyLocalHosts(System.String,System.Collections.Generic.Dictionary{System.String,System.Net.IPAddress})">
            <summary>
            <para>
            Used to modify the <b>$/etc/hosts</b> file used by the DNS resolver for testing, debugging 
            and possibly other purposes.
            </para>
            <note>
            <b>WARNING:</b> Modifying the <b>hosts</b> file will impact all processes
            on the system, not just the current process.
            </note>
            </summary>
            <param name="section">
            <para>
            Specifies the string to use to delimit the host names section.  This is required and
            must be a non-empty string consisting of up to 63 non-control ASCII characters.  Section
            names are case sensitive.
            </para>
            </param>
            <param name="hostEntries">A dictionary mapping the hostnames to an IP address or <c>null</c>.</param>
            <remarks>
            <note>
            This method requires elevated administrative privileges.
            </note>
            <para>
            This method adds or removes a temporary section of host entry definitions
            delimited by special comment lines.  When <paramref name="hostEntries"/> is 
            non-null and non-empty, the section will be added or updated.  Otherwise, the
            section will be removed.
            </para>
            <para>
            You can remove all host sections by passing both <paramref name="hostEntries"/> 
            and <paramref name="section"/> as <c>null</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.ListLocalHostsSections">
            <summary>
            Lists the names of the local host sections.
            </summary>
            <returns>The section names converted to uppercase.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.RewriteOn20thRetry(System.String,System.Collections.Generic.List{System.String},System.Int32@)">
            <summary>
            Rewrites the hosts file on the 20th retry.
            </summary>
            <param name="hostsPath">Path to the hosts file.</param>
            <param name="lines">The host file lines.</param>
            <param name="retryCount">The retry count.</param>
        </member>
        <member name="M:Neon.Net.NetHelper.GetHostAddresses(System.String)">
            <summary>
            Performs a synchronous DNS lookup.
            </summary>
            <param name="hostname">The target hostname.</param>
            <returns>The array of IP addresses resolved or an empty array if the hostname lookup failed.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.GetHostAddressesAsync(System.String)">
            <summary>
            Performs an asynchronous DNS lookup.
            </summary>
            <param name="hostname">The target hostname.</param>
            <returns>The array of IP addresses resolved or an empty array if the hostname lookup failed.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.GetReachableHost(System.Collections.Generic.IEnumerable{System.String},Neon.Net.ReachableHostMode)">
            <summary>
            Pings one or more hostnames or IP addresses in parallel to identify one that
            appears to be online and reachable via the network (because it answers a ping).
            </summary>
            <param name="hosts">The hostname or IP addresses to be tested.</param>
            <param name="failureMode">
            Specifies what should happen when there are no reachable hosts.  
            This defaults to <see cref="F:Neon.Net.ReachableHostMode.ReturnFirst"/>.
            </param>
            <returns>A <see cref="T:Neon.Net.ReachableHost"/> instance describing the host or <c>null</c>.</returns>
            <exception cref="T:Neon.Net.NetworkException">
            Thrown if no hosts are reachable and <paramref name="failureMode"/> is 
            passed as <see cref="F:Neon.Net.ReachableHostMode.Throw"/>.
            </exception>
        </member>
        <member name="M:Neon.Net.NetHelper.GetReachableHosts(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Pings one or more hostnames or IP addresses in parallel to identify those that
            appear to be online and reachable via the network (because it answers a ping).
            </summary>
            <param name="hosts">The hostname or IP addresses to be tested.</param>
            <returns>The <see cref="T:Neon.Net.ReachableHost"/> instances describing the reachable hosts (if any).</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.GetAddressUriHost(System.Net.IPAddress)">
            <summary>
            Converts an <see cref="T:System.Net.IPAddress"/> into a host name suitable for using as
            a <see cref="T:System.Uri"/> host name.  For IPv4 addresses, this just returns the
            address as a string.  For IPv6 address, this returns the address surrounded
            by "[...]" to make it compatible with URI standards.
            </summary>
            <param name="address">The IP address.</param>
            <returns>The host name suitable for including in a URI.</returns>
            <exception cref="T:System.NotSupportedException">Thrown for non IPv4 or IPv6 addresses.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.ComputeMSS(System.Int32,System.Boolean)">
            <summary>
            Computes the TCP maximum segment size for a given MTU, optionally taking a
            VXLAN wrapper headers into account.
            </summary>
            <param name="mtu">Specifies the target MTU (defaults to <see cref="F:Neon.Net.NetConst.DefaultMTU"/>).</param>
            <param name="vxLan">Optionally indicates that traffic is routed via a VXLAN.</param>
            <returns>The maximum segment size in bytes.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.TryParseIPv4Endpoint(System.String,System.Net.IPEndPoint@)">
            <summary>
            Attempts to parse an IPv4 network endpoint.
            </summary>
            <param name="input">The input string.</param>
            <param name="endpoint">Returns as the parsed endpoint.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.ParseIPv4Endpoint(System.String)">
            <summary>
            Parses an IPv4 endpoint from a string.
            </summary>
            <param name="input">The input.</param>
            <returns>The parsed <see cref="T:System.Net.IPEndPoint"/>.</returns>
            <exception cref="T:System.FormatException">Thrown if the input is not valid.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.GetUnusedTcpPort(System.Net.IPAddress)">
            <summary>
            Returns a free TCP port for a local network interface.
            </summary>
            <param name="address">
            Optionally specifies the target interface's IP address.  This defaults to
            <see cref="F:System.Net.IPAddress.Any"/> where an unused port will be returned that is
            available on all network interfaces.
            </param>
            <returns>The free port number.</returns>
            <exception cref="T:Neon.Net.NetworkException">Thrown when there are no available ports.</exception>
            <remarks>
            <note>
            <para>
            The behavior when <see cref="M:Neon.Net.NetHelper.GetUnusedTcpPort(System.Net.IPAddress)"/> is called multiple times
            without actually listening on the ports is somewhat undefined.
            </para>
            <para>
            We believe most operating systems won't return the same port again for
            a while (perhaps a few minutes) so you're probably safe retrieving a few
            unused ports before using them for testing and other non-production purposes.
            </para>
            <para>
            Production code should begin listening on and unused ports immediately after
            retrieving one.  This will ensure that the unused ports returned will be unique
            and also help avoid having another application grab the port before you have
            a chance to listen on it.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.GetUnusedTcpPort(System.Int32,System.Int32,System.Net.IPAddress)">
            <summary>
            Returns a free TCP port for a local network interface within a given range of ports.
            </summary>
            <param name="startPort">
            The first port to check
            </param>
            <param name="endPort">
            The last port to check.
            </param>
            <param name="address">
            Optionally specifies the target interface's IP address.  This defaults to
            <see cref="F:System.Net.IPAddress.Any"/> where an unused port will be returned that is
            available on all network interfaces.
            </param>
            <returns>The free port number.</returns>
            <exception cref="T:Neon.Net.NetworkException">Thrown when there are no available ports.</exception>
            <remarks>
            <note>
            <para>
            The behavior when <see cref="M:Neon.Net.NetHelper.GetUnusedTcpPort(System.Net.IPAddress)"/> is called multiple times
            without actually listening on the ports is somewhat undefined.
            </para>
            <para>
            We believe most operating systems won't return the same port again for
            a while (perhaps a few minutes) so you're probably safe retrieving a few
            unused ports before using them for testing and other non-production purposes.
            </para>
            <para>
            Production code should begin listening on and unused ports immediately after
            retrieving one.  This will ensure that the unused ports returned will be unique
            and also help avoid having another application grab the port before you have
            a chance to listen on it.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.TcpPortIsFree(System.Int32,System.Net.IPAddress)">
            <summary>
            Checks to see whether a TCP port is free on a given IP address.
            </summary>
            <param name="port">
            The port number.
            </param>
            <param name="address">
            The optional IP address. If not specified, defaults to <see cref="F:System.Net.IPAddress.Any"/>.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neon.Net.NetHelper.GetRoutableIpAddress">
            <summary>
            <para>
            Returns a routable (non-loopback) IPv4 address for the current machine.
            </para>
            <note>
            This returns a routable IP address from the network interface returned by
            <see cref="M:Neon.Net.NetHelper.GetConnectedInterface"/> when there is a connected interface.
            </note>
            </summary>
            <returns>The IP address or <c>null</c> if there doesn't appear to be a connected network interface.</returns>
            <remarks>
            <para>
            This works via a somewhat fragile heuristic.  We list all network interfaces,
            filter out those that are loopback, TAP interfaces, Hyper-V switches as well as 
            any that aren't up and then return the highest speed interface from any remaining
            interfaces.
            </para>
            <para>
            This may not work as expected for machines with multiple active connections
            to different networks.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.GetConnectedGatewayAddress">
            <summary>
            Returns an upstream getway address for the network interface returned by <see cref="M:Neon.Net.NetHelper.GetConnectedInterface"/>.
            </summary>
            <returns>The IP address or <c>null</c> if there doesn't appear to be a connected network interface.</returns>
            <remarks>
            <para>
            This works via a somewhat fragile heuristic.  We list all network interfaces,
            filter out those that are loopback, TAP interfaces, Hyper-V switches as well as 
            any that aren't up and then return the highest speed interface from any remaining
            interfaces.
            </para>
            <para>
            This may not work as expected for machines with multiple active connections
            to different networks.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.GetConnectedInterface">
            <summary>
            Returns a connected network interface with an IPv4 address.
            </summary>
            <returns>The connected interface or <c>null</c> if there doesn't appear to be a connected network interface.</returns>
            <remarks>
            <para>
            This works via a somewhat fragile heuristic.  We list all network interfaces,
            filter out those that are loopback, TAP interfaces, Hyper-V switches as well as 
            any that aren't up and then return the highest speed interface from any remaining
            interfaces.
            </para>
            <para>
            This may not work as expected for machines with multiple active connections
            to different networks.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.GetNetworkConfiguration">
            <summary>
            Returns basic information about the current network connection including the
            machine's routable IP address, the network CIDR and gateway as well as the
            DNS server addresses.
            </summary>
            <returns>
            A <see cref="T:Neon.Net.NetworkConfiguration"/> with the information or <c>null</c> 
            when the computer doesn't appear to be connected to a network.
            </returns>
            <remarks>
            This implementation is somewhat fragile because it relies on <see cref="M:Neon.Net.NetHelper.GetRoutableIpAddress"/> which
            uses heuristics to try to identify a suitable connected network.  This may not work as expected for machines
            with multiple active connections to different networks.
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.ToAwsS3Uri(System.String)">
            <summary>
            Converts an S3 or standard HTTPS URI into an S3 URI.
            </summary>
            <param name="uri">The source URI.</param>
            <returns>The equivalent S3 URI.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.EnsureSuccess(System.Net.HttpStatusCode,System.String)">
            <summary>
            <para>
            Ensures that the status code passed indicates an HTTP request completed successfully.
            </para>
            <note>
            Status codes between 200-299 are considered to indicate success.
            </note>
            </summary>
            <param name="statusCode">Specifies the status code.</param>
            <param name="reasonPhrase">Optionally specifies the reason phrase to be included in any exception thrown.</param>
            <returns>The status code passed.</returns>
            <exception cref="T:Neon.Net.HttpException">Thrown for non-success status codes.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.GetMacAddressAsync(System.Net.IPAddress)">
            <summary>
            <para>
            Attempts to fetch the MAC address associated with an IP address.
            </para>
            <note>
            This is currently supported only for Windows.
            </note>
            </summary>
            <param name="address">Specifies the IP address.</param>
            <returns>The MAC address as a byte array or <c>null</c> when no MAC address could be located.</returns>
            <exception cref="T:System.NotSupportedException">Thrown when the current platform is not supported.</exception>
            <remarks>
            <para>
            This works by sending an ICMP ping to <paramref name="address"/> and then using
            the <b>arp</b> command line tool to fetch the local ARP table in an attempt to
            locate the MAC address.  The idea here is that the ping should cause the target's
            MAC address to be added to the ARP table when the target is running and is on
            the local network.
            </para>
            <note>
            The first MAC address for the IP address found will be returned.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.GetArpTableAsync">
            <summary>
            <para>
            Returns the ARP table for the current machine.
            </para>
            <note>
            This is currently supported only for Windows.
            </note>
            </summary>
            <returns>
            A dictionary of dictionaries, with the first level keyed by network interface
            IP address, returning a dictionary relating IP addresses to MAC addresses for
            that interface.
            </returns>
            <exception cref="T:System.NotSupportedException">Thrown when the current platform is not supported.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.GetArpFlatTableAsync">
            <summary>
            <para>
            Returns a flattened ARP table for the current machine.  This is just a
            dictionary keyed by IP addresses mapping to the cached MAC address.
            </para>
            <note>
            This is currently supported only for Windows.
            </note>
            </summary>
            <returns>The IP/MAC dictionary.</returns>
            <exception cref="T:System.NotSupportedException">Thrown when the current platform is not supported.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.GetWindowsArpTableAsync">
            <summary>
            <para>
            Returns the ARP table for Windows.
            </para>
            <note>
            This is currently supported only for Windows.
            </note>
            </summary>
            <returns>The full ARP table.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.DeleteArpEntry(System.Net.IPAddress)">
            <summary>
            <para>
            Removes the cached ARP entry for an IP address if it's present.
            </para>
            <note>
            This is currently supported only for Windows.
            </note>
            </summary>
            <param name="address">Specifies the IP address being removed from the ARP cache.</param>
            <exception cref="T:System.NotSupportedException">Thrown when the current platform is not supported.</exception>
        </member>
        <member name="T:Neon.Net.NetworkCidr">
            <summary>
            Describes a IP network subnet using Classless Inter-Domain Routing (CIDR) notation.
            </summary>
            <remarks>
            <para>
            This is generally used for describing an IP subnet.  See the following Wikipedia
            article for more information.
            </para>
            <para>
            https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation
            </para>
            <note>
            This class currently supports only IPv4 addresses.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetworkCidr.op_Equality(Neon.Net.NetworkCidr,Neon.Net.NetworkCidr)">
            <summary>
            Compares two <see cref="T:Neon.Net.NetworkCidr"/> instances for equality.
            </summary>
            <param name="v1">Value 1.</param>
            <param name="v2">Value 2</param>
            <returns><c>true</c> if the values are equal.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.op_Inequality(Neon.Net.NetworkCidr,Neon.Net.NetworkCidr)">
            <summary>
            Compares two <see cref="T:Neon.Net.NetworkCidr"/> instances for inequality.
            </summary>
            <param name="v1">Value 1.</param>
            <param name="v2">Value 2</param>
            <returns><c>true</c> if the values are not equal.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.op_Implicit(Neon.Net.NetworkCidr)~System.String">
            <summary>
            Implicitly casts a <see cref="T:Neon.Net.NetworkCidr"/> into a string.
            </summary>
            <param name="v">The value (or <c>null)</c>.</param>
        </member>
        <member name="P:Neon.Net.NetworkCidr.All">
            <summary>
            Returns the <b>0.0.0.0/0</b> subnet which includes all public and private
            IP addresses.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Parse(System.String)">
            <summary>
            Parses a subnet from CIDR notation in the form of <i>ip-address</i>/<i>prefix</i>,
            where <i>prefix</i> is the network prefix length in bits.
            </summary>
            <param name="input">The input string.</param>
            <returns>The parsed <see cref="T:Neon.Net.NetworkCidr"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the input is not correctly formatted.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.TryParse(System.String,Neon.Net.NetworkCidr@)">
            <summary>
            Attempts to parse a subnet from CIDR notation in the form of <i>ip-address</i>/<i>prefix</i>,
            where <i>prefix</i> is the network prefix length in bits.
            </summary>
            <param name="input">The input string.</param>
            <param name="cidr">The parsed <see cref="T:Neon.Net.NetworkCidr"/>.</param>
            <returns><c>true</c> if the operation was successful.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Normalize(System.String)">
            <summary>
            Attempts to normalize a network CIDR string by ensuring that the
            address actually fits the mask.
            </summary>
            <param name="input">The input string.</param>
            <returns>The normalizes CIDR converted back to a string.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the input is not a valid CIDR.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkCidr.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Constructs a subnet from an IPv4 address and prefix length.
            </summary>
            <param name="address">The IP address.</param>
            <param name="prefixLength">The network prefix mask length in bits.</param>
        </member>
        <member name="M:Neon.Net.NetworkCidr.#ctor(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Constructs a subnet from an IPv4 address and subnet mask.
            </summary>
            <param name="address">The IP address.</param>
            <param name="subnetMask">The subnet mask.</param>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Initialize(System.Net.IPAddress,System.Int32)">
            <summary>
            Initializes the instance.
            </summary>
            <param name="address">The IP address.</param>
            <param name="prefixLength">The network prefix mask length in bits.</param>
        </member>
        <member name="P:Neon.Net.NetworkCidr.Address">
            <summary>
            Returns the CIDR address.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.Mask">
            <summary>
            Returns the subnet mask.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.PrefixLength">
            <summary>
            Returns the prefix length in bits.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.AddressCount">
            <summary>
            Returns the number of IP addresses within the subnet.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.UsableAddressCount">
            <summary>
            Returns the number of usable IP addresses within the subnet.  This returns
            <c>AddressCount - 1</c> to exclude the first address (.0) in the subnet as
            well as the last address which is reserved for broadcasting.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.FirstAddress">
            <summary>
            Returns the first IP address in the subnet.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.FirstUsableAddress">
            <summary>
            Returns the first usable IP address in the subnet.  This is often the
            gateway address.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.LastAddress">
            <summary>
            Returns the last IP address in the subnet.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.NextAddress">
            <summary>
            Returns the first address after the subnet.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Contains(System.Net.IPAddress)">
            <summary>
            Determines whether an IP address is within the subnet.
            </summary>
            <param name="address">The IP address.</param>
            <returns><c>true</c> if the address is within the subnet.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if for IPv6 addresses.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Contains(Neon.Net.NetworkCidr)">
            <summary>
            Determines whether a subnet is completely contained within the current subnet.
            </summary>
            <param name="subnet">The subnet being tested.</param>
            <returns><c>true</c> if <paramref name="subnet"/> is fully contained.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Overlaps(Neon.Net.NetworkCidr)">
            <summary>
            Determines whether this subnet overlaps another.
            </summary>
            <param name="subnet">The subnet being tested.</param>
            <returns><c>true</c> if the subnets overlap.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="subnet"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Net.NetworkCidr.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Net.NetworkConfiguration">
            <summary>
            Retured by <see cref="M:Neon.Net.NetHelper.GetNetworkConfiguration"/> with the current network
            settings including: Routable IP address, network CIDR, network gateway and the
            DNS server IP addresses.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkConfiguration.InterfaceName">
            <summary>
            Returns the network interface name.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkConfiguration.Address">
            <summary>
            The routable IP address of the current machine.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkConfiguration.Subnet">
            <summary>
            The subnet (CIDR) for the local network.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkConfiguration.Gateway">
            <summary>
            The IP address of the local network gateway.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkConfiguration.NameServers">
            <summary>
            The IP address of the local network's DNS name servers.
            </summary>
        </member>
        <member name="T:Neon.Net.NetworkException">
            <summary>
            Indicates network related problems.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkException.#ctor(System.String,System.Exception)">
            <summary>
            Constuctor.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The optional inner exception.</param>
        </member>
        <member name="T:Neon.Net.NetworkPorts">
            <summary>
            Defines some common network port numbers as well as the <see cref="M:Neon.Net.NetworkPorts.TryParse(System.String,System.Int32@)" /> method.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.HTTP">
            <summary>
            HyperText Transport Protocol port (<b>80</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.HTTPS">
            <summary>
            Secure HyperText Transport Protocol port (<b>443</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SSL">
            <summary>
            Secure Socket Layer port (<b>443</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.DNS">
            <summary>
            Domain Name System port (<b>53</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SMTP">
            <summary>
            Simple Message Transport Protocol port (<b>25</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.POP3">
            <summary>
            Post Office Protocol version 3 port (<b>110</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TELNET">
            <summary>
            Remote terminal protocol port (<b>23</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.FTP">
            <summary>
            File Transfer Protocol (control) port (<b>21</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.FTPDATA">
            <summary>
            File Transfer Protocol (data) port (<b>20</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SFTP">
            <summary>
            Secure File Transfer Protocol port (<b>22</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.RADIUS">
            <summary>
            RADIUS authentication and billing protocol (port <b>1812</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.AAA">
            <summary>
            Authentication, Authorization, and Accounting port.  This port was
            originally used by the RADIUS protocol and is still used
            fairly widely (<b>1645</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.ECHO">
            <summary>
            PING port (<b>7</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.DAYTIME">
            <summary>
            Daytime (RFC 867) port (<b>13</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TFTP">
            <summary>
            Trivial File Transfer Protocol port (<b>69</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SSH">
            <summary>
            Secure Shell port (<b>22</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TIME">
            <summary>
            TIME protocol port (<b>37</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.NTP">
            <summary>
            Network Time Protocol port (<b>123</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IMAP">
            <summary>
            Internet Message Access Protocol port (<b>143</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SNMP">
            <summary>
            Simple Network Managenment Protocol (SNMP) port (<b>161</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SNMPTRAP">
            <summary>
            Simple Network Managenment Protocol (trap) port (<b>162</b>)
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.LDAP">
            <summary>
            Lightweight Directory Access Protocol port (<b>389</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.LDAPS">
            <summary>
            Lightweight Directory Access Protocol over TLS/SSL port (<b>636</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SIP">
            <summary>
            Session Initiation Protocol port (<b>5060</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SIPS">
            <summary>
            Secure Session Initiation Protocol (over TLS) port (<b>5061</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SQUID">
            <summary>
            The default port for the <a href="http://en.wikipedia.org/wiki/Squid_%28software%29">Squid</a>
            open source proxy project port (<b>3128</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SOCKS">
            <summary>
            The SOCKS (Socket Secure) proxy port (<b>1080</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Consul">
            <summary>
            The HashiCorp Consul service (RPC) port (<b>8500</b>).  The protocol
            will be HTTP or HTTPS depending on how Consul is configured.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Vault">
            <summary>
            The HashiCorp Vault service port (<b>8200</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Docker">
            <summary>
            The Docker API port (<b>2375</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.DockerSwarm">
            <summary>
            The Docker Swarm node advertise port (<b>2377</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Etcd">
            <summary>
            The Etcd API port (<b>2379</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.EtcdPeer">
            <summary>
            The internal Etcd cluster peer API port (<b>2380</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TDAgentForward">
            <summary>
            The Treasure Data <b>td-agent</b> <b>forward</b> port 
            to accept TCP and UDP traffic (<b>24224</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TDAgentHttp">
            <summary>
            The Treasure Data <b>td-agent</b> <b>HTTP</b> port (<b>9880</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.ElasticSearchHttp">
            <summary>
            The ElasticSearch client HTTP port (<b>9200</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.ElasticSearchTcp">
            <summary>
            The ElasticSearch client TCP port (<b>9300</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Kibana">
            <summary>
            The Kibana website port (<b>5601</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SysLog">
            <summary>
            The SysLog UDP port (<b>514</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseWebAdmin">
            <summary>
            The Couchbase Server web administration user interface port (<b>8091</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseApi">
            <summary>
            The Couchbase Server REST API port (<b>8092</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseSyncGatewayAdmin">
            <summary>
            The Couchbase Sync Gateway administration REST API port (<b>4985</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseSyncGatewayPublic">
            <summary>
            The Couchbase Sync Gateway public REST API port (<b>4984</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.OpenVPN">
            <summary>
            The OpenVPN port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.AMQP">
            <summary>
            The Advanced Messaging Queue Protocol (AMQP) port (e.g. RabbitMQ).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.RabbitMQAdmin">
            <summary>
            RabbitMQ Admin dashboard port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.AppCacherNg">
            <summary>
            <b>apt-cacher-ng</b> Debian/Ubuntu package proxy port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Cadence">
            <summary>
            Uber Cadence primary cluster port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Temporal">
            <summary>
            Temporal primary cluster port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.KubernetesApiServer">
            <summary>
            Kubernetes API port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.HubbleRelay">
            <summary>
            Hubble (Cilium) relay service port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Cassandra">
            <summary>
            The Cassnadra database port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Postgres">
            <summary>
            The Postgres database port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.GrafanaDashboard">
            <summary>
            Default port for the Grafana dashboard.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.PrometheusMetrics">
            <summary>
            The standard Prometheus scraping port exposed by Neon related services,
            including custom user services built on <b>Neon.Service</b>.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.PrometheusDashboard">
            <summary>
            Default port for the Prometheus dashboard.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IstioEnvoyAdmin">
            <summary>
            Envoy sidecar admin port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IstioEnvoyOutbound">
            <summary>
            Envoy sidecar outbound port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IstioEnvoyInbound">
            <summary>
            Envoy sidecar inbound port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IstioEnvoyTunnel">
            <summary>
            Envoy sidecar tunnel port (inbound).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IstioIstioTelemetry">
            <summary>
            Merged Prometheus telemetry.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IstioIstioHealth">
            <summary>
            Istio health check.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IstioEnvoyTelemetry">
            <summary>
            Envoy sidecar Prometheus telemetry. 
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkPorts.InitializePortMap">
            <summary>
            Initializes the well-known name to port map. 
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkPorts.TryParse(System.String,System.Int32@)">
            <summary>
            Attempts to parse an integer or well known port name from a string
            and return the integer TCP port number.
            </summary>
            <param name="input">The port number or name as as string.</param>
            <param name="port">Receives the parsed port number.</param>
            <returns><c>true</c> if a port was successfully parsed.</returns>
        </member>
        <member name="T:Neon.Net.Pinger">
            <summary>
            Implements a threadsafe subset of the .NET Framework <see cref="T:System.Net.NetworkInformation.Ping"/> class.
            </summary>
            <remarks>
            <para>
            Unfortunately, the .NET Framework <see cref="T:System.Net.NetworkInformation.Ping"/> class is not threadsafe (even
            the async methods).  So, we need to ensure that only one ping request
            is performed on any given instance.
            </para>
            <para>
            My original idea was to simply create and dispose <see cref="T:System.Net.NetworkInformation.Ping"/>] instances on 
            the fly for each request, but I changed my mind after thinking about
            the potential performance overhead as well as the potential for exhausting
            ephemeral socket ports.
            </para>
            <para>
            Instead, I'm going to maintain a queue of <see cref="T:System.Net.NetworkInformation.Ping"/> instances that that can
            be reused for subsequent queries.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Net.Pinger.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.Dispose">
            <summary>
            Releases all resources associated with the instance.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Net.Pinger.Clear">
            <summary>
            Disposes any unused underlying <see cref="T:System.Net.NetworkInformation.Ping"/> instances.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.SendPingAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Pings an IP address.
            </summary>
            <param name="address">The target address.</param>
            <param name="timeoutMilliseconds">Optional timeout in milliseconds (defaults to 2000).</param>
            <returns>A <see cref="T:System.Net.NetworkInformation.PingReply"/> with the reply or an error indication.</returns>
        </member>
        <member name="M:Neon.Net.Pinger.SendPingAsync(System.String,System.Int32)">
            <summary>
            Pings a IP address passed as a <c>string</c>.
            </summary>
            <param name="address">The target address.</param>
            <param name="timeoutMilliseconds">Optional timeout in milliseconds (defaults to 2000).</param>
            <returns>A <see cref="T:System.Net.NetworkInformation.PingReply"/> with the reply or an error indication.</returns>
        </member>
        <member name="T:Neon.Net.ReachableHost">
            <summary>
            Holds information about a reachable host returned by <see cref="M:Neon.Net.NetHelper.GetReachableHost(System.Collections.Generic.IEnumerable{System.String},Neon.Net.ReachableHostMode)"/>.
            </summary>
        </member>
        <member name="M:Neon.Net.ReachableHost.#ctor(System.String,System.Net.IPAddress,System.TimeSpan,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="host">The target hostname.</param>
            <param name="address">The target IP address or <c>null</c> if the target is un reachable.</param>
            <param name="time">The ping and answer round trip time.</param>
            <param name="unreachable">Optionally specifies that the host was reachable.</param>
        </member>
        <member name="M:Neon.Net.ReachableHost.#ctor(System.String,System.Net.NetworkInformation.PingReply,System.Boolean)">
            <summary>
            Internal constructor used to create an instance from a <see cref="T:System.Net.NetworkInformation.PingReply"/>.
            </summary>
            <param name="host">The target hostname.</param>
            <param name="pingReply">The ping reply.</param>
            <param name="unreachable">Optionally specifies that the host was reachable.</param>
        </member>
        <member name="P:Neon.Net.ReachableHost.Host">
            <summary>
            The target host name.
            </summary>
        </member>
        <member name="P:Neon.Net.ReachableHost.Address">
            <summary>
            The target IP address or <c>null</c> if the target is unreachable.
            </summary>
        </member>
        <member name="P:Neon.Net.ReachableHost.Time">
            <summary>
            The ping and answer round trip time.
            </summary>
        </member>
        <member name="P:Neon.Net.ReachableHost.Unreachable">
            <summary>
            Indicates that the host was unreachable but was returned anyway because
            <see cref="F:Neon.Net.ReachableHostMode.ReturnFirst"/> was specified.
            </summary>
        </member>
        <member name="T:Neon.Net.ReachableHostMode">
            <summary>
            Enumerates how <see cref="M:Neon.Net.NetHelper.GetReachableHost(System.Collections.Generic.IEnumerable{System.String},Neon.Net.ReachableHostMode)"/> should
            behave when no there are no healthy hosts.
            </summary>
        </member>
        <member name="F:Neon.Net.ReachableHostMode.Throw">
            <summary>
            Throw an exception when no hosts respond.
            </summary>
        </member>
        <member name="F:Neon.Net.ReachableHostMode.ReturnFirst">
            <summary>
            Return the first host when no hosts respond.
            </summary>
        </member>
        <member name="F:Neon.Net.ReachableHostMode.ReturnNull">
            <summary>
            Return <c>null</c> when no hosts respond.
            </summary>
        </member>
        <member name="T:Neon.Net.StreamDocument">
            <summary>
            <para>
            Used by <b>ModelGen</b> generated service client methods to upload body data
            from a stream as opposed to serializing a document as JSON for service model
            methods tagged with <see cref="T:Neon.ModelGen.BodyStreamAttribute"/>.
            </para>
            <para>
            <see cref="T:Neon.Net.StreamDocument"/> instances may be passed as the <c>document</c>
            parameter to <see cref="T:Neon.Net.JsonClient"/> methods which recognizes these documents
            as special by uploading the stream data instead of JSON.
            </para>
            <note>
            You may also use special document directly in your code if necessary.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Net.StreamDocument.#ctor(System.IO.Stream)">
            <summary>
            Default constructor.
            </summary>
            <param name="stream">
            The stream whose contents from the current position to the end of the 
            stream will be uploaded as the request body.
            </param>
        </member>
        <member name="P:Neon.Net.StreamDocument.Stream">
            <summary>
            Returns the stream whose contents from the current position to the end of the 
            stream will be uploaded as the request body.
            </summary>
        </member>
        <member name="P:Neon.Net.StreamDocument.ContentType">
            <summary>
            Specifies the <b>Content-Type</b> to be used for the uploaded data. 
            This default to <b>application/octet-stream</b>.
            </summary>
        </member>
        <member name="P:Neon.Net.StreamDocument.BufferSize">
            <summary>
            Specifies the size of the buffer to be used for transmitting the
            body data.  This defaults to <b>8 GiB</b>.
            </summary>
        </member>
        <member name="T:Neon.Retry.ExponentialRetryPolicy">
            <summary>
            Implements an <see cref="T:Neon.Retry.IRetryPolicy"/> that retries an operation 
            first at an initial interval and then doubles the interval up to a limit
            for a specified maximum number of times.
            </summary>
            <remarks>
            <para>
            You can enable transient error logging by passing a non-empty <b>logCategory</b>
            name to the constructor.  This creates an embedded <see cref="T:Microsoft.Extensions.Logging.ILogger"/>
            using that name and any retried transient errors will then be logged as
            warnings including <b>[transient-retry]</b> in the message.
            </para>
            <note>
            Only the retried errors will be logged.  The final exception thrown after
            all retries fail will not be logged because it's assumed that these will
            be caught and handled upstack by application code.
            </note>
            <para>
            Choose a category name that can be used to easily identify the affected
            component.  For example, <b>yugabyte:my-cluster</b> to identify a
            specific YugaBYte database cluster.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.#ctor(System.Func{System.Exception,System.Boolean},System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy with a specific transitent detection function.
            </summary>
            <param name="transientDetector">
            Optionally specifies the function that determines whether an exception is transient 
            (see <see cref="T:Neon.Retry.TransientDetector"/>).  You can pass <c>null</c> when all exceptions
            are to be considered to be transient.
            </param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="initialRetryInterval">Optionally specifies the initial retry interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="maxRetryInterval">Optionally specifies the maximum retry interval (defaults to essentially unlimited: 24 hours).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="categoryName">
            Optionally customizes the transient error logging source category name (defaults to <see cref="F:Neon.Retry.RetryPolicyBase.DefaultCategoryName"/>).
            You can disable transient error logging by passing <c>null</c> or by adding an event handler to <see cref="E:Neon.Retry.IRetryPolicy.OnTransient"/>
            that ignores the event and also indicates that the event was handled.
            </param>
            <remarks>
            <para>
            The <paramref name="maxAttempts"/> parameter defaults to <b>-1</b> indicating that the
            operation should be attempted up to <b>5</b> times, unless a <see cref="T:System.Threading.Timeout"/> is
            specified.  In this case, <paramref name="maxAttempts"/> will be ignored and the timeout
            will be honored.
            </para>
            <para>
            When <paramref name="maxAttempts"/> is greater than or equal to zero and <see cref="T:System.Threading.Timeout"/> 
            is passed, then both <paramref name="maxAttempts"/> and <see cref="T:System.Threading.Timeout"/> will be honored,
            with retries stopping when either are exceeded.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.#ctor(System.Type,System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a specific exception type as transient.
            </summary>
            <param name="exceptionType">Specifies the exception type to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="initialRetryInterval">Optionally specifies the initial retry interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="maxRetryInterval">Optionally specifies the maximum retry interval (defaults to essentially unlimited: 24 hours).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="categoryName">Optionally enables transient error logging by identifying the source category name (defaults to <c>null</c>).</param>
            <remarks>
            <para>
            The <paramref name="maxAttempts"/> parameter defaults to <b>-1</b> indicating that the
            operation should be attempted up to <b>5</b> times, unless a <see cref="T:System.Threading.Timeout"/> is
            specified.  In this case, <paramref name="maxAttempts"/> will be ignored and the timeout
            will be honored.
            </para>
            <para>
            When <paramref name="maxAttempts"/> is greater than or equal to zero and <see cref="T:System.Threading.Timeout"/> 
            is passed, then both <paramref name="maxAttempts"/> and <see cref="T:System.Threading.Timeout"/> will be honored,
            with retries stopping when either are exceeded.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.#ctor(System.Type[],System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a multiple exception types as transient.
            </summary>
            <param name="exceptionTypes">Specifies the exception type to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="initialRetryInterval">Optionally specifies the initial retry interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="maxRetryInterval">Optionally specifies the maximum retry interval (defaults to essentially unlimited: 24 hours).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="categoryName">Optionally enables transient error logging by identifying the source category name (defaults to <c>null</c>).</param>
            <remarks>
            <para>
            The <paramref name="maxAttempts"/> parameter defaults to <b>-1</b> indicating that the
            operation should be attempted up to <b>5</b> times, unless a <see cref="T:System.Threading.Timeout"/> is
            specified.  In this case, <paramref name="maxAttempts"/> will be ignored and the timeout
            will be honored.
            </para>
            <para>
            When <paramref name="maxAttempts"/> is greater than or equal to zero and <see cref="T:System.Threading.Timeout"/> 
            is passed, then both <paramref name="maxAttempts"/> and <see cref="T:System.Threading.Timeout"/> will be honored,
            with retries stopping when either are exceeded.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Retry.ExponentialRetryPolicy.MaxAttempts">
            <summary>
            Returns the maximum number of times the action should be attempted.
            </summary>
        </member>
        <member name="P:Neon.Retry.ExponentialRetryPolicy.InitialRetryInterval">
            <summary>
            Returns the initial interval between action retry attempts.
            </summary>
        </member>
        <member name="P:Neon.Retry.ExponentialRetryPolicy.MaxRetryInterval">
            <summary>
            Returns the maximum intervaL between action retry attempts. 
            </summary>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.Clone(System.Func{System.Exception,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.Invoke(System.Action,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.Invoke``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Retry.IRetryPolicy">
            <summary>
            Describes the behavior of an operation retry policy.  These are used
            to retry operations that have failed due to transient errors.
            </summary>
        </member>
        <member name="P:Neon.Retry.IRetryPolicy.Timeout">
            <summary>
            Returns the optional policy timeout.  When present, this specifies the
            maximum time the policy will continue retrying the operation.
            </summary>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.Clone(System.Func{System.Exception,System.Boolean})">
            <summary>
            Returns a copy of the retry policy.
            </summary>
            <param name="transientDetector">
            Optionally specifies a replacement transient detector function 
            that will be set in the cloned policy.
            </param>
            <returns>The policy copy.</returns>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Retries an asynchronous action that returns no result when it throws exceptions due to 
            transient errors.  The classification of what is a transient error, the interval
            between the retries as well as the number of times the operation are retried are
            determined by the policy implementation.
            </summary>
            <param name="action">The asynchronous action to be performed.</param>
            <param name="cancellationToken">Optionally specifies a cancellation token.</param>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Retries an asynchronous action that returns <typeparamref name="TResult"/> when it throws exceptions
            due to transient errors.  he classification of what is a transient error, the interval 
            between the retries as well as the number of times the operation are retried are 
            determined by the policy implementation. 
            </summary>
            <typeparam name="TResult">The action result type.</typeparam>
            <param name="action">The asynchronous action to be performed.</param>
            <param name="cancellationToken">Optionally specifies a cancellation token.</param>
            <returns>The action result.</returns>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.Invoke(System.Action,System.Threading.CancellationToken)">
            <summary>
            Retries a synchronous action that returns no result when it throws exceptions due to 
            transient errors.  The classification of what is a transient error, the interval
            between the retries as well as the number of times the operation are retried are
            determined by the policy implementation.
            </summary>
            <param name="action">The synchronous action to be performed.</param>
            <param name="cancellationToken">Optionally specifies a cancellation token.</param>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.Invoke``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>
            Retries a synchronous action that returns a result when it throws exceptions due to 
            transient errors.  The classification of what is a transient error, the interval
            between the retries as well as the number of times the operation are retried are
            determined by the policy implementation.
            </summary>
            <typeparam name="TResult">The action result type.</typeparam>
            <param name="action">The synchronous action to be performed.</param>
            <param name="cancellationToken">Optionally specifies a cancellation token.</param>
            <returns>The action result.</returns>
        </member>
        <member name="E:Neon.Retry.IRetryPolicy.OnTransient">
            <summary>
            <para>
            Used to intercept and handle logging for transient exceptions detected by
            a retry policy.  Handlers can set <see cref="P:Neon.Retry.RetryTransientArgs.Handled"/>
            in the argument passed to prevent subsequent handlers from being invoked
            and also prevent the transient exception from being logged.
            </para>
            <para>
            When no handlers are added to this event, the default behavior is to log
            all transient failures.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Retry.LinearRetryPolicy">
            <summary>
            Implements a simple <see cref="T:Neon.Retry.IRetryPolicy"/> that retries an operation 
            at a fixed interval for a specified maximum number of times.
            </summary>
            <remarks>
            <para>
            You can enable transient error logging by passing a non-empty <b>logCategory</b>
            name to the constructor.  This creates an embedded <see cref="T:Microsoft.Extensions.Logging.ILogger"/>
            using that name and any retried transient errors will then be logged as
            warnings including <b>[transient-retry]</b> in the message.
            </para>
            <note>
            Only the retried errors will be logged.  The final exception thrown after
            all retries fail will not be logged because it's assumed that these will
            be caught and handled upstack by application code.
            </note>
            <para>
            Choose a category name that can be used to easily identify the affected
            component.  For example, <b>yugabyte:my-cluster</b> to identify a
            specific YugaBYte database cluster.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.#ctor(System.Func{System.Exception,System.Boolean},System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy with a specific transitent detection function.
            </summary>
            <param name="transientDetector">
            Optionally specifies the function that determines whether an exception is transient 
            (see <see cref="T:Neon.Retry.TransientDetector"/>).  You can pass <c>null</c> when all exceptions
            are to be considered to be transient.
            </param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="retryInterval">Optionally specifies time interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="categoryName">
            Optionally customizes the transient error logging source category name (defaults to <see cref="F:Neon.Retry.RetryPolicyBase.DefaultCategoryName"/>).
            You can disable transient error logging by passing <c>null</c> or by adding an event handler to <see cref="E:Neon.Retry.IRetryPolicy.OnTransient"/>
            that ignores the event and also indicates that the event was handled.
            </param>
            <remarks>
            <para>
            The <paramref name="maxAttempts"/> parameter defaults to <b>-1</b> indicating that the
            operation should be attempted up to <b>5</b> times, unless a <see cref="T:System.Threading.Timeout"/> is
            specified.  In this case, <paramref name="maxAttempts"/> will be ignored and the timeout
            will be honored.
            </para>
            <para>
            When <paramref name="maxAttempts"/> is greater than or equal to zero and <see cref="T:System.Threading.Timeout"/> 
            is passed, then both <paramref name="maxAttempts"/> and <see cref="T:System.Threading.Timeout"/> will be honored,
            with retries stopping when either are exceeded.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.#ctor(System.Type,System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a specific exception type as transient.
            </summary>
            <param name="exceptionType">Specifies the exception type to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="retryInterval">Optionally specifies the time interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="categoryName">Optionally enables transient error logging by identifying the source category name (defaults to <c>null</c>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <remarks>
            <para>
            The <paramref name="maxAttempts"/> parameter defaults to <b>-1</b> indicating that the
            operation should be attempted up to <b>5</b> times, unless a <see cref="T:System.Threading.Timeout"/> is
            specified.  In this case, <paramref name="maxAttempts"/> will be ignored and the timeout
            will be honored.
            </para>
            <para>
            When <paramref name="maxAttempts"/> is greater than or equal to zero and <see cref="T:System.Threading.Timeout"/> 
            is passed, then both <paramref name="maxAttempts"/> and <see cref="T:System.Threading.Timeout"/> will be honored,
            with retries stopping when either are exceeded.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.#ctor(System.Type[],System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a multiple exception types as transient.
            </summary>
            <param name="exceptionTypes">Specifies the exception types to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="retryInterval">Optionally specifies the time interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="categoryName">Optionally enables transient error logging by identifying the source category name (defaults to <c>null</c>).</param>
            <remarks>
            <para>
            The <paramref name="maxAttempts"/> parameter defaults to <b>-1</b> indicating that the
            operation should be attempted up to <b>5</b> times, unless a <see cref="T:System.Threading.Timeout"/> is
            specified.  In this case, <paramref name="maxAttempts"/> will be ignored and the timeout
            will be honored.
            </para>
            <para>
            When <paramref name="maxAttempts"/> is greater than or equal to zero and <see cref="T:System.Threading.Timeout"/> 
            is passed, then both <paramref name="maxAttempts"/> and <see cref="T:System.Threading.Timeout"/> will be honored,
            with retries stopping when either are exceeded.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Retry.LinearRetryPolicy.MaxAttempts">
            <summary>
            Returns the maximum number of times the action should be attempted.
            </summary>
        </member>
        <member name="P:Neon.Retry.LinearRetryPolicy.RetryInterval">
            <summary>
            Returns the fixed interval between action retry attempts.
            </summary>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.Clone(System.Func{System.Exception,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.Invoke(System.Action,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.Invoke``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Retry.NamespaceDoc">
            <summary>
            This namespace includes simple types that can be used to mitigate transient errors.
            </summary>
        </member>
        <member name="T:Neon.Retry.NoRetryPolicy">
            <summary>
            Implements an <see cref="T:Neon.Retry.IRetryPolicy"/> that does not attempt to retry operations.
            </summary>
        </member>
        <member name="P:Neon.Retry.NoRetryPolicy.Instance">
            <summary>
            Returns a global invariant instance.
            </summary>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Retry.NoRetryPolicy.Timeout">
            <inheritdoc/>
        </member>
        <member name="E:Neon.Retry.NoRetryPolicy.OnTransient">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.Clone(System.Func{System.Exception,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.Invoke(System.Action,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.Invoke``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Retry.RetryPolicy">
            <summary>
            Base class for used to help implement a <see cref="T:Neon.Retry.IRetryPolicy"/>.
            </summary>
        </member>
        <member name="F:Neon.Retry.RetryPolicy.DefaultMaxAttempts">
            <summary>
            The default number of times an operation should be attempted for transient exceptions.
            </summary>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.#ctor(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Constructor.
            </summary>
            <param name="categoryName">Optionally enables transient error logging by identifying the source category name (defaults to <c>null</c>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation should be retried (defaults to no limit).</param>
        </member>
        <member name="P:Neon.Retry.RetryPolicy.Timeout">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.Clone(System.Func{System.Exception,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.Invoke(System.Action,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.Invoke``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="E:Neon.Retry.RetryPolicy.OnTransient">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.LogTransient(System.Exception)">
            <summary>
            Handles logging of transient exceptions by invoking any <see cref="E:Neon.Retry.RetryPolicy.OnTransient"/>
            event handlers and then logging the transient exception when none of the handlers
            indicated that they handled the event.
            </summary>
            <param name="e">The transient exception.</param>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.AdjustDelay(System.TimeSpan)">
            <summary>
            Adjusts the delay <see cref="T:System.TimeSpan"/> passed to ensure such
            that delaying the next retry won't exceed the overall retry
            timeout (if specified).
            </summary>
            <param name="delay">The requested delay.</param>
            <returns>The adjusted delay.</returns>
            <remarks>
            <note>
            If the result is <see cref="F:System.TimeSpan.Zero"/> or negative, the
            calling retry policy should immediately stop retrying.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Retry.RetryPolicyBase">
            <summary>
            Base class for used to help implement a <see cref="T:Neon.Retry.IRetryPolicy"/>.
            </summary>
        </member>
        <member name="F:Neon.Retry.RetryPolicyBase.DefaultCategoryName">
            <summary>
            Specifies the default default category name for logging transient exceptions.
            </summary>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.#ctor(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Constructor.
            </summary>
            <param name="categoryName">
            Optionally customizes the transient error logging source category name (defaults to <see cref="F:Neon.Retry.RetryPolicyBase.DefaultCategoryName"/>).
            You can disable transient error logging by passing <c>null</c> or by adding an event handler to <see cref="E:Neon.Retry.IRetryPolicy.OnTransient"/>
            that ignores the event and also indicates that the event was handled.
            </param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained).</param>
        </member>
        <member name="P:Neon.Retry.RetryPolicyBase.Timeout">
            <inheritdoc/>
        </member>
        <member name="E:Neon.Retry.RetryPolicyBase.OnTransient">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.Clone(System.Func{System.Exception,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.InvokeAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.Invoke(System.Action,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.Invoke``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Retry.RetryPolicyBase.CategoryName">
            <summary>
            Returns the associated log source category name (or <c>null)</c>.
            </summary>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.LogTransient(System.Exception)">
            <summary>
            Handles logging of transient exceptions by invoking any <see cref="E:Neon.Retry.RetryPolicyBase.OnTransient"/>
            event handlers and then logging the transient exception when none of the handlers
            indicated that they handled the event (or there were no handlers).
            </summary>
            <param name="e">The transient exception.</param>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.SysDeadline">
            <summary>
            Computes the time (SYS) after which the operation should not be retried.
            </summary>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.AdjustDelay(System.TimeSpan,System.DateTime)">
            <summary>
            Adjusts the delay <see cref="T:System.TimeSpan"/> passed to ensure such
            that delaying the next retry won't exceed the overall retry
            timeout (if specified).
            </summary>
            <param name="delay">The requested delay.</param>
            <param name="sysDeadline">The retry deadline (SYS) computed by <see cref="M:Neon.Retry.RetryPolicyBase.SysDeadline"/>.</param>
            <returns>The adjusted delay.</returns>
            <remarks>
            <note>
            If the result is <see cref="F:System.TimeSpan.Zero"/> or negative, the
            calling retry policy should immediately stop retrying.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Retry.RetryTransientArgs">
            <summary>
            Arguments passed to <see cref="E:Neon.Retry.IRetryPolicy.OnTransient"/> handlers so these can
            react to transient exceptions and optionally prevent further handlers from being
            invoked and also prevent the transient exception from being logged.
            </summary>
        </member>
        <member name="M:Neon.Retry.RetryTransientArgs.#ctor(System.Exception)">
            <summary>
            Internal constructor.
            </summary>
            <param name="e">Specifies the transient exception.</param>
        </member>
        <member name="P:Neon.Retry.RetryTransientArgs.Exception">
            <summary>
            Returns the transient exception detected by the retry policy.
            </summary>
        </member>
        <member name="P:Neon.Retry.RetryTransientArgs.Handled">
            <summary>
            Handlers may set this to <c>true</c> to indicate that no subsequent 
            handlers should be called and also that the default transient logging
            should not occur.
            </summary>
        </member>
        <member name="T:Neon.Retry.TransientDetector">
            <summary>
            Provides some common transient error detection functions for use by
            <see cref="T:Neon.Retry.IRetryPolicy"/> implementations.
            </summary>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Always(System.Exception)">
            <summary>
            Considers <b>every</b> exceptions to be transient.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c></returns>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Never(System.Exception)">
            <summary>
            Considers <b>no</b> exceptions to be transient.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Network(System.Exception)">
            <summary>
            Considers <see cref="T:System.Net.Sockets.SocketException"/> and <see cref="T:Neon.Retry.TransientException"/> as possible
            transient errors as well as these exceptions nested within an <see cref="T:System.AggregateException"/>.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c> if the exception is to be considered as transient.</returns>
            <remarks>
            <note>
            <see cref="T:Neon.Retry.TransientException"/> is always considered to be a transient exception.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Http(System.Exception)">
            <summary>
            Considers <see cref="T:Neon.Net.HttpException"/>, <see cref="T:System.Net.Http.HttpRequestException"/>, and
            <see cref="T:Neon.Retry.TransientException"/> as possible transient errors as well as these 
            exceptions nested within an <see cref="T:System.AggregateException"/>.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c> if the exception is to be considered as transient.</returns>
            <remarks>
            <note>
            <see cref="T:Neon.Retry.TransientException"/> is always considered to be a transient exception.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Retry.TransientDetector.NetworkOrHttp(System.Exception)">
            <summary>
            Considers <see cref="T:System.Net.Sockets.SocketException"/>, <see cref="T:System.Net.Http.HttpRequestException"/>, and
            <see cref="T:Neon.Retry.TransientException"/> as possible transient errors as well as these 
            exceptions nested within an <see cref="T:System.AggregateException"/>.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c> if the exception is to be considered as transient.</returns>
            <remarks>
            <note>
            <see cref="T:Neon.Retry.TransientException"/> is always considered to be a transient exception.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Retry.TransientDetector.MatchException(System.Exception,System.Type)">
            <summary>
            Used internally to determine whether a thrown exception matches a specific exception type.
            </summary>
            <param name="e">The thrown exception or <c>null</c>.</param>
            <param name="exceptionType">The exception type to be matched.</param>
            <returns>
            <c>true</c> if <paramref name="e"/> is not <c>null</c> and
            it's type is <paramref name="exceptionType"/> or if <paramref name="e"/>
            is a <see cref="T:System.AggregateException"/> and one of the subexceptions
            is a <paramref name="exceptionType"/>.
            </returns>
        </member>
        <member name="T:Neon.Retry.TransientException">
            <summary>
            Used to indicate an explicit transient error.
            </summary>
        </member>
        <member name="M:Neon.Retry.TransientException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">Optional inner exception.</param>
        </member>
        <member name="T:Neon.Service.NamespaceDoc">
            <summary>
            This namespace defines types used to describe an application service.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceApiContact">
            <summary>
            Holds the contact information for a service API.  This maps closely
            to the <b>Microsoft.OpenApi.Models.OpenApiContact</b> class.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiContact.Name">
            <summary>
            The name of the contact person or organiztion.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiContact.Url">
            <summary>
            The URL pointing to the contact information.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiContact.Email">
            <summary>
            The email address of the contact person or organization formatted
            as a URL like: <b>mailto:joe@blow.com</b>
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceApiInfo">
            <summary>
            <para>
            Human readable metadata for a service API.  This maps pretty closely
            to the <c>Microsoft.OpenApi.Models.OpenApiInfo</c> class which is used
            to by Swagger when generating ASP.NET documentation.
            </para>
            <note>
            We're not referencing the <b>Microsoft.OpenApi</b> nuget package to
            avoid adding about 166KB to applications using the <b>Neon.Common</b>
            assembly.f
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Title">
            <summary>
            API documentation title.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Description">
            <summary>
            More detailed API description.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Version">
            <summary>
            API version.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.TermsOfService">
            <summary>
            References the API terms of service.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Contact">
            <summary>
            API contact information.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.License">
            <summary>
            API licence information.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceApiLicense">
            <summary>
            Holds the license information for a service API.  This maps closely
            to the <b>Microsoft.OpenApi.Models.OpenApiLicense</b> class.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiLicense.Name">
            <summary>
            License name.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiLicense.Url">
            <summary>
            The URL pointing to the licence information.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceDescription">
            <summary>
            Describes a remote service.
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceDescription.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Name">
            <summary>
            The service name as deployed to Kubernetes.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Namespace">
            <summary>
            The Kubernetes namespace where the service is deployed.  This defaults to <b>"default"</b>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Domain">
            <summary>
            The cluster's configured domain (aka zone).  This defaults to <b>"cluster.local"</b>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Address">
            <summary>
            When set, this overrides <see cref="P:Neon.Service.ServiceDescription.Name"/>, <see cref="P:Neon.Service.ServiceDescription.Namespace"/>, and
            <see cref="P:Neon.Service.ServiceDescription.Domain"/> when generating the <see cref="P:Neon.Service.ServiceDescription.Hostname"/> result.
            This is typically set for public service endpoints for public deployments
            or when emulating a cluster on a local machine for testing purposes.  
            This defaults to <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Hostname">
            <summary>
            <para>
            Returns the hostname to be used to communcate with this service.  When deployed
            to a Kubernetes cluster, this will be formed from <see cref="P:Neon.Service.ServiceDescription.Name"/> and <see cref="P:Neon.Service.ServiceDescription.Namespace"/>,
            omitting the <see cref="P:Neon.Service.ServiceDescription.Domain"/>.  When testing and <see cref="P:Neon.Service.ServiceDescription.Address"/> is not <c>null</c>,
            then this will simply be the address converted to a string.
            </para>
            <note>
            Use <see cref="P:Neon.Service.ServiceDescription.FullHostname"/> if you need the fully qualified hostname that
            includes the cluster domain.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.FullHostname">
            <summary>
            <para>
            Returns the hostname to be used to communcate with this service.  When deployed
            to a Kubernetes cluster, this will be formed from <see cref="P:Neon.Service.ServiceDescription.Name"/> and <see cref="P:Neon.Service.ServiceDescription.Namespace"/>,
            including the <see cref="P:Neon.Service.ServiceDescription.Domain"/>.  When testing and <see cref="P:Neon.Service.ServiceDescription.Address"/> is not <c>null</c>,
            then this will simply be the address converted to a string.
            </para>
            <note>
            Use <see cref="P:Neon.Service.ServiceDescription.Hostname"/> if you need the fully qualified hostname that
            includes the cluster domain.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Endpoints">
            <summary>
            The service's network endpoints.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.MetricsPort">
            <summary>
            The service's Prometheus metrics exporter port.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.TestEnvironmentVariables">
            <summary>
            Used to hold environment variables that will be set when deploying the service in a test
            via <c>NeonServiceFixture</c>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.TestTextConfigFiles">
            <summary>
            Used to hold text configuration files that will be set when deploying the service in a test
            via <c>NeonServiceFixture</c>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.TestBinaryConfigFiles">
            <summary>
            Used to hold binary configuration files that will be set when deploying the service in a test
            via <c>NeonServiceFixture</c>.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceEndpoint">
            <summary>
            Describes a network endpoint for remote service.
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceEndpoint.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.ServiceDescription">
            <summary>
            <para>
            The parent <see cref="P:Neon.Service.ServiceEndpoint.ServiceDescription"/>.
            </para>
            <note>
            This must be initialized before attempting to reference the endpoint.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Name">
            <summary>
            The endpoint name.  This defaults to the empty string.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Protocol">
            <summary>
            Specifies the network protocol implemented by this endpoint.
            This defaults to <see cref="F:Neon.Service.ServiceEndpointProtocol.Http"/>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.PathPrefix">
            <summary>
            This specifies the path prefix to prepended to URIs accessing this service. 
            This defaults to an empty string.  This has meaning only for the HTTP and 
            HTTPS protocols.
            </summary>
            <remarks>
            <note>
            Any leading forward slash character will be stripped when setting this.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Port">
            <summary>
            <para>
            This specifies the network port to be used for URIs accessing this service.  This defaults to <b>-1</b>
            which indicates that HTTP and HTTPS based endpoints will be initialized to their default ports <b>80</b>
            and <b>443</b> so you don't need to specify and explicit ports for these.  You will need to set this to
            a valid port for TCP and UDP protocols.
            </para>
            <note>
            <b>CAUTION:</b> It's best not to rely on this value when setting up your service network endpoints and
            reference the port from <see cref="P:Neon.Service.ServiceEndpoint.Uri"/> instead because that will always be a valid TCP port number.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.ApiInfo">
            <summary>
            ASP.NET services, this can be set to the metadata used for Swagger documentation
            generation related purposes.  This defaults to <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Uri">
            <summary>
            <para>
            Returns the URI for the endpoint.  For HTTP and HTTPS endpoints, this will
            include the service hostname returned by the parent <see cref="P:Neon.Service.ServiceEndpoint.ServiceDescription"/>,
            along with the port and path prefix.  For TCP and UDP protocols, this will
            use the <b>tcp://</b> or <b>udp://</b> scheme along with the hostname and
            just the port.  The path prefix is ignored for TCP and UDP.
            </para>
            <para>
            When <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is <b>-1</b> for HTTP or HTTPS endpoints, the URL returned 
            will use the default port for thbe protocol (80/443).  For TCP and UDP protocols,
            the port must be a valid (non-negative) network port.
            </para>
            <note>
            For production, this property returns the partially qualified hostname for
            the host, omitting the cluster domain (e.g. <b>cluster.local</b>).  Use 
            <see cref="P:Neon.Service.ServiceEndpoint.FullUri"/> if you need the fully qualified URI.
            </note>
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is not valid for the endpoint protocol.</exception>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.FullUri">
            <summary>
            <para>
            Returns the URI for the endpoint.  For HTTP and HTTPS endpoints, this will
            include the service hostname returned by the parent <see cref="P:Neon.Service.ServiceEndpoint.ServiceDescription"/>,
            along with the port and path prefix.  For TCP and UDP protocols, this will
            use the <b>tcp://</b> or <b>udp://</b> scheme along with the hostname and
            just the port.  The path prefix is ignored for TCP and UDP.
            </para>
            <para>
            When <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is zero for HTTP or HTTPS endpoints, the URL returned 
            will use the default port for thbe protocol (80/443).  For TCP and UDP protocols,
            the port must be a valid non-zero network port.
            </para>
            <note>
            For production, this property returns the partially qualified hostname for
            the host, including the cluster domain (e.g. <b>cluster.local</b>.  Use 
            <see cref="P:Neon.Service.ServiceEndpoint.Uri"/> if you need the relative qualified URI.
            </note>
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is not valid for the endpoint protocol.</exception>
        </member>
        <member name="T:Neon.Service.ServiceEndpointProtocol">
            <summary>
            Enumerats the network protocols that can be implemented by a <see cref="T:Neon.Service.ServiceEndpoint"/>.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Http">
            <summary>
            HTTP.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Https">
            <summary>
            HTTPS.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Tcp">
            <summary>
            TCP.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Udp">
            <summary>
            UDP.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceEndpoints">
            <summary>
            Holds the endpoint definitions for a service.
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceEndpoints.Add(Neon.Service.ServiceEndpoint)">
            <summary>
            Adds an endpoint.
            </summary>
            <param name="endpoint">The endpoint.</param>
        </member>
        <member name="P:Neon.Service.ServiceEndpoints.Default">
            <summary>
            Returns the default endpoint (the one with the empty name) if present.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the default endpoint doesn't exist.</exception>
        </member>
        <member name="T:Neon.Service.ServiceMap">
            <summary>
            <para>
            Describes a collection of services deployed to Kubernetes or that run in
            a simulated unit test environment.  This is simply a dictionary mapping
            case sensitive service names to <see cref="T:Neon.Service.ServiceDescription"/>
            records for each service.
            </para>
            <note>
            <see cref="T:Neon.Service.ServiceMap"/> is a somewhat dated concept that doesn't make a lot of sense in
            the Kubernetes world.  We recommend that new code avoid this.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceMap.Add(Neon.Service.ServiceDescription)">
            <summary>
            Adds a service description to the map.
            </summary>
            <param name="description">The service descrioption.</param>
        </member>
        <member name="M:Neon.Service.ServiceMap.Add(System.String,Neon.Service.ServiceDescription)">
            <summary>
            Adds the named service description.
            </summary>
            <param name="name">The service name.</param>
            <param name="description">The service description.</param>
        </member>
        <member name="P:Neon.Service.ServiceMap.Item(System.String)">
            <summary>
            Indexer mapping service names to their <see cref="T:Neon.Service.ServiceDescription"/>.
            </summary>
            <param name="name">The service name.</param>
            <returns>The service description or <c>null</c> if the named service is not present.</returns>
        </member>
        <member name="M:Neon.Service.ServiceMap.GetServiceEndpoint(System.String,System.String)">
            <summary>
            Returns the named endpoint for the specified service.
            </summary>
            <param name="serviceName">The target service name.</param>
            <param name="endpointName">Optionally specifies the target endpoint name (defaults to <see cref="F:System.String.Empty"/>).</param>
            <returns>The requested service endpoint.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the requested service or endpoint does not exist.</exception>
        </member>
        <member name="M:Neon.Service.ServiceMap.GetServiceEndpointUri(System.String,System.String)">
            <summary>
            Returns the named endpoint <see cref="T:System.Uri"/> for the specified service.
            </summary>
            <param name="serviceName">The target service name.</param>
            <param name="endpointName">Optionally specifies the target endpoint name (defaults to <see cref="F:System.String.Empty"/>).</param>
            <returns>The requested service endpoint <see cref="T:System.Uri"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the requested service or endpoint does not exist.</exception>
        </member>
        <member name="T:Neon.Tasks.Async">
            <summary>
            <see cref="T:System.Threading.Tasks.Task"/> related utilities.
            </summary>
        </member>
        <member name="M:Neon.Tasks.Async.ForEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task},System.Int32)">
            <summary>
            Iterates over a set of work items and executes an async action for each item.
            The method returns when all of the actions have completed.
            </summary>
            <typeparam name="TWorkItem">The work item type.</typeparam>
            <param name="workItems">The work item collection.</param>
            <param name="action">The async action to be executed on each work item.</param>
            <param name="maxParallel">Optionally specifies the maximum number of tasks to execute in parallel (defaults to <c>1</c>).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.AggregateException">Thrown when any of the actions failed.</exception>
            <remarks>
            <para>
            The actions will be executed on threads from the thread pool which means
            that the number of tasks that can be executed in parallel will be limited
            by the number of available pooled threads.
            </para>
            <note>
            The order in which work items are executed is not defined.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.Async.ProcessAsync``1(``0,System.Func{``0,System.Threading.Tasks.Task},System.Threading.SemaphoreSlim)">
            <summary>
            Handles async processing of each work item from a <see cref="M:Neon.Tasks.Async.ForEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)"/> 
            call (without a <see cref="T:System.Threading.CancellationToken"/>).
            </summary>
            <typeparam name="TWorkItem">The work item type.</typeparam>
            <param name="workItem">The work item.</param>
            <param name="action">The async action to be executed on each work item.</param>
            <param name="taskGate">The <see cref="T:System.Threading.SemaphoreSlim"/> used to limit the number of tasks executing in parallel.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Tasks.Async.ForEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Iterates over a set of work items and executes an async action for each item.
            The method returns when all of the actions have completed.
            </summary>
            <typeparam name="TWorkItem">The work item type.</typeparam>
            <param name="workItems">The work item collection.</param>
            <param name="action">The async action to be executed on each work item.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="maxParallel">Optionally specifies the maximum number of tasks to execute in parallel (defaults to <c>1</c>).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.AggregateException">Thrown when any of the actions failed.</exception>
            <remarks>
            <para>
            The actions will be executed on threads from the thread pool which means
            that the number of tasks that can be executed in parallel will be limited
            by the number of available pooled threads.
            </para>
            <note>
            The order in which work items are executed is not defined.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.Async.ProcessAsync``1(``0,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.SemaphoreSlim)">
            <summary>
            Handles async processing of each work item from a <see cref="M:Neon.Tasks.Async.ForEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)"/> 
            call (with a <see cref="T:System.Threading.CancellationToken"/>).  This override supports a <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <typeparam name="TWorkItem">The work item type.</typeparam>
            <param name="workItem">The work item.</param>
            <param name="action">The async action to be executed on each work item.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="taskGate">The <see cref="T:System.Threading.SemaphoreSlim"/> used to limit the number of tasks executing in parallel.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Tasks.AsyncAutoResetEvent">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <see cref="T:System.Threading.AutoResetEvent"/>.
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="initialState">
            Pass <c>true</c> to set the initial event state to signaled, <c>false</c>
            for unsignaled.
            </param>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Set">
            <summary>
            Sets the state of the event to signalled allowing a single task that is currently
            waiting or the next task that waits on the event to proceed.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Reset">
            <summary>
            Sets the state of the event to unsignalled, so that tasks will have to wait.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.WaitAsync">
            <summary>
            Waits until the event is signalled.
            </summary>
        </member>
        <member name="T:Neon.Tasks.AsyncManualResetEvent">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <see cref="T:System.Threading.ManualResetEvent"/>.
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="initialState">
            Pass <c>true</c> to set the initial event state to signaled, <c>false</c>
            for unsignaled.
            </param>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Set">
            <summary>
            Sets the state of the event to signalled allowing one or more waiting tasks
            to proceed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the event has already been closed.</exception>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Reset">
            <summary>
            Sets the state of the event to non-signalled, causing tasks to block.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.WaitAsync">
            <summary>
            Wait asynchronously for the event to be signalled.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the event has already been closed or is closed before it is signalled.</exception>
        </member>
        <member name="T:Neon.Tasks.AsyncMutex">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <see cref="T:System.Threading.Mutex"/>.
            </summary>
            <remarks>
            <para>
            This class can be used to grant a task exclusive access to a resource.  This class is
            pretty easy to use.  Simply instantiate an instance and then call <see cref="M:Neon.Tasks.AsyncMutex.AcquireAsync"/>
            within a <c>using</c> statement:
            </para>
            <code language="cs">
            var mutex = new AsyncMutex();
            
            using (await mutex.Acquire())
            {
                // Protected code
            }
            </code>
            <note>
            Be very sure to include the <c>await</c> within the <c>using</c> statement to avoid
            hard to debug problems.  The <c>await</c> ensures that the <c>using</c> statement
            will dispose the acquired lock as opposed to the <see cref="T:System.Threading.Tasks.Task"/> that returns
            the lock.
            </note>
            <para>
            Applications that cannot use a <c>using</c> statement may release the lock explicitly
            by disposing the object returned by the lock method, like this:
            </para>
            <code language="cs">
            var mutex  = new AsyncMutex();
            var myLock = await mutex.AcquireAsync();
            
            // Protected code.
            
            myLock.Dispose();
            </code>
            <para>
            <see cref="T:Neon.Tasks.AsyncMutex"/>'s <see cref="M:Neon.Tasks.AsyncMutex.Dispose"/> method ensures that any tasks
            waiting for a lock will be unblocked with an <see cref="T:System.ObjectDisposedException"/>.
            </para>
            <para><b>REENTRANCY NOT SUPPORTED</b></para>
            <para>
            <b>IMPORTANT:</b> This class does not allow a single task to acquire the lock more than once.  
            This differs from how the regular <see cref="T:System.Threading.Mutex"/> classes work which do allow a single 
            thread to acquire the mutex more than once.
            </para>
            <para>
            This means that you cannot expect to acquire a mutex in a task and then call into a
            method that will also attempt to acquire the same mutex.  Doing this will result in 
            a deadlock.
            </para>
            <code language="cs">
            var mutex = new AsyncMutex();
            
            using (await mutex.Acquire())
            {
                using (await mutex.Acquire())   // $lt;--- This will block forever
                {
                    // Protected code
                }
            }
            </code>
            <para>
            You can use <see cref="T:Neon.Tasks.AsyncReentrantMutex"/> instead.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this mutex.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this mutex.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.AcquireAsync">
            <summary>
            Acquires exclusive access to the mutex.
            </summary>
            <returns>The <see cref="T:System.IDisposable"/> instance to be disposed to release the lock.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the mutex is disposed before or after this method is called.</exception>
        </member>
        <member name="T:Neon.Tasks.AsyncPeriodicTask">
            <summary>
            Implements a common asynchronous coding pattern where an asynchronous
            operation is performed periodically and cancellation and exceptions
            are handled cleanly.
            </summary>
            <remarks>
            <para>
            This class provides a nice way to implement the very common server
            side pattern where we need to periodically perform some operation 
            until the operation signals that it's done or the task is canceled,
            while handling some of the messy exception handling details.
            </para>
            <para>
            You'll use the <see cref="M:Neon.Tasks.AsyncPeriodicTask.#ctor(System.TimeSpan,System.Func{System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Threading.Tasks.Task},System.Threading.CancellationTokenSource)"/>
            constructor to create a task, passing the task interval, asynchronous task handler and optional exception handler and cancellation token
            and then call <see cref="M:Neon.Tasks.AsyncPeriodicTask.Run"/> to execute the task.
            </para>
            <para>
            <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> will call the task handler, wait for the interval and then repeat.  The task handler
            return <c>false</c> to continue running or <c>true</c> to signal that <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> should stop.
            <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> also monitors the cancellation token passed and watches for <see cref="T:System.OperationCanceledException"/>
            thrown by the task handler to stop itself.
            </para>
            <para>
            The exception handler will be called for all exceptions thrown by the task handler except for <see cref="T:System.OperationCanceledException"/>
            exceptions as these signal that <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> should terminate.  Exception handlers return <c>false</c> to continue 
            running or <c>true</c> to signal that <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> should stop.
            stop.
            </para>
            <para>
            Finally, an optional handler can be specified that will be called just before the <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> terminates.
            </para>
            <note>
            This class implements <see cref="T:System.IDisposable"/> and the task will be terminated
            when this is called.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.#ctor(System.TimeSpan,System.Func{System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Threading.Tasks.Task},System.Threading.CancellationTokenSource)">
            <summary>
            Constructs a periodic task.
            </summary>
            <param name="interval">The interval between task executions.</param>
            <param name="onTaskAsync">Called periodically to implement the task.  The callback should return <c>true</c> if the task should terminate.</param>
            <param name="onExceptionAsync">Optional callback that handles exceptions thrown by the task.  The callback should return <c>true</c> if the task should terminate.</param>
            <param name="onTerminateAsync">Optional callback that will be called just before the task terminates.</param>
            <param name="cancellationTokenSource">Optionally specifies the <see cref="P:Neon.Tasks.AsyncPeriodicTask.CancellationTokenSource"/> that can be used to stop the task.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.Dispose">
            <summary>
            Stops the task if it's running.
            </summary>
        </member>
        <member name="P:Neon.Tasks.AsyncPeriodicTask.Interval">
            <summary>
            Returns the task interval.
            </summary>
        </member>
        <member name="P:Neon.Tasks.AsyncPeriodicTask.CancellationTokenSource">
            <summary>
            Returns the cancellation token.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.Run">
            <summary>
            Asynchronously executes the task until it exits or is canceled.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.OnTerminateAsync">
            <summary>
            Asynchronously invokes the termination handler (if present).
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.OnExceptionAsync(System.Exception)">
            <summary>
            Asynchronously executes the exception handler (if present).
            </summary>
            <param name="e">The exception.</param>
            <returns><c>true</c> if the handler indicates that the task should be terminated.</returns>
        </member>
        <member name="T:Neon.Tasks.AsyncReaderWriterLock">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <b>ReaderWriterLock</b>.
            </summary>
            <remarks>
            <para>
            This class can be used to grant a single writer task exclusive access to a resource
            or multiple reader tasks.  This class is pretty easy to use.  Simply instantiate
            an instance and then call <see cref="M:Neon.Tasks.AsyncReaderWriterLock.GetReadLockAsync"/> or <see cref="M:Neon.Tasks.AsyncReaderWriterLock.GetWriteLockAsync"/>
            within a <c>using</c> statement:
            </para>
            <code language="cs">
            var rwLock = new AsyncReaderWriterLock();
            
            using (await rwLock.GetReadLockAsync())
            {
                // Protected reading code
            }
            
            using (await rwLock.GetWriteLockAsync())
            {
                // Protected writing code
            }
            </code>
            <note>
            Be very sure to include the <c>await</c> within the <c>using</c> statement to avoid
            hard to debug problems.  The <c>await</c> ensures that the <c>using</c> statement
            will dispose the acquired lock as opposed to the <see cref="T:System.Threading.Tasks.Task"/> that returns
            the lock.
            </note>
            <para>
            Applications that cannot use a <c>using</c> statement may release the lock explicitly
            by disposing the object returned by the lock method, like this:
            </para>
            <code language="cs">
            var rwLock   = new AsyncReaderWriterLock();
            var readLock = await rwLock.GetReadLockAsync();
            
            // Protected reading code.
            
            readLock.Dispose();
            </code>
            <para>
            <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/>'s <see cref="M:Neon.Tasks.AsyncReaderWriterLock.Dispose"/> method ensures that any tasks
            waiting for a lock will be unblocked with an <see cref="T:System.ObjectDisposedException"/>.
            </para>
            <para>
            This class is implemented is fairly simple and always favors writers over readers.
            Also, all waiting readers will be released together.
            </para>
            <note>
            <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/> does not support any kind of reentrant <see cref="T:System.Threading.Tasks.Task"/>
            locking support.  Child tasks will be considered to be completely independent of the parent
            and <b>will not</b> inherit the parent's lock and a single task will not be able to acquire 
            the same lock multiple times.
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="T:Neon.Tasks.AsyncReaderWriterLock.Lock">
            <summary>
            The disposable lock returned by an <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/> granting read
            or write access to a resource.  Call <see cref="M:Neon.Tasks.AsyncReaderWriterLock.Lock.Dispose"/> to release the lock.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Lock.#ctor(Neon.Tasks.AsyncReaderWriterLock,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="parent">The parent lock.</param>
            <param name="isWriteLock"><c>true</c> if for a write lock.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Lock.Dispose">
            <summary>
            Releases the lock acquired from a <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/>.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this lock.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this lock.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.GetReadLockAsync">
            <summary>
            Acquires a non-exclusive read lock.
            </summary>
            <returns>The <see cref="T:System.IDisposable"/> instance to be disposed to release the lock.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the lock is disposed before or after this method is called.</exception>
            <remarks>
            <note>
            This class allows multiple readers to hold the lock at any given time but requires
            that writers have exclusive access.  Writers are given priority over readers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.ReleaseReadLock">
            <summary>
            Called by a <see cref="T:Neon.Tasks.AsyncReaderWriterLock.Lock"/> to release a read lock.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.GetWriteLockAsync">
            <summary>
            Acquires an exclusive write lock.
            </summary>
            <returns>The <see cref="T:System.IDisposable"/> instance to be disposed to release the lock.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the lock is disposed before or after this method is called.</exception>
            <remarks>
            <note>
            This class allows multiple readers to hold the lock at any given time but requires
            that writers have exclusive access.  Writers are given priority over readers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.ReleaseWriteLock">
            <summary>
            Called by a <see cref="T:Neon.Tasks.AsyncReaderWriterLock.Lock"/> to release a write lock.
            </summary>
        </member>
        <member name="T:Neon.Tasks.AsyncReentrantMutex">
            <summary>
            Extends <see cref="T:Neon.Tasks.AsyncMutex"/> to support reentrancy.
            </summary>
            <remarks>
            <para>
            Unlike the <see cref="T:Neon.Tasks.AsyncMutex"/> class, this class supports reentrency, meaning
            that once an asynchronous <see cref="T:System.Threading.Tasks.Task"/> flow has acquired the mutex, any additional
            acquistions by nested operations will also be accepted.
            </para>
            <code language="cs">
            var mutex = new AsyncReentrantMutex();
            
            await mutex.ExecuteActionAsync(
                async () =>
                {
                    // Protected code
                    
                    await mutex.ExecuteActionAsync(   // &lt;--- This doesn't block
                        async () =>
                        {
                            // More protected code
                        });
                });
            </code>
            <para>
            The <see cref="M:Neon.Tasks.AsyncReentrantMutex.ExecuteFuncAsync``1(System.Func{System.Threading.Tasks.Task{``0}})"/> can be used to execute an async
            function that returns a result instead.
            </para>
            <para>
            <see cref="T:Neon.Tasks.AsyncReentrantMutex"/> is disposable.  Calling dispose will cause
            <see cref="T:System.ObjectDisposedException"/> to be thrown on any tasks waiting
            to acquire the mutex.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReentrantMutex.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReentrantMutex.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReentrantMutex.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this mutex.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReentrantMutex.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncReentrantMutex.ExecuteActionAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Acquires the mutex and then invokes the asynchronous action passed.  This method
            returns after the action completes.
            </summary>
            <param name="action">The asynchronous action.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Tasks.AsyncReentrantMutex.ExecuteFuncAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Acquires the mutex and then invokes the asynchronous function passed, returning
            the function's result.
            </summary>
            <typeparam name="TResult">Specifies the result returned by the async function.</typeparam>
            <param name="function">The asynchronous function.</param>
            <returns>The function result.</returns>
        </member>
        <member name="T:Neon.Tasks.AsyncTimer">
            <summary>
            Implements a timer that runs on a background <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <remarks>
            <para>
            This class is pretty easy to use.  Simply use the <see cref="M:Neon.Tasks.AsyncTimer.#ctor(System.Func{System.Threading.Tasks.Task})"/>
            constructor to create an instance, passing the async callback to be called when the 
            timer fires and then call <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/> to start the timer, passing
            the timer interval.
            </para>
            <para>
            <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/> starts a background task that fires the callback at the interval
            specified.  You can call <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/> again to restart the timer with a different
            interval.  The <see cref="P:Neon.Tasks.AsyncTimer.IsRunning"/> property can be used to determine whether a 
            timer is running or not.
            </para>
            <para>
            Call <see cref="M:Neon.Tasks.AsyncTimer.Stop"/> to stop a timer.  <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/> may be called again to
            restart the timer.
            </para>
            <note>
            This class implements <see cref="T:System.IDisposable"/> so this should be called for every 
            instance created or <see cref="M:Neon.Tasks.AsyncTimer.Stop"/> should be called explicitly.
            </note>
            <note>
            This class handles any exceptions thrown by the callback by logging them to the
            default <see cref="T:Neon.Diagnostics.TelemetryHub"/> and then continuing on with firing ticks.  
            You'll need to add a try/catch to your callback to do your own exception handling.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.#ctor(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Constructor.
            </summary>
            <param name="callback">Optionally specifies the callback.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="P:Neon.Tasks.AsyncTimer.IsRunning">
            <summary>
            <para>
            Indicates whether the timer is currently running.
            </para>
            <note>
            This returns <see cref="F:System.TimeSpan.Zero"/> until <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/>
            is called for the first time.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Tasks.AsyncTimer.Interval">
            <summary>
            Returns the timer interval.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.CheckDisposed">
            <summary>
            Ensures that the instance is not disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown when the instance is disposed.</exception>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})">
            <summary>
            <para>
            Starts or restarts the timer.
            </para>
            <para>
            The <paramref name="interval"/> must be specified as a positive interval when
            the timer is first started but this is optional thereafter, defaulting to
            value from the original <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/> call.
            </para>
            </summary>
            <param name="interval">Optionally specifies the timer interval.</param>
            <param name="delayFirstTick">
            The callback is called immediately by default.  You can delay this for 
            <paramref name="interval"/> by passing this as <c>true</c>.  This defaults
            to <c>false</c>.
            </param>
            <param name="callback">
            <para>
            Optionally specifies the timer callback.
            </para>
            <note>
            This must be specified if no callback was passed to the constructor or a previous
            call to <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/>.
            </note>
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is the first time <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/> is called for the
            instance and <paramref name="interval"/> is not passed or when <paramref name="callback"/> is
            <c>null</c> and no callback was specified in constructor or a previous call to 
            <see cref="M:Neon.Tasks.AsyncTimer.Start(System.TimeSpan,System.Boolean,System.Func{System.Threading.Tasks.Task})"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">Thrown when the instance is disposed.</exception>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.Stop">
            <summary>
            Stops the timer.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown when the instance is disposed.</exception>
        </member>
        <member name="M:Neon.Tasks.AsyncTimer.TimerLoopAsync">
            <summary>
            Implements the async timer loop.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Tasks.IAsyncFuture">
            <summary>
            Defines an interface that completes a future operation asynchronously.
            </summary>
        </member>
        <member name="M:Neon.Tasks.IAsyncFuture.GetAsync">
            <summary>
            Returns when the asynchronous operation has completed.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Tasks.IAsyncFuture`1">
            <summary>
            Defines an interface that returns the value from the asynchronous operation.
            </summary>
            <typeparam name="T">The result type.</typeparam>
        </member>
        <member name="M:Neon.Tasks.IAsyncFuture`1.GetAsync">
            <summary>
            Returns the value from the operation.
            </summary>
            <returns>The future.</returns>
        </member>
        <member name="T:Neon.Tasks.NamespaceDoc">
            <summary>
            This namespace includes a handful of types that implement the async equivalent of
            primitives like <b>auto/manual reset events</b>, <b>mutexes</b>, <b>reader/writer locks</b>, 
            and <b>timers</b>.  This also includes <b>SyncContext</b> which can be used to easily
            clear the synchronization context within API implementations.
            </summary>
        </member>
        <member name="T:Neon.Tasks.NonDisposableTask">
            <summary>
            Used to convert a <see cref="T:System.Threading.Tasks.Task"/> into an awaitable that that does not
            implement <see cref="T:System.IDisposable"/>.  This is useful for avoiding confusion
            and hard to debug problems when async methods return an <see cref="T:System.IDisposable"/>
            intended to be referenced in a <c>using</c> statement.  It is very easy to forget
            the <c>await</c> keyword in this situation and because <see cref="T:System.Threading.Tasks.Task"/>
            also implements <see cref="T:System.IDisposable"/>, there will be no compiler error
            or warning.  Wrapping the task with this structure addresses this.
            </summary>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Constructor.
            </summary>
            <param name="task">The task being wrapped.</param>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask.GetAwaiter">
            <summary>
            Returns the task's awaiter.
            </summary>
        </member>
        <member name="T:Neon.Tasks.NonDisposableTask`1">
            <summary>
            Used to convert a <see cref="T:System.Threading.Tasks.Task`1"/> into an awaitable that that does not
            implement <see cref="T:System.IDisposable"/>.  This is useful for avoiding confusion
            and hard to debug problems when async methods return an <see cref="T:System.IDisposable"/>
            intended to be referenced in a <c>using</c> statement.  It is very easy to forget
            the <c>await</c> keyword in this situation and because <see cref="T:System.Threading.Tasks.Task`1"/>
            also implements <see cref="T:System.IDisposable"/>, there will be no compiler error
            or warning.  Wrapping the task with this structure addresses this.
            </summary>
            <typeparam name="T">The task result type.</typeparam>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            Constructor.
            </summary>
            <param name="task">The task being wrapped.</param>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask`1.GetAwaiter">
            <summary>
            Returns the task's awaiter.
            </summary>
        </member>
        <member name="T:Neon.Tasks.SyncContext">
             <summary>
             Used by public <c>async</c> library methods to reset the current task
             <see cref="T:System.Threading.SynchronizationContext"/> so that continuations won't be 
             marshalled back to the current thread which can cause serious problems
             for UI apps.
             </summary>
             <remarks>
             <para>
             This class was adapted from this blog post:
             </para>
             <para>
             <a href="https://blogs.msdn.microsoft.com/benwilli/2017/02/09/an-alternative-to-configureawaitfalse-everywhere/"/>
             </para>
             <para>
             I renamed the structure, converted it into a singleton and added an optional <see cref="M:System.Threading.Tasks.Task.Yield"/>
             call and a global mode to tune the operation for server vs. UI applications.
             </para>
             <para>
             The <b>async/await</b> pattern is more complex than it seems because the code after the await may
             run on the same thread that performed the await in some circumstances (e.g. for UI applications)
             or on another thread in other environments.  Library code needs to adapt to both situations.
             </para>
             <para>
             UI platforms like WinForms, WPF, UXP,... require that all user interface manipulation happen
             on the UI thread and the synchronization context in these cases will be configured to have 
             all awaits default to continuing on the calling (typically UI) thread to make it easy for 
             developers to await a long running operation and then update the UI afterwards.
             </para>
             <para>
             The problem for UI applications is that if the awaited operation internally awaits on additional
             operations (which is quite common), then each of the internal operations will also continue on
             the UI thread.  This can be big problem because there's only one UI thread and continuing on
             the UI thread means that the operation needs to be queued to the application's dispatcher possibly
             leading to serious performance and usability issues.
             </para>
             <para>
             This is less of a problem for console and server apps where awaited operations generally continue
             on any free threadpool thread, but <see cref="T:System.Threading.Tasks.Task"/> scheduling can be customized so this isn't
             necessarily always the case.
             </para>
             <para>
             As the blog post linked above describes, developers are encouraged to call <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/>,
             passing <c>false</c> for every <c>async</c> call where the result doesn't need to be marshalled back
             to the original synchronization context.  Non-UI class libraries typically don't care about this.
             The problem is that to do this properly, MSFT recommends that you call <c>Task.ConfigureAwait(false)</c>
             on <b>EVERY</b> <c>async</c> call you made in these situations.  This is pretty ugly and will be tough
             to enforce on large projects over long periods of time because it's just too easy to miss one.
             </para>
             <para>
             It's also likely that async library methods will be called serveral, perhaps hundreds of times by
             applications and it's a shame to require application developers to call <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/>
             everywhere rather than somehow having the library APIs handle this.
             </para>
             <para>
             This <c>struct</c> implements a custom awaiter that saves the current synchronization context and then
             clears it for the rest of the current method execution and then restores the original context when
             when the method returns.  This means that every subsequent <c>await</c>  performed within the method will 
             simply fetch a pool thread to continue execution, rather than to the original context thread.  To
             accomplish this, you'll simply await <see cref="P:Neon.Tasks.SyncContext.Clear"/> at or near the top of your 
             async methods:
             </para>
             <para>
             The global <see cref="P:Neon.Tasks.SyncContext.Mode"/> property controls what the <see cref="P:Neon.Tasks.SyncContext.Clear"/> method actually does.
             This defaults to <see cref="F:Neon.Tasks.SyncContextMode.ClearOnly"/> which turns <see cref="P:Neon.Tasks.SyncContext.Clear"/> into a NOP
             which is probably suitable for most non-UI applications that reduce overhead and increase performance.
             </para>
             <para>
             UI applications should probably set the <see cref="F:Neon.Tasks.SyncContextMode.ClearAndYield"/> which prevents
             nested method continuations from running on the UI thread and also ensures that any initial synchronous
             code won't run on the UI thread either.
             </para>
             <code language="C#">
             using Neon.Tasks;
             
             public async Task&lt;string&gt; HelloAsync()
             {
                 // On UI thread
                 
                 await SyncContext.Clear;
                 
                 // On background thread
                 
                 SlowSyncOperation();
                 
                 // On background thread
                 
                 await DoSomthingAsync();
                 
                 // On background thread
                 
                 await DoSomethingElseAsync();
                 
                 // On background thread
                 
                 return "Hello World!";
             }
            
             public async Task Main(string[] args)
             {
                 // Set a mode suitable for UI apps.
                 
                 SyncContext.Mode = SyncContextMode.ClearAndYield;
                 
                 // Assume that we're running on a UI thread here.
                 
                 var greeting = await HelloAsync();
                 
                 // On UI thread
             }
             </code>
             <para>
             This example sets the <see cref="F:Neon.Tasks.SyncContextMode.ClearAndYield"/> mode 
             and then awaits <c>HelloAsync()</c> which clears the sync context and
             then performs a long running synchronous operation and then two async
             operations.  Note how all of the continuations in <c>HelloAsync()</c>
             after the clear are running on a background thread but the continuation
             after <c>await HelloAsync()</c> is back to running on the UI thread.
             </para>
             <para>
             This is pretty close to being ideal behavior.
             </para>
             </remarks>
        </member>
        <member name="P:Neon.Tasks.SyncContext.Clear">
            <summary>
            <c>await</c> this singleton to clear the current synchronization
            context for the scope of the current method as a potential performance
            optimization.  The original context will be restored when the method 
            returns.
            </summary>
            <remarks>
            <para>
            You'll typically at or near the top of your method.  This will
            look something like:
            </para>
            <code language="C#">
            using Neon.Tasks;
            
            public async Task&lt;string&gt; HelloAsync()
            {
                await SyncContext.Clear;
                
                await DoSomthingAsync();
                await DoSomethingElseAsync();
                
                return "Hello World!";
            }
            </code>
            <note>
            <see cref="P:Neon.Tasks.SyncContext.Clear"/> is not a method.
            </note>
            <para>
            Awaiting this property clears the current synchronization context such 
            that the subsequent <c>async</c> calls will each marshal back to threads
            obtained from the thread pool and due to the compiler's async magic,
            the original synchronization context will be restored before the
            <c>HelloAsync()</c> method returns.
            </para>
            <para>
            The <see cref="P:Neon.Tasks.SyncContext.Mode"/> property controls what awaiting <see cref="P:Neon.Tasks.SyncContext.Clear"/>
            actually does.  This defaults to <see cref="F:Neon.Tasks.SyncContextMode.ClearOnly"/>
            which is probably suitable for most non-UI applications.  UI applications
            will probably want to explicitly set <see cref="F:Neon.Tasks.SyncContextMode.ClearAndYield"/>
            to help keep continations off the UI thread, which is often desirable.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Tasks.SyncContext.Mode">
            <summary>
            <para>
            Used to control what <see cref="P:Neon.Tasks.SyncContext.Clear"/> actually does.  This defaults to
            <see cref="F:Neon.Tasks.SyncContextMode.ClearOnly"/> which is probably suitable for most
            non-UI applications by reducing task overhead.  UI application will probably
            want to set <see cref="F:Neon.Tasks.SyncContextMode.ClearAndYield"/> to keep work from
            running on the UI thread.
            </para>
            <para>
            This defaults to <see cref="F:Neon.Tasks.SyncContextMode.ClearOnly"/> for server code,
            because we're writing more server applications than UI applications these
            days.
            </para>
            </summary>
        </member>
        <member name="M:Neon.Tasks.SyncContext.#ctor(System.Int32)">
            <summary>
            Private constructor.
            </summary>
            <param name="stub">Ignored.</param>
        </member>
        <member name="P:Neon.Tasks.SyncContext.IsCompleted">
            <summary>
            <b>INTERNAL USE ONLY:</b> Do not call this directly.
            </summary>
        </member>
        <member name="M:Neon.Tasks.SyncContext.OnCompleted(System.Action)">
            <summary>
            <b>INTERNAL USE ONLY:</b> Do not call this directly.
            </summary>
            <param name="continuation">The continuation action.</param>
        </member>
        <member name="M:Neon.Tasks.SyncContext.GetAwaiter">
            <summary>
            <b>INTERNAL USE ONLY:</b> Do not call this directly.
            </summary>
        </member>
        <member name="M:Neon.Tasks.SyncContext.GetResult">
            <summary>
            <b>INTERNAL USE ONLY:</b> Do not call this directly.
            </summary>
        </member>
        <member name="T:Neon.Tasks.SyncContextMode">
            <summary>
            Enumerates the <see cref="T:Neon.Tasks.SyncContext"/> modes, configured by setting <see cref="P:Neon.Tasks.SyncContext.Mode"/>.
            </summary>
        </member>
        <member name="F:Neon.Tasks.SyncContextMode.ClearOnly">
            <summary>
            <para>
            Enables `await SyncContext.Clear;` such that the continuations within the
            nested scope of the method will not happen on the original thread.
            </para>
            <para>
            This mode is the default and is generally suitable for server and other
            non-UI applications.
            </para>
            </summary>
        </member>
        <member name="F:Neon.Tasks.SyncContextMode.ClearAndYield">
            <summary>
            <para>
            Enables `await SyncContext.Clear;` such that the continuations within the
            nested scope of the method will not happen on the original thread and that
            the awaitee can immediately release the current thread for other uses.
            </para>
            <para>
            This mode is useful for UI applications because it ensures that any synchronous
            operations won't be executed on the original thread.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Time.GatedTimer">
            <summary>
            Implements a timer that allows only one thread at a time to process timer events.
            </summary>
            <remarks>
            <para>
            This is necessary to because the <see cref="T:System.Threading.Timer"/> class will continue firing
            thread handlers even if a long-running thread is still handling an earlier
            timer event.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.GatedTimer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan)">
            <summary>
            Initializes and starts the timer.
            </summary>
            <param name="callback">The callback to be called when the timer fires.</param>
            <param name="state">Application state.</param>
            <param name="period">Time to wait between firing events.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes and starts the timer.
            </summary>
            <param name="callback">The callback to be called when the timer fires.</param>
            <param name="state">Application state.</param>
            <param name="dueTime">Time to wait before firing the first event.</param>
            <param name="period">Time to wait between firing events.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Time.GatedTimer.Dispose">
            <summary>
            Releases all resources associated with the timer.
            </summary>
        </member>
        <member name="M:Neon.Time.GatedTimer.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.Change(System.TimeSpan,System.TimeSpan)">
            <summary>
            Modifies the timer.
            </summary>
            <param name="dueTime">Time to wait before firing the first event.</param>
            <param name="period">Time to wait between firing events.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.OnTimer(System.Object)">
            <summary>
            Handles the timer dispatch.
            </summary>
            <param name="state">The timer state.</param>
        </member>
        <member name="T:Neon.Time.GoDuration">
            <summary>
            Implements support for GO Language formatted durations.  This class is
            useful for integrating with GO applications.
            </summary>
            <remarks>
            <note>
            <para>
            <see cref="T:Neon.Time.GoDuration"/> measures time down 1 nanosecond resolution whereas
            <see cref="P:Neon.Time.GoDuration.TimeSpan"/>'s resolution is 100ns and both implementations use
            a signed 64-bit integer as the underlying representation.  This means that
            <see cref="T:Neon.Time.GoDuration"/> can represent of maximum duration of about 290
            years (positive and negative) where <see cref="P:Neon.Time.GoDuration.TimeSpan"/> can handle 
            about 29,000 years.
            </para>
            <para>
            This class will throw a <see cref="T:System.ArgumentOutOfRangeException"/> when converting
            a <see cref="P:Neon.Time.GoDuration.TimeSpan"/> that is beyound the capability of a <see cref="T:Neon.Time.GoDuration"/>.
            </para>
            </note>
            </remarks>
        </member>
        <member name="F:Neon.Time.GoDuration.PartialRegEx">
            <summary>
            The partial regular expression that can be used to validate GOLANG duration strings.  This
            does not include the start/end anchors and is suitable for situations where these are implied.
            </summary>
        </member>
        <member name="F:Neon.Time.GoDuration.RegEx">
            <summary>
            The full regular expression (including start/end anchors) use to validate GOLANG duration strings.
            </summary>
        </member>
        <member name="F:Neon.Time.GoDuration.TicksPerMicrosecond">
            <summary>
            The number of nanosecond ticks per micrososecond.
            </summary>
        </member>
        <member name="F:Neon.Time.GoDuration.TicksPerMillisecond">
            <summary>
            The number of nanosecond ticks per millisecond.
            </summary>
        </member>
        <member name="F:Neon.Time.GoDuration.TicksPerSecond">
            <summary>
            The number of nanosecond ticks per second;
            </summary>
        </member>
        <member name="F:Neon.Time.GoDuration.TicksPerMinute">
            <summary>
            The number of nanosecond ticks per minute.
            </summary>
        </member>
        <member name="F:Neon.Time.GoDuration.TicksPerHour">
            <summary>
            The number of nanosecond ticks per minute.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.Zero">
            <summary>
            Returns a zero <see cref="T:Neon.Time.GoDuration"/> .
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.MinValue">
            <summary>
            Returns the minimum possible <see cref="T:Neon.Time.GoDuration"/>.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.MaxValue">
            <summary>
            Returns the maximum possible <see cref="T:Neon.Time.GoDuration"/>.
            </summary>
        </member>
        <member name="F:Neon.Time.GoDuration.MinValueString">
            <summary>
            The minimum value serialized to a string (computed by hand to avoid 64-bit wrap around issues.
            </summary>
        </member>
        <member name="M:Neon.Time.GoDuration.op_Implicit(Neon.Time.GoDuration)~System.TimeSpan">
            <summary>
            Implicitly converts a <see cref="T:Neon.Time.GoDuration"/> into a <see cref="P:Neon.Time.GoDuration.TimeSpan"/>.
            </summary>
            <param name="goTimeSpan">The input <see cref="T:Neon.Time.GoDuration"/>.</param>
            <returns>The equivalent <see cref="P:Neon.Time.GoDuration.TimeSpan"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoDuration.op_Implicit(System.TimeSpan)~Neon.Time.GoDuration">
            <summary>
            Implicitly converts a <see cref="P:Neon.Time.GoDuration.TimeSpan"/> into a <see cref="T:Neon.Time.GoDuration"/>.
            </summary>
            <param name="timespan">The input <see cref="P:Neon.Time.GoDuration.TimeSpan"/>.</param>
            <returns>The equivalent <see cref="T:Neon.Time.GoDuration"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoDuration.TryParse(System.String,Neon.Time.GoDuration@)">
            <summary>
            Attempts to parse a GO formatted timespan.  
            </summary>
            <param name="input">The input string.</param>
            <param name="goTimeSpan">Returns as the parsed timespan on success.</param>
            <returns><c>true</c> on success.</returns>
            <remarks>
            <para>
            The input is a possibly signed sequence of decimal numbers, each with 
            optional fraction and a unit suffix, such as "300ms", "-1.5h" or 
            "2h45m". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". 
            </para>
            <note>
            GO timespans are limited to about 290 years (the maximum number of
            nanoseconds that can be represented in a signed 64-bit integer).
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Time.GoDuration.Parse(System.String)">
            <summary>
            Parses a <see cref="T:Neon.Time.GoDuration"/> from a string.
            </summary>
            <param name="input">The input string.</param>
            <returns>The parsed <see cref="T:Neon.Time.GoDuration"/>.</returns>
            <exception cref="T:System.FormatException">Thrown if the input is not valid.</exception>
            <remarks>
            <para>
            The input is a possibly signed sequence of decimal numbers, each with 
            optional fraction and a unit suffix, such as "300ms", "-1.5h" or 
            "2h45m". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". 
            </para>
            <note>
            <c>null</c> or empty strings are parsed as <see cref="F:System.TimeSpan.Zero"/>.
            </note>
            <note>
            GO timespans are limited to about 290 years (the maximum number of
            nanoseconds that can be represented in a signed 64-bit integer).
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Time.GoDuration.FromTimeSpan(System.TimeSpan)">
            <summary>
            Creates a <see cref="T:Neon.Time.GoDuration"/> from a <see cref="P:Neon.Time.GoDuration.TimeSpan"/>.
            </summary>
            <param name="timespan">The input time span.</param>
            <returns>The new <see cref="T:Neon.Time.GoDuration"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoDuration.FromNanoseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoDuration"/> from nanoseconds.
            </summary>
            <param name="nanoseconds">The duration in nanoseconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoDuration"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoDuration.FromMicroseconds(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoDuration"/> from microseconds.
            </summary>
            <param name="milliseconds">The duration in microseconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoDuration"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoDuration"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoDuration.FromMilliseconds(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoDuration"/> from milliseconds.
            </summary>
            <param name="milliseconds">The duration in milliseconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoDuration"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoDuration"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoDuration.FromSeconds(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoDuration"/> from seconds.
            </summary>
            <param name="seconds">The duration in seconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoDuration"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoDuration"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoDuration.FromMinutes(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoDuration"/> from minutes.
            </summary>
            <param name="minutes">The duration in minutes.</param>
            <returns>The new <see cref="T:Neon.Time.GoDuration"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoDuration"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoDuration.FromHours(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoDuration"/> from hours.
            </summary>
            <param name="hours">The duration in hours.</param>
            <returns>The new <see cref="T:Neon.Time.GoDuration"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoDuration"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoDuration.ToTicks(System.Decimal)">
            <summary>
            Converts a <c>double</c> nanosecond count to a <c>long</c>, ensuring that the
            result can be represented as a <see cref="T:Neon.Time.GoDuration"/>.
            </summary>
            <param name="nanoseconds">The input <c>douuble</c>.</param>
            <returns>The output <c>long</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoDuration"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoDuration.#ctor(System.Int64)">
            <summary>
            Constructs a <see cref="T:Neon.Time.GoDuration"/> from nanoseconds.
            </summary>
            <param name="nanoseconds">The duration in nanoseconds.</param>
        </member>
        <member name="M:Neon.Time.GoDuration.#ctor(System.TimeSpan)">
            <summary>
            Constructs an instance from a <see cref="P:Neon.Time.GoDuration.TimeSpan"/>.
            </summary>
            <param name="timespan">The time span.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoDuration"/>.</exception>
        </member>
        <member name="P:Neon.Time.GoDuration.Ticks">
            <summary>
            The duration expressed as nanosecond ticks.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.TotalNanoseconds">
            <summary>
            Returns the duration as nanoseconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.TotalMicroseconds">
            <summary>
            Returns the total number of microseconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.TotalMilliseconds">
            <summary>
            Returns the total number of milliseconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.TotalSeconds">
            <summary>
            Returns the total number of seconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.TotalMinutes">
            <summary>
            Returns the total number of minutes.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.TotalHours">
            <summary>
            Returns the total number of hours.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.Nanoseconds">
            <summary>
            Returns the nanosecond component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.Microseconds">
            <summary>
            Returns the microsecond component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.Milliseconds">
            <summary>
            Returns the millisecond component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.Seconds">
            <summary>
            Returns the second component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.Minutes">
            <summary>
            Returns the minutes component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.Hours">
            <summary>
            Returns the hours component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoDuration.TimeSpan">
            <summary>
            Returns the equivalent <see cref="P:Neon.Time.GoDuration.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:Neon.Time.GoDuration.ToString">
            <summary>
            Renders the time span as a GO Duration compatible string.
            </summary>
            <returns>The GO duration.</returns>
        </member>
        <member name="M:Neon.Time.GoDuration.ToPretty">
            <summary>
            Renders the duration into a string including hour, minute, and seconds with
            fractions as required, avoiding millisecond, microsecond, and nanosecond units.
            </summary>
            <returns>The pretty string.</returns>
        </member>
        <member name="T:Neon.Time.NamespaceDoc">
            <summary>
            This namespace includes some time related types.
            </summary>
        </member>
        <member name="T:Neon.Time.PolledTimer">
            <summary>
            Implements a timer suitable for use in scenarios that need to 
            poll periodically to see if an action needs to be performed.
            </summary>
            <remarks>
            <para>
            A common programming pattern is to have background threads check
            periodically for something to do; like resend a message, clean up
            idle connections, or signal a timeout.  The <see cref="T:Neon.Time.PolledTimer" />
            class provides an easy way to encapsulate the interval and next
            scheduled time at which these events should happen.
            </para>
            <para>
            Use <see cref="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan)" /> or <see cref="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan,System.Boolean)" />
            to create a timer, specifying the firing interval.  The second constructor
            also specifies the <i>autoReset</i> parameter which indicates that the
            timer should automatically reschedule itself after being fired.  Note that
            one of these constructors <b>must be used</b>.  <see cref="T:Neon.Time.PolledTimer" />
            structures created with the default constructor will thow a <see cref="T:System.InvalidOperationException" />
            when an attempt is made to use it.
            </para>
            <para>
            While being constructed, a polled timer calculates its next scheduled firing time (SYS).
            Note that this value generated by <see cref="T:Neon.Time.SysTime" /> not a normal system time.
            The scheduled firing time is available as the <see cref="P:Neon.Time.PolledTimer.FireTime" /> property.
            Ther current interval is available as the <see cref="P:Neon.Time.PolledTimer.Interval" /> property.
            </para>
            <para>
            Use <see cref="P:Neon.Time.PolledTimer.HasFired" /> to determine if the timer has been fired.  This
            will return <c>true</c> if this is the case.  If <i>autoReset=true</i> was 
            passed to the constructor, then <see cref="P:Neon.Time.PolledTimer.HasFired" /> will automatically 
            reset the timer by scheduling the next firing time.  If <i>autoReset=false</i>,
            then the timer will remain in the fired state until <see cref="M:Neon.Time.PolledTimer.Reset" /> is
            called.
            </para>
            <para>
            Asynchronous applications may find it more convienent to call <see cref="M:Neon.Time.PolledTimer.WaitAsync(System.TimeSpan)"/>
            to wait for the timer to fire.
            </para>
            <para>
            The <see cref="M:Neon.Time.PolledTimer.Reset" />, <see cref="M:Neon.Time.PolledTimer.ResetImmediate" />, and <see cref="M:Neon.Time.PolledTimer.ResetRandom" /> 
            methods are used recalcuclate the firing time.  The first variation schedules this time as
            the current time plus the timer interval.  The second variation schedules
            the timer for immediate firing (typically used right after the timer is
            constructed in situations where the application wishes the timer to fire
            right away the first time it is polled), and the third method resets the timer
            to fire at a random interval between zero and the timer's interval (useful when
            trying to avoid having multiple timers fire at the same time).
            </para>
            <para>
            The <see cref="M:Neon.Time.PolledTimer.Disable" /> method prevents the timer from firing until
            <see cref="M:Neon.Time.PolledTimer.Reset" /> is called or <see cref="P:Neon.Time.PolledTimer.Interval" /> is set.
            This is useful for preventing a timer from firing when an operation
            initiated from a previous firing is still executing (perhaps on another
            thread).
            </para>
            </remarks>
            <threadsafety instance="true" />
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor">
            <summary>
            The default constructor creates a timer that is initially disabled.
            </summary>
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor(System.Boolean)">
            <summary>
            The default constructor creates a timer that is initially disabled
            with optional auto reset capabilities. 
            </summary>
            <param name="autoReset">Indicates whether the timer should automatically reset itself after firing.</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan)">
            <summary>
            Constructs a timer, initializing it to fire at the specified interval.
            </summary>
            <param name="interval">The timer interval.</param>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan,System.Boolean)">
            <summary>
            Constructs a timer with the option of auto resetting itself.
            </summary>
            <param name="interval">The timer interval.</param>
            <param name="autoReset">Pass <c>true</c> to create an auto reset timer.</param>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.Reset">
            <summary>
            Reschedules the timer to fire at the current time plus the timer interval.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetImmediate">
            <summary>
            Reschedules the timer to fire immediately.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetRandom">
            <summary>
            Reschedules the timer to fire at a random time between now and the timer interval.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetAddRandom(System.TimeSpan)">
            <summary>
            Reschedules the timer to fire at a random time between the current scheduled
            firing time and a random interval between <see cref="F:System.TimeSpan.Zero" /> and
            <paramref name="interval" />.
            </summary>
            <param name="interval">The interval to be randomized (can be positive or negative).</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.Reset(System.TimeSpan)">
            <summary>
            Assigns a new interval to the timer and reschedules the timer
            to fire at the current time plus the new interval.
            </summary>
            <param name="interval">The new timer interval.</param>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetTemporary(System.TimeSpan)">
            <summary>
            Reschedules the timer to fire at the current time plus the specified interval
            but <b>does not</b> change the underlying timer interval.  Subsequent timer
            resets will continue to use the original interval.
            </summary>
            <param name="interval">The timer wait interval.</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetRandomTemporary(System.TimeSpan,System.TimeSpan)">
            <summary>
            Reschedules the timer to fire at the current time plus a randomly selected
            time between the two intervals passed.  This call <b>does not</b> change the 
            underlying timer interval.  Subsequent timer resets will continue to use the 
            original interval.
            </summary>
            <param name="minInterval">The minimum timer wait interval.</param>
            <param name="maxInterval">The maximum timer wait interval.</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.FireNow">
            <summary>
            Sets the timer into the fired state.
            </summary>
        </member>
        <member name="M:Neon.Time.PolledTimer.Disable">
            <summary>
            Prevents the timer from firing until one of the <see cref="M:Neon.Time.PolledTimer.Reset" /> methods
            are called or <see cref="P:Neon.Time.PolledTimer.Interval" /> is assigned a new value.
            </summary>
        </member>
        <member name="P:Neon.Time.PolledTimer.HasFired">
            <summary>
            Determines whether the timer has fired.
            </summary>
            <returns><c>true</c> if the timer has fired.</returns>
            <remarks>
            For auto reset timers, this property will reschedule the next
            firing time if the timer has fired.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.WaitAsync(System.TimeSpan)">
            <summary>
            Waits aynchronously for the timer to fire.
            </summary>
            <param name="pollInterval">Optional timer polling interval (defaults to <b>15 seconds</b>).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="P:Neon.Time.PolledTimer.FireTime">
            <summary>
            Returns the scheduled firing time (SYS).
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="P:Neon.Time.PolledTimer.Interval">
            <summary>
            The current timer interval.
            </summary>
            <remarks>
            <note>Setting a new interval causes the timer fire time to be rescheduled.</note>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
        </member>
        <member name="T:Neon.Time.RecurringTimer">
            <summary>
            Used to manage tasks that need to be performed on a periodic basis.
            </summary>
            <remarks>
            <para>
            This timer is designed to be polled periodically from an application's background
            thread by calling the <see cref="M:Neon.Time.RecurringTimer.HasFired" /> or <see cref="M:Neon.Time.RecurringTimer.HasFired(System.DateTime)" />
            methods.  These methods will return <c>true</c> if the action associated with the timer
            is to be performed.
            </para>
            <para>
            This class works by watching for the transition between a call to <see cref="M:Neon.Time.RecurringTimer.HasFired" />
            made at a time before the scheduled event and then a subsequent call made when the 
            current time is at or after the scheduled event time. <see cref="M:Neon.Time.RecurringTimer.HasFired" /> will
            return <c>true</c> on the subsequent call if the time is right.
            </para>
            <para>
            This behavior ensures that scheduled tasks will only be executed once for any recurring
            schedule, even if the application is restarted.
            </para>
            <para>
            The <see cref="M:Neon.Time.RecurringTimer.HasFired" /> method uses the current UTC time to perform the
            time comparison.  The <see cref="M:Neon.Time.RecurringTimer.HasFired(System.DateTime)" /> will use the time passed
            (which may be local time, etc.) to do this.
            </para>
            <note>
            <para>
            This timer auto resets after <see cref="M:Neon.Time.RecurringTimer.HasFired" /> returns <c>true</c>.  Note also
            that <see cref="M:Neon.Time.RecurringTimer.HasFired" /> must be called fairly frequently (on the order of a few minutes or less)
            to obtain reasonable accuracy.
            </para>
            <para>
            Asynchronous applications may find it more convienent to call <see cref="M:Neon.Time.RecurringTimer.WaitAsync(System.TimeSpan)"/>
            to wait for the timer to fire.
            </para>
            <para>
            The <see cref="M:Neon.Time.RecurringTimer.Reset"/> and <see cref="M:Neon.Time.RecurringTimer.Reset(System.DateTime)"/> methods may be used to explicitly
            reset the timer to fire at the next scheduled time.  This may be useful for ensuring that
            short duration timers are properly reset after an operation that may take longer to
            complete than the timer interval.
            </para>
            </note>
            <para>
            Recurring timers are represented as strings with the format of the string
            depending on the type of timer.  The table below describes these formats:
            </para>
            <list type="table">
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Disabled" /></term>
                    <description>
                    <para>
                    Disabled timers never fire.  Simply place the word <b>Disabled</b> at the
                    beginning of the timer string.
                    </para>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Minute" /></term>
                    <description>
                    <para>
                    Minute timers fire at the top of every minute.  There is no offset.  Minute
                    timers are formatted as:
                    </para>
                    <example>
                    Minute
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.QuarterHour" /></term>
                    <description>
                    <para>
                    Quarter hour timers are fired four times an hour at the offset from the 15 minute time.  
                    Quarter hour timers formatted as:
                    </para>
                    <example>
                    QuarterHour
                    QuarterHour:MM
                    QuarterHour:MM:SS
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Hourly" /></term>
                    <description>
                    <para>
                    Hourly timers are fired once per hour at the offset from the top of the hour.  Hourly timers
                    are formatted as:
                    </para>
                    <example>
                    Hourly
                    Hourly:MM
                    Hourly:MM:SS
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Daily" /></term>
                    <description>
                    <para>
                    Daily timers are fired once per day at the specified time of day.  Daily timers
                    are formatted as:
                    </para>
                    <example>
                    Daily
                    Daily:HH:MM
                    Daily:HH:MM:SS
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Interval" /></term>
                    <description>
                    <para>
                    Interval timers are fired on a regular interval that is not not
                    tied to a specific period.  Interval timers are formatted as:
                    </para>
                    <example>
                    Interval:HH:MM:SS
                    </example>
                    </description>
                </item>
            </list>
            </remarks>
            <threadsafety instance="false" />
        </member>
        <member name="P:Neon.Time.RecurringTimer.Disabled">
            <summary>
            Returns a disabled timer.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.TryParse(System.String,Neon.Time.RecurringTimer@)">
            <summary>
            Attempts to parse <see cref="T:Neon.Time.RecurringTimer"/> from a string.
            </summary>
            <param name="input">The input string.</param>
            <param name="timer">Returns as the parsed timer.</param>
            <returns><c>true</c> if the timer was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor">
            <summary>
            Default constructor that creates a <see cref="F:Neon.Time.RecurringTimerType.Disabled" /> timer.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor(System.String)">
            <summary>
            Constructs a timer by parsing a string value.
            </summary>
            <param name="value">The string representation.</param>
            <exception cref="T:System.ArgumentException">Thrown if the string passed is not valid.</exception>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor(Neon.Time.RecurringTimerType,System.TimeSpan)">
            <summary>
            Constructs a recurring timer of the specified type and time offset from
            the beginning of the implied period.
            </summary>
            <param name="type">Describes the timer type which implies the period.</param>
            <param name="timeOffset">The time offset from the beginning of the implied timer period.</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor(Neon.Time.TimeOfDay)">
            <summary>
            Constructs a recurring timer that will fire once a day at the specified time offset.
            </summary>
            <param name="timeOfDay">The time of day offset.</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.HasFired">
            <summary>
            Determines whether the timer has fired by comparing the current UTC time with
            the scheduled event time.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.HasFired(System.DateTime)">
            <summary>
            Determines if the timer has fired by comparing the current time passed with
            the next scheduled firing time.
            </summary>
            <param name="nowUtc">The current time (UTC).</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.WaitAsync(System.TimeSpan)">
            <summary>
            Waits aynchronously for the timer to fire.
            </summary>
            <param name="pollInterval">Optional timer polling interval (defaults to <b>15 seconds</b>).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Reset">
            <summary>
            Resets the timer to fire at the next scheduled interval after the current UTC time.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Reset(System.DateTime)">
            <summary>
            Resets the timer to fire at the next scheduled interval after the time passed.
            </summary>
            <param name="now">The current time.</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Start">
            <summary>
            Starts the timer by computing the next firing time after the current time (UTC).
            </summary>
            <remarks>
            <para>
            Applications may use this method to initalize the timer.  This is useful in situations where
            some time may pass between the time the timer was constructed and the first time
            <see cref="M:Neon.Time.RecurringTimer.HasFired" /> has been called.  In these situations, the timer will
            not fire for a scheduled event that occurs during this interval.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Start(System.DateTime)">
            <summary>
            Starts the timer by computing the next firing time after the time passed.
            </summary>
            <param name="nowUtc">The current time (UTC).</param>
            <remarks>
            <para>
            Applications may use this method to initalize the timer.  This is useful in situations where
            some time may pass between the time the timer was constructed and the first time
            <see cref="M:Neon.Time.RecurringTimer.HasFired" /> has been called.  In these situations, the timer will
            not fire for a scheduled event that occurs during this interval.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Set(System.DateTime)">
            <summary>
            Sets the firing time for the timer.
            </summary>
            <param name="timeUtc">Optionally specifies the scheduled time (UTC) (defaults to now).</param>
            <remarks>
            This is useful in situations where it is necessary to special-case a
            specific firing time.
            </remarks>
        </member>
        <member name="P:Neon.Time.RecurringTimer.Type">
            <summary>
            Returns the timer type.
            </summary>
        </member>
        <member name="P:Neon.Time.RecurringTimer.TimeOffset">
            <summary>
            Returns the <see cref="T:System.TimeSpan" /> offet from the beginning of the 
            period when the timer is scheduled to fire.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.GetTimeOffsetString">
            <summary>
            Renders the local timeoffset into a nice string.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.ToString">
            <summary>
            Renders the timer into a string.
            </summary>
            <returns>The timer string.</returns>
        </member>
        <member name="M:Neon.Time.RecurringTimer.TryParse(System.String)">
            <summary>
            Attempts to parse the configuration value.
            </summary>
            <param name="input">The configuration value.</param>
            <returns><c>true</c> if the value could be parsed, <b></b> if the value is not valid for the type.</returns>
        </member>
        <member name="T:Neon.Time.RecurringTimerType">
            <summary>
            Enumerates the possible <see cref="T:Neon.Time.RecurringTimer" /> types.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Disabled">
            <summary>
            The timer never fires.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Minute">
            <summary>
            The timer will be fired once per minute. 
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.QuarterHour">
            <summary>
            The timer will be fired once every 15 minutes.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Hourly">
            <summary>
            The timer will be fired once per hour.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Daily">
            <summary>
            The timer will be fired once per day.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Interval">
            <summary>
            The timer is fired on a specified interval rather than a 
            specific period offset.  This is similar to how <see cref="T:Neon.Time.PolledTimer" />
            works.
            </summary>
        </member>
        <member name="T:Neon.Time.SysTime">
            <summary>
            A date/time implementation that is guaranteed to be monotonically increasing
            even as the underlying system time is updated manually or automatically to adjust
            for daylight savings time or clock skewing.
            </summary>
            <remarks>
            <para>
            Use of system time rather than real-time is useful in situations
            where events need to be timed in relative rather than absolute time.
            Using absolute time to measure intervals call can be problematic
            because system clock may be have to be periodically corrected to
            keep it in sync with a global time base.  These corrections will
            cause event timers to become inaccurate.
            </para>
            <para>
            The <see cref="P:Neon.Time.SysTime.Now" /> property returns the current system time and
            <see cref="P:Neon.Time.SysTime.Infinite" /> calculates and returns an essentially infinite
            timespan value that will be safe when added to the current system time.
            </para>
            <note>
            The <see cref="T:System.DateTime" /> instances returned by this class are useful
            only for measuring timespans.  The Day, Month, Year properties 
            will have no useful meaning.
            </note>
            <note>
            The class is implemented such that the first time
            returned by the <see cref="P:Neon.Time.SysTime.Now" /> property will be a time value that 
            is a minumim of one year after <see cref="F:System.DateTime.MinValue" />.  This is 
            useful in situations where programs want to schedule a periodic event 
            for immediate triggering when the application starts by setting the last trigger
            time to <see cref="F:System.DateTime.MinValue" />.
            </note>
            <para>
            The <see cref="T:Neon.Time.SysTime" /> class is also capable of maintaining rough
            synchronization with an external time source.  To use this feature,
            you'll periodically get the time from the external source and assign
            it to the static <see cref="P:Neon.Time.SysTime.ExternalNow" /> property then you can
            use the <see cref="P:Neon.Time.SysTime.ExternalNow" /> property to get and estimate of the
            current external time.
            </para>
            <para>
            The local side clock will likely drift over time, resulting in a skew
            between the time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> and the actual
            time at the external source.  This skew can be limited by getting the
            external time and assigning it to <see cref="P:Neon.Time.SysTime.ExternalNow" /> more
            frequently.
            </para>
            <note>
            The time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> is not guaranteed to be
            monotimically increasing since reported times may jump around as the
            bias between the local and external clocks are adjusted.
            </note>
            <para><b><u>Implementation Note</u></b></para>
            <para>
            This class is currently implemented using the Windows <b>GetTickCount()</b> API.
            This function returns the number of milliseconds since the operating system
            was booted with a resolution equal to the process/threading timeslice (typically
            10-15 milliseconds).  The actual resolution for the current machine can be
            obtained from <see cref="P:Neon.Time.SysTime.Resolution" />.
            </para>
            <para>
            The <see cref="P:System.Environment.TickCount"/> counter is an unsigned 32-bit value and will wrap-around
            every 49.7 days.  The <see cref="T:Neon.Time.SysTime" /> class handles this by using a <see cref="T:Neon.Time.GatedTimer" />
            to wake up every five minutes to check for and handle this wrap-around.
            </para>
            <para>
            As noted above, the time value returned by <see cref="P:Neon.Time.SysTime.Now" /> has no relation
            to the actual calendar date.  The first date returned after booting the computer
            will be approximately 1/1/0002 00:00:00, one year <i>greater</i> the minimum <see cref="T:System.DateTime" />
            value.  <see cref="P:Neon.Time.SysTime.Infinite" /> returns a calculated value that when added to <see cref="P:Neon.Time.SysTime.Now" />
            will result in a date one year less then the maximum <see cref="T:System.DateTime" /> value.
            </para>
            <para>
            These one year offsets were choosen so that applications can perform reasonable
            offset calculations (e.g. within background tasks) without fear of wrap-around.
            Since <see cref="T:System.DateTime" /> and <see cref="T:System.TimeSpan" /> span up to 10,000
            years, this means that <see cref="T:Neon.Time.SysTime" /> calculations will remain valid
            for up to 9,998 years after the computer has been started, which should be
            good enough for most applications.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.SysTime.GetTime">
            <summary>
            Returns the current time relative to time the system started.
            </summary>
        </member>
        <member name="P:Neon.Time.SysTime.Now">
            <summary>
            Returns the current time relative to time the system started.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if there's a problem with the system timer.</exception>
        </member>
        <member name="P:Neon.Time.SysTime.Resolution">
            <summary>
            Returns the resolution of the underlying system timer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if there's a problem with the system timer.</exception>
        </member>
        <member name="P:Neon.Time.SysTime.Infinite">
            <summary>
            Returns what is essentially an infinite timespan.
            </summary>
            <remarks>
            <para>
            The value returned will calculated such that when added to the
            current <see cref="T:Neon.Time.SysTime" />.<see cref="P:Neon.Time.SysTime.Now" /> value that the
            result will be <see cref="F:System.DateTime.MaxValue" /> minus one year.
            </para>
            <para>
            This is useful for situations where you need specify an infinite
            timeout but you want to avoid wrap-around when adding this to
            the current <see cref="T:Neon.Time.SysTime" />.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if there's a problem with the system timer.</exception>
        </member>
        <member name="P:Neon.Time.SysTime.ExternalNow">
            <summary>
            <para>
            Tracks an external time source.
            </para>
            <note>
            This currently throws a <see cref="T:System.NotImplementedException"/>.
            </note>
            </summary>
            <remarks>
            <para>
            The <see cref="T:Neon.Time.SysTime" /> class is also capable of maintaining rough
            synchronization with an external time source.  To use this feature,
            you'll periodically get the time from the external source and assign
            it to the static <see cref="P:Neon.Time.SysTime.ExternalNow" /> property then you can
            use the <see cref="P:Neon.Time.SysTime.ExternalNow" /> property to get and estimate of the
            current external time.
            </para>
            <para>
            The local side clock will likely drift over time, resulting in a skew
            between the time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> and the actual
            time at the external source.  This skew can be limited by getting the
            external time and assigning it to <see cref="P:Neon.Time.SysTime.ExternalNow" /> more
            frequently.
            </para>
            <note>
            The time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> is not guaranteed to be
            monotimically increasing since reported times may jump around as the
            bias between the local and external clocks are adjusted.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Time.SysTime.Reset">
            <summary>
            Used by Unit tests to reset the timer class to its initial value.
            </summary>
        </member>
        <member name="T:Neon.Time.TimeOfDay">
            <summary>
            Represents the time offset since the beginning of the day.
            </summary>
            <threadsafety instance="true" />
        </member>
        <member name="M:Neon.Time.TimeOfDay.TryParse(System.String,Neon.Time.TimeOfDay@)">
            <summary>
            Attempts to parse a string of the form HH:MM or HH:MM:SS into a
            time of day offset.
            </summary>
            <param name="value">The string to be parsed.</param>
            <param name="timeOfDay">Returns as the parsed time of day on success.</param>
            <returns><c>true</c> if the string was parsed successfully, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.DateTime)">
            <summary>
            Constructs a time of day offset by stripping the date portion
            from the parameter passed.
            </summary>
            <param name="date">The source date time.</param>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a time of day offset from hours and minutes.
            </summary>
            <param name="hours">The hours.</param>
            <param name="minutes">The minutes.</param>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a time of day offset from hours, minutes, and seconds.
            </summary>
            <param name="hours">The hours.</param>
            <param name="minutes">The minutes.</param>
            <param name="seconds">The seconds.</param>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.String)">
            <summary>
            Constructs a time of day offset by parsing a string of the form HH:MM or HH:MM:SS.
            </summary>
            <param name="value">The input string.</param>
            <exception cref="T:System.ArgumentException">Thrown if the string passed does not represent a valid time of day offset.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.TimeSpan)">
            <summary>
            Constructs a time of day offset from a <see cref="P:Neon.Time.TimeOfDay.TimeSpan" />.
            </summary>
            <param name="offset">The time offset from the beginning of the day.</param>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.Validate">
            <summary>
            Checks to make sure that the specified offset is valid.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="P:Neon.Time.TimeOfDay.Hour">
            <summary>
            Returns the hours part of the time offset.
            </summary>
        </member>
        <member name="P:Neon.Time.TimeOfDay.Minute">
            <summary>
            Returns the minutes part of the time offset.
            </summary>
        </member>
        <member name="P:Neon.Time.TimeOfDay.Second">
            <summary>
            Returns the seconds part of the time offset.
            </summary>
        </member>
        <member name="P:Neon.Time.TimeOfDay.TimeSpan">
            <summary>
            Returns the offset as a <see cref="P:Neon.Time.TimeOfDay.TimeSpan" />.
            </summary>
        </member>
        <member name="M:Neon.Time.TimeOfDay.ToString">
            <summary>
            Renders the time of day value as a string formatted as HH:MM:SS.
            </summary>
            <returns>The formatted string.</returns>
        </member>
        <member name="T:Neon.Windows.MEMORYSTATUSEX">
            <summary>
            Holds information about memory utilization for a Windows computer.
            </summary>
        </member>
        <member name="M:Neon.Windows.MEMORYSTATUSEX.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.dwLength">
            <summary>
            Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.dwMemoryLoad">
            <summary>
            Number between 0 and 100 that specifies the approximate percentage of physical memory that is in use (0 indicates no memory use and 100 indicates full memory use).
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.ullTotalPhys">
            <summary>
            Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.ullAvailPhys">
            <summary>
            Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.ullTotalPageFile">
            <summary>
            Size of the committed memory limit, in bytes. This is physical memory plus the size of the page file, minus a small overhead.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.ullAvailPageFile">
            <summary>
            Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.ullTotalVirtual">
            <summary>
            Total size of the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.ullAvailVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Neon.Windows.MEMORYSTATUSEX.ullAvailExtendedVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the extended portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="T:Neon.Windows.NamespaceDoc">
            <summary>
            This namespace defines low-level Windows P/Invoke mappings as well as
            a simply class that can execute PowerShell commands.
            </summary>
        </member>
        <member name="T:Neon.Windows.PowerShell">
            <summary>
            <para>
            A simple proxy for executing PowerShell commands on Windows machines.
            </para>
            <note>
            This class requires elevated administrative rights.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Windows.PowerShell.PwshPath">
            <summary>
            Optional path to the Powershell Core <b>pwsh</b> executable.  The <b>PATH</b>
            environment variable will be searched by default.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.GetPwshPath">
            <summary>
            Returns the path to the Powershell Core <b>pwsh</b> executable.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.#ctor(System.Action{System.String},System.Action{System.String})">
            <summary>
            Default constructor to be used to execute local PowerShell commands.
            </summary>
            <param name="outputAction">Optionally specifies an action to receive logged output.</param>
            <param name="errorAction">Optionally specifies an action to receive logged error output.</param>
            <exception cref="T:System.NotSupportedException">Thrown if we're not running on Windows.</exception>
            <remarks>
            You can pass callbacks to the <paramref name="outputAction"/> and/or <paramref name="errorAction"/>
            parameters to be receive logged output and errors.  Note that <paramref name="outputAction"/> will receive
            both STDERR and STDOUT text if <paramref name="errorAction"/> isn't specified.
            </remarks>
        </member>
        <member name="M:Neon.Windows.PowerShell.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.Dispose">
            <summary>
            Releases all resources associated with the instance.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Windows.PowerShell.ExpandEnvironmentVars(System.String)">
            <summary>
            Expands any environment variables of the form <b>${NAME}</b> in the input
            string and returns the expanded result.
            </summary>
            <param name="input">The input string.</param>
            <returns>The expanded output string.</returns>
        </member>
        <member name="M:Neon.Windows.PowerShell.Execute(System.String,System.Boolean)">
            <summary>
            Executes a PowerShell command that returns a simple string result.
            </summary>
            <param name="command">The command string.</param>
            <param name="noEnvironmentVars">
            Optionally disables that environment variable subsitution (defaults to <c>false</c>).
            </param>
            <returns>The command response.</returns>
            <exception cref="T:Neon.Windows.PowerShellException">Thrown if the command failed.</exception>
        </member>
        <member name="M:Neon.Windows.PowerShell.ExecuteJson(System.String,System.Boolean)">
            <summary>
            Executes a PowerShell command that returns result JSON, subsituting any
            environment variable references of the form <b>${NAME}</b> and returning a list 
            of <c>dynamic</c> objects parsed from the table with the object property
            names set to the table column names and the values parsed as strings.
            </summary>
            <param name="command">The command string.</param>
            <param name="noEnvironmentVars">
            Optionally disables that environment variable subsitution (defaults to <c>false</c>).
            </param>
            <returns>The list of <c>dynamic</c> objects parsed from the command response.</returns>
            <exception cref="T:Neon.Windows.PowerShellException">Thrown if the command failed.</exception>
        </member>
        <member name="T:Neon.Windows.PowerShellException">
            <summary>
            Thrown by <see cref="T:Neon.Windows.PowerShell"/> when an error is detected.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShellException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The exception message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="T:Neon.Windows.Win32">
            <summary>
            Low-level Windows system calls.
            </summary>
        </member>
        <member name="M:Neon.Windows.Win32.GetPhysicallyInstalledSystemMemory(System.UInt64@)">
            <summary>
            Returns the total installed physical RAM as kilobytes.
            </summary>
            <param name="TotalMemoryInKilobytes">Returns as the physical RAM as KiB.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Windows.Win32.EncryptFile(System.String)">
            <summary>
            Has Windows encrypt a file or folder at rest.
            </summary>
            <param name="path">The file or folder path.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Windows.Win32.DecryptFile(System.String)">
            <summary>
            Has Windows decrypt a file or folder at rest.
            </summary>
            <param name="path">The file or folder path.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Windows.Win32.GlobalMemoryStatusEx(Neon.Windows.MEMORYSTATUSEX)">
            <summary>
            Obtains information about memory utilization on the current Windows machine.
            </summary>
            <param name="lpBuffer">Returns as a <see cref="T:Neon.Windows.MEMORYSTATUSEX"/> with the infirmation.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Windows.Win32.MakeWindowTopmost(System.IntPtr)">
            <summary>
            Relocates a window to be topmost in the z-order such that it will be
            above all other windows on the desktop.
            </summary>
            <param name="hWnd">Specifies the low-level handle for the target window.</param>
        </member>
        <member name="T:System.Diagnostics.Contracts.Covenant">
            <summary>
            A simple, lightweight, and inspired by the <see cref="T:System.Diagnostics.Contracts.Contract"/> class.
            </summary>
            <remarks>
            This class is intended to be a drop-in replacement for code contract assertions by simply
            searching and replacing <b>"Contract."</b> with "<see cref="T:System.Diagnostics.Contracts.Covenant"/>." in all source code.
            In my experience, code contracts slow down build times too much and often obsfucate 
            <c>async</c> methods such that they cannot be debugged effectively using the debugger.
            Code Contracts are also somewhat of a pain to configure as project propoerties.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Covenant.Requires``1(System.Boolean,System.String,System.String)">
            <summary>
            Verifies a method pre-condition throwing a custom exception.
            </summary>
            <typeparam name="TException">Specifies exception to be thrown if the condition is <c>false</c>.</typeparam>
            <param name="condition">Specifies the condition to be tested.</param>
            <param name="arg1">Optionally specifies the first string argument to the exception constructor.</param>
            <param name="arg2">Optionally specifies the second optional string argument to the exception constructor.</param>
            <remarks>
            <para>
            This method throws a <typeparamref name="TException"/> instance when <paramref name="condition"/>
            is <c>false</c>.  Up to two string arguments may be passed to the exception constructor when an
            appropriate constructor exists, otherwise these arguments will be ignored.
            </para>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Covenant.Requires``1(System.Boolean,System.Func{System.String},System.Func{System.String})">
            <summary>
            Verifies a method pre-condition throwing a custom exception using lambda functions
            to obtain the messages to be included in the exception.  Use this override for better
            performance when the messages need to be formatted at runtime.
            </summary>
            <typeparam name="TException">Specifies exception to be thrown if the condition is <c>false</c>.</typeparam>
            <param name="condition">Specifies the condition to be tested.</param>
            <param name="arg1Func">
            Specifies a function that returns first string argument to the exception constructor.
            This may be <c>null</c>.
            </param>
            <param name="arg2Func">
            Optionally a function that returns the second optional string argument to the exception constructor.
            </param>
            <remarks>
            <para>
            This method throws a <typeparamref name="TException"/> instance when <paramref name="condition"/>
            is <c>false</c>.  Up to two string arguments may be passed to the exception constructor when an
            appropriate constructor exists, otherwise these arguments will be ignored.
            </para>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Covenant.Assert(System.Boolean,System.String)">
            <summary>
            Asserts that a condition is <c>true</c>.
            </summary>
            <param name="condition">Specifies the condition to be tested.</param>
            <param name="message">Optionally spacifies the message to be included in the exception thrown.</param>
            <exception cref="T:Neon.Diagnostics.AssertException">Thrown if <paramref name="condition"/> is <c>false</c>.</exception>
        </member>
        <member name="M:System.Diagnostics.Contracts.Covenant.Assert(System.Boolean,System.Func{System.String})">
            <summary>
            Asserts that a condition is <c>true</c>.  Use this override for better performance
            when the message needs to be formatted at runtime.
            </summary>
            <param name="condition">Specifies the condition to be tested.</param>
            <param name="messageFunc">
            Specifies a lambda function that returns the message to be included in the
            exception thrown.  This may be <c>null</c>.
            </param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.StaticBytesDataSource">
            <summary>
            Implements a <see cref="T:ICSharpCode.SharpZipLib.Zip.IStaticDataSource"/> that wraps an in-memory byte array
            into a form suitable for adding to a <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.StaticBytesDataSource.#ctor(System.Byte[])">
            <summary>
            Constructs a source from raw bytes.
            </summary>
            <param name="data">The data array or <c>null</c>.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.StaticBytesDataSource.#ctor(System.String)">
            <summary>
            Constructs a source from a UTG-8 encoded string.
            </summary>
            <param name="data">The data string</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.StaticBytesDataSource.GetSource">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.StaticStringDataSource">
            <summary>
            Implements a <see cref="T:ICSharpCode.SharpZipLib.Zip.IStaticDataSource"/> that wraps a string to be
            returned as URF-8 encoded bytes into a form suitable for adding to a 
            <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipFile"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.StaticStringDataSource.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="text">The text or <c>null</c>.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.StaticStringDataSource.GetSource">
            <inheritdoc/>
        </member>
    </members>
</doc>
